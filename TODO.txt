- add something to the DAO which returns a wrapper around a statement/connection
	- allows you to do a .execute, .query, etc.. depending on the type, maybe subclassed
	- allows you to set arguments with array or individually
	- has a .close() or .release() and lots of documentation around it

- maybe watch the number of connections gotten from a connection source that aren't released
	- maybe keep an exception to be used to track the caller

- support for JTA annotations, whatever the common one is
	- maybe also JDO?

- support for embedded objects
	- look to see if the unknown class has a DatabaseTable(embedded = true) or javax annotation
	- take all of the fields as if they were fields in this class
	- embedded keys are going to be _hard_, maybe not support them

- from nelson: can ORMLite build the join table to help with mapping many-to-many relationships?
	- if something has a foreign collection, allow a joinTable=true, maybe joinTableName="..."
	- the foreign object does _not_ need to have a foreign field
	- maybe joinClass="..." which defines the fooId, barId object?
	- builds the sub-query internally itself
	- implements the many-to-one type of restriction based on unique-ness restrictions?
		- manyToOne puts a unique limitation on the other object's id
		- oneToMany puts a unique limitation on this object's id 
	- automatically puts an index on stuff?  index=true or something
	- Accounts are associated with many Customers, Customers may have more than one Account
	- three table: account, customer, account_customer
	- account_customer has a column for account_id and customer_id to handle this relationship
	- how can ORMLite assist in the loading of a Java list of Customers on an Account object

- more support for more constraints (other than primary and unique):
	- maybe a check="> 10" type of addition to DatabaseField so we can add a check constraint
	- foreign key constraint can be in addition to (or required for) the foreign=true
	- is this handled by the columnDefinition?

- DANGER: might be some problems with how we pass around object cache objects internally:
	- in the case of foreign-auto-refresh, we may be passing the object cache of the parent object in

- look into migrating the foreign collections to use AbstractCollection as a simplification
	- how about AbstractSet?

- the Foreign Collections have an addAll method which takes a List type:
	- DAO's could have a createAll/createOrUpdateAll which would use the batch tasks

- there are a number of places in StatementExecutor where we do this:
		if (mappedQueryForId == null) {
			mappedQueryForId = MappedQueryForId.build(databaseType, tableInfo, null);
		}
		- this is the classic initialization out of order race condition with multiple threads using the DAO
		- maybe just bite the bullet and do the initialization at the start
		- or maybe give users a DAO call to do all of the builds at once
		- i do wonder if aggressive refactoring can get rid of a lot of the custom statements

- fix ignored tests inside of ForeignCollectionTest

- TableUtils from JC:
	- TableUtils.alterTableAddColumns(connectionSource, dataClass, String... columnOrFieldNames);
	- TableUtils.alterTableDropColumns(connectionSource, dataClass, String... columnOrFieldNames);

- add an autoCreate=true feature to the @ForeignCollectionField
	- after an object is created, if it has a foreign collection that is auto-create an eager collection is created
		and set on the field if it is null
	- do we have to do the query in case an object is created which already has entries in the collection?	

- how to support encryption in the databases
	- custom field persisters?
	- some sort of converter between the DatabaseConnection and the database
		- override the update() method to encrypt the args
		- override the get* methods to decrypt the database values
	- some sort of Dao converter at a higher level
		- inject a DataConverter or some sort which would be handled by the Dao like the object cache
	- some sort of @DatabaseField(encrypted = true) setting?
		- how would it inject it?
		- how would it change the schema?
	- maybe some sort of DataPersister proxy?
	- How does this effects the schema?  Every SQL native field would turn into a String which is some encrypted
		representation of the value?  Would you define something to be a long but if the DataConverter is in place it
		would turn into a String and do a DatabaseResults.getString(1) but then return a long once it has been
		decrypted?

- add foreign key constraints to better support the foreign=true stuff

- need to add a Foreign field section under the query builder section
	- needs to explain how to do queries for foreign fields
	- need to explain that we can't query for a foreign collection

- look into storing the underlying compiled statement somewhere
	- maybe cacheing it per connection?
	- maybe each connection has a setQueryForId(), etc. type of call on it
	- it probably needs to be a thread local so we can set args on it
	- some sort of boolean to turn this on
	- look into a prepared query which keeps the connection open to the database
		- needs to have a lot of warnings on it
		- maybe the query keeps a cache of compiled statements per connection
		- or maybe the connection keeps the cache of compiled statements.  key is the PreparedQuery.
		- thread locals?  how to turn on/off, maybe just do for queryForAll, queryForId, insert, delete, etc.
		- maybe a flag on the prepared query to have it cache

- support batch inserts that we can compile a statement and then directly set the args on it for each data object from a collection
	- maybe get rid of the Object[] arguments and set the arguments directly from the data
	- add in a bulk insert which will compile the insert statement and just set args for each entry

- flesh out the SimpleDB version of the library:
	- get all tests passing
	- think about batch operations
	- maybe add a insert(Collection)?

- backend for HBase (Hadoop's bigtable) 

- test QueryBuilder.groupBy() in field and raw form
	- org.h2.jdbc.JdbcSQLException: Column "FOO.ID" must be in the GROUP BY list; SQL statement:

- new methods in the DAO:
	- updateNonDefault()
		- update only those fields that are not null
	- createOrUpdateNonDefault()

- better detection of whether a table exists or not:
   static boolean tableExists(JdbcConnectionSource connSource, final String tableName) throws SQLException {
       JdbcDatabaseConnection c = (JdbcDatabaseConnection) connSource.getReadOnlyConnection();
       DatabaseMetaData metaData = c.getInternalConnection().getMetaData();
       ResultSet rs = metaData.getTables(null, null, null, new String[]{ "TABLE" });
       try {
           while (rs.next()) {
               int numColumns = rs.getMetaData().getColumnCount();
               for (int i = 1; i < numColumns; i++) {
                   if (tableName.equalsIgnoreCase(rs.getString(i))) {
                       return true;
                   }
               }
           }
       } finally {
           if (rs != null) {
               rs.close();
           }
       }
       return false;
   }

-----------------------------------------------------------------------------------------------------------------------------------

- add a createTable call to the DAO instead of using tableUtils
	- ANSWER: adding a createTable() would also add a dropTable().  These are constructive enough to not but on the DAO.

- for objects that a user does not have control over, how about the ability of defining a Method to construct a particular class
	- ANSWER: not good cost/benefit
	- when you create the dao, you have to somehow inject a Method which returns a new object of a certain type
	- can't do it as part of the annotation, has to be setup with a DatabaseTableConfig I guess
	- this will allow you to call a constructor with (for example) some null fields to get an instance that can be overridden
	- should we do the same for setters and getters?  use this method to set the field, use this to get it? (doesn't sound worth it)

- allow any field as the foreign id column (not just the id field)
	- ANSWER: not good cost/benefit
	- specify the field in the remote object (must match the name directly)
	- creates a prepared query 'WHERE field = value'
	- uses queryForFirst to return object
	- creates account_field-name instead of account_id field in local table 

- anyway to simplify the query builder call structure:
	- ANSWER: for now we leave it as it.  Added Where.raw(), .query(), and .iterator() methods
	- take a look at http://www.javalobby.org/articles/activeobjects/
	- Person[] people = manager.find(Person.class, Query.select().where("age > 18").limit(10));
	- dao.queryBuilder().where().gt("age", 18).limit(10);
	- maybe have a query(), delete(), update(), ... methods on Where?

- think about proxy objects for foreign objects that can throw if they do anything but getId()
	- ANSWER: for now we leave it as it is since it works and is simple, ORMLite != ORMMediumOrHeavy
	- expensive indirection?
	- cglib dependency?
	- this starts down the road towards caching the DataSource in some proxy object
		- maybe just heavily document it and say to use the refresh directly if want to
		- reinventing the hibernate wheel?
	- or maybe they just auto-refresh when someone accesses a field
	- maybe it has a null object initially and replaces it with a real object to invoke on 
	- just extend BaseJdbcDao so it can query the class by itself
		- maybe ask the class loader if it has a Dao for that class?

- how about the avg, sum, etc. stuff, how should those work
	- ANSWER: for now just handle with the RawResults SQL query support
	- we can't create a T object because of the avg field -- where would it go?
	- maybe allow fields in a T object that are used to store avg and other information returned from them
	- we would need to auto-group any requested fields
	- what does it break if we have the sum/group, ordering?
	- maybe specify the object to fill in with a query
	- have each of the fields annotated with group(x) or avg(y)
	- AVG(), COUNT(), FIRST(), LAST(), MAX(), MIN(), SUM(), DISTINCT

- should we handle all non-number arguments to queries to be ? and force internal SelectArgs?
	- ANSWER: they can use SelectArgs if they want, expensive otherwise
	- would be better for escaping reasons
	- now have field types in the queries so escaping better
	- increased object overhead?

- can we use the jdbc connection meta data to detect whether or not generated-ids are supported
	- ANSWER? - maybe not.  The methods don't match our code right.
 	- DatabaseMetaData metaData = connection.getMetaData();
	- metaData.supportsGetGeneratedKeys() -- not exactly what we need
	- supportsMultipleTransactions() -- in different connections so not relevant
