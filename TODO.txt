- allow any field as the foreign id column (not just the id field)
	- specify the field in the remote object (must match the name directly)
	- creates a prepared query 'WHERE field = value'
	- uses queryForFirst to return object
	- creates account_field-name instead of account_id field in local table 

- maybe add rawUpdate and rawExecute?
	- add documentation for update, execute in .texi

- for objects that a user does not have control over, how about the ability of defining a Method to construct a particular class
	- when you create the dao, you have to somehow inject a Method which returns a new object of a certain type
	- can't do it as part of the annotation, has to be setup with a DatabaseTableConfig I guess
	- this will allow you to call a constructor with (for example) some null fields to get an instance that can be overridden
	- should we do the same for setters and getters?  use this method to set the field, use this to get it? (doesn't sound worth it)

- support for embedded objects
	- look to see if the unknown class has a DatabaseTable(embedded = true or javax annotation
	- take all of the fields as if they were fields in this class

- more support for more constraints (other than primary and unique):
	- maybe a check="> 10" type of addition to DatabaseField so we can add a check constraint
	- foreign key constraint can be in addition to (or required for) the foreign=true

- from nelson: how to better handle the foreign key relationships.  How can we build the JOIN query.
	- i was hoping to avoid the join complexity/dance that hibernate does.
	- we could configure the DAO on the foreign field itself by attaching a BaseDaoImpl
	- one Dao would call the other when it needs to refresh a foreign field
	- still making two queries but doing it auto-magically
	- do we need to worry about object dependency loops: account1 has a user1 which has an account1

- how to help with remote IN queries (similar to above?):
	- select * from puzzles where id in (select puzzle_id from solutions group by puzzle_id)
	- is there a generic case here?
	- define a query for a foreign-id in another table
	- somehow able to do a Where.in(id-query) -- maybe that's the generic solution

- from nelson: can ORMLite help out with mapping many-to-many relationships?
	- could it help with building the join table?
	- Accounts are associated with many Customers, Customers may have more than one Account
	- three table: account, customer, account_customer
	- account_customer has a column for account_id and customer_id to handle this relationship
	- how can ORMLite assist in the loading of a Java list of Customers on an Account object
	- at least a List of customer ids?

- implement a "keep-alive" query ("select 1") to keep a connection warm
	- for the pooled connection source
	- needs another thread to run select 1 every minute or so
	- should do a select 1 when the connection is handed to us and not closed
	- database type should define the keep-alive query

- delete method which deletes all of the rows that match a particular field.
	- to support the foreign key stuff.
	- deleteFieldEquals(String fieldName, Object value);
	- List<Object> selectFieldEquals(String fieldName, Object value);

- from Larry: an example-based query, where you supply an object with fields set as criteria
	- no setting --> no criteria for that field
	- primitive types a problem for the 'no criteria' case
	- maybe it would be better to have a Map with values 

- need better documentation about the iterator
	- example about how to use it outside of a for loop

- JDO annotations?
	- support as well as the JPA

- anyway to simplify the query builder call structure:
	- take a look at http://www.javalobby.org/articles/activeobjects/
	- Person[] people = manager.find(Person.class, Query.select().where("age > 18").limit(10));
	- dao.queryBuilder().where().gt("age", 18).limit(10);
	- maybe have a .prepare() method on Where?
	- maybe have a query(), delete(), update(), ... methods on Where?

- flesh out the SimpleDB version of the library:
	- get all tests passing
	- think about batch operations
	- maybe add a insert(Collection)?

- backend for HBase (Hadoop's bigtable) 

- general documentation on schema creation:
	- how to do it by hand with TableUtils
	- how to use TableCreator

- consider allowing auto foreign object creation and updating with internal doa's
	- use the base dao for updating
	- need to be careful of recursion
	- how would create work?  Maybe you could see if the id was set or something

-----------------------------------------------------------------------------------------------------------------------------------

- think about proxy objects for foreign objects that can throw if they do anything but getId()
	- ANSWER: for now we leave it as it is since it works and is simple, ORMLite != ORMMediumOrHeavy
	- expensive indirection?
	- cglib dependency?
	- this starts down the road towards caching the DataSource in some proxy object
		- maybe just heavily document it and say to use the refresh directly if want to
		- reinventing the hibernate wheel?
	- or maybe they just auto-refresh when someone accesses a field
	- maybe it has a null object initially and replaces it with a real object to invoke on 
	- just extend BaseJdbcDao so it can query the class by itself
		- maybe ask the class loader if it has a Dao for that class?

- how about the avg, sum, etc. stuff, how should those work
	- ANSWER: for now just handle with the RawResults SQL query support
	- we can't create a T object because of the avg field -- where would it go?
	- maybe allow fields in a T object that are used to store avg and other information returned from them
	- we would need to auto-group any requested fields
	- what does it break if we have the sum/group, ordering?
	- maybe specify the object to fill in with a query
	- have each of the fields annotated with group(x) or avg(y)
	- AVG(), COUNT(), FIRST(), LAST(), MAX(), MIN(), SUM(), DISTINCT

- should we handle all non-number arguments to queries to be ? and force internal SelectArgs?
	- ANSWER: they can use SelectArgs if they want, expensive otherwise
	- would be better for escaping reasons
	- now have field types in the queries so escaping better
	- increased object overhead?

- can we use the jdbc connection meta data to detect whether or not generated-ids are supported
	- ANSWER? - maybe not.  The methods don't match our code right.
 	- DatabaseMetaData metaData = connection.getMetaData();
	- metaData.supportsGetGeneratedKeys() -- not exactly what we need
	- supportsMultipleTransactions() -- in different connections so not relevant
