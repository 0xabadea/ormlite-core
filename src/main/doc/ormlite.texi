\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename ormlite.info
@settitle ORM Lite Documentation
@setchapternewpage odd
@headings double
@c %**end of header

@dircategory Libraries
@direntry
* ORMLite: (orm lite).			Lightweight ORM package.
@end direntry

@c ----------------------------------------------------------------
@c This file has the new style title page commands.
@c Also, it uses `@@include' files instead of `@@input' files.

@c Run using special version of `texinfo.tex'.

@c Also, run `makeinfo' rather than `texinfo-format-buffer'.
@c ----------------------------------------------------------------

@c ----------------------------------------------------------------
@set ormlite_version 4.4
@set ormlite_date November 2010
@set package ORMLite
@c ----------------------------------------------------------------

@ifinfo
This file is an introduction to the ORM Lite package which is a simple Object Relationship Mapping package.

Copyright 2010 by Gray Watson.

Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice
and this permission notice are preserved on all copies.
@end ifinfo

@titlepage
@title ORM Lite Package
@subtitle Version @value{ormlite_version}
@subtitle @value{ormlite_date}
@author Gray Watson

@page
Copyright 2010 by Gray Watson.

Published by Gray Watson

Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice
and this permission notice are preserved on all copies.
@end titlepage

@c ----------------------------------------------------------------
@node Top, Getting Started, (dir), (dir)
@top @value{package}

Version @value{ormlite_version} -- @value{ormlite_date}

@cindex introduction
@cindex author
@cindex object relational mapping
@cindex hibernate
@cindex ibatis
@value{package} provides a lightweight Object Relational Mapping between Java classes and SQL databases -- see
@uref{http://en.wikipedia.org/wiki/Object-relational_mapping}.  There are certainly more mature ORMs which
provide this functionality including Hibernate and iBatis.  However, the author wanted a simple yet powerful
wrapper around the JDBC functions and Hibernate and iBatis are significantly more complicated with many
dependencies.

@cindex databases supported
@cindex supported databases
@value{package} supports JDBC connections to MySQL, Postgres, Microsoft SQL Server, H2, Derby, HSQLDB, and
Sqlite and can be extended to additional ones relatively easily.  @value{package} also supports native database
calls on Android OS.  There are also initial implementations for DB2 and Oracle although the author needs
access to each of these database types to tune the support.  Contact the author if your database is not supported.

@cindex code examples
@cindex examples of code
To get started quickly with @value{package}, see the code examples down in the @code{com.j256.ormlite.examples}
package test classes in the Java sources jar down in @code{src/test/java}.  They contain a couple different
examples with working code.
@ifhtml
There is also a PDF version of this documentation -- see
@uref{http://ormlite.sourceforge.net/javadoc/ormlite-core/doc-files/ormlite.pdf}.
@end ifhtml
@iftex
There is also a HTML version of this documentation -- see
@uref{http://ormlite.sourceforge.net/javadoc/ormlite-core/doc-files/ormlite.html}.
@end iftex

Gray Watson @uref{http://256.com/gray/}

@menu
* Getting Started::             Getting started with @value{package}.
* Using::                       More details on how to use the system.
* Statement Builder::           How to use the custom statement builder.
* Foreign Objects::             Fields that represent foreign objects.
* Use With Android::            Using with the Android OS.
* How to Upgrade::              Upgrading from a previous version.
* Advanced::                    Advanced concepts with @value{package}.
* Contributions::               Contributions from others who helped.
* Index of Concepts::           Index of concepts in the manual.
@end menu

@c ----------------------------------------------------------------
@node Getting Started, Downloading, Top, Top
@chapter Getting Started

@menu
* Downloading ::                Downloading the @value{package} jar.
* Starting Class::              Configuring a class to persist.
* Starting DAO::                Configuring a Data Access Object.
* Starting Client::             Client code example on how its works.
@end menu

@c ----------------------------------------------------------------
@node Downloading, Starting Class, Getting Started, Getting Started
@section Downloading @value{package} Jar

To get started with @value{package}, you will need to download the jar file.  It is available on the central maven repository
(@uref{http://repo1.maven.org/maven2/com/j256/ormlite/}) or from Sourceforge (@uref{http://sourceforge.net/projects/ormlite/files/}). 

Users that are connecting to SQL databases via JDBC connections will need to download the ormlite-jdbc-X.X.jar file. For use with Android
applications, you should download the ormlite-android-X.X.jar instead. @value{package} does not have any required direct dependencies.
See the section on external dependencies for information about other packages that you may want to use.  @xref{Dependencies}.  The code
works with Java 5 or later.

@c ----------------------------------------------------------------
@node Starting Class, Starting DAO, Downloading, Getting Started
@section Configuring a Class

The following is an example class that is configured to be persisted to a database using @value{package} annotations.  The @code{@@DatabaseTable}
annotation configures the Account class to be persisted to the database table named @code{accounts}. The @code{@@DatabaseField} annotations map
the fields on the Account to the database columns with the same names.

The name field is configured as the primary key for the database table by using the @code{id = true} annotation field.  Also, notice that a
no-argument constructor is needed so the object can be returned by a query. For more information see the class setup information later in the
manual.  @xref{Class Setup}.

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
    
    @@DatabaseField(id = true)
    private String name;
    @@DatabaseField
    private String password;
    
    public Account() @{
        // @value{package} needs a no-arg constructor 
    @}
    public Account(String name, String password) @{
        this.name = name;
        this.password = password;
    @}
    public String getName() @{
        return name;
    @}
    public String getPassword() @{
        return password;
    @}
@}
@end example

@c ----------------------------------------------------------------
@node Starting DAO, Starting Client, Starting Class, Getting Started
@section Configuring a DAO

A typical Java pattern is to isolate the database operations in Database Access Objects or DAO classes. Each DAO provides create, delete,
update, etc. type of functionality and specializes in the handling a particular persisted class.  To set up a DAO, you will need a DAO
interface and an implementation class.  @value{package} provides a base DAO interface and a base implementation class. The following is
an example DAO interface corresponding to the Account class from the previous section of the manual:

@example
/** Account DAO which has a String id (Account.name) */
public interface AccountDao extends Dao<Account,String> @{
    // empty wrapper, you can add additional DAO methods here
@}
@end example

The following is the example implementation class:

@example
/** JDBC implementation of the AccountDao interface. */
public class AccountDaoImpl extends BaseDaoImpl<Account,String>
 implements AccountDao @{
    public AccountDaoImpl(ConnectionSource connectionSource) throws SQLException @{
        super(connectionSource, Account.class);
    @}
@}
@end example

You are not @emph{required} to create a DAO class for every one of your persisted objects.  You can use the
@code{createDao} static method on the @code{BaseDaoImpl} class to create a DAO class without having to define
one.  For example:

@example
Dao<Account, String> accountDao =
  BaseDaoImpl.createDao(connectionSource, Account.class);
Dao<Order, Integer> orderDao =
  BaseDaoImpl.createDao(connectionSource, Order.class);
@end example

More information about setting up the DOAs is available later in the manual. @xref{DAO Setup}.

@c ----------------------------------------------------------------
@node Starting Client, Using, Starting DAO, Getting Started
@section Client Code Example

The client code in this section demonstrates how to use the classes presented in the previous two sections. The code uses H2 as a test database
instance. You will need to add the H2 jar file to your classpath if you want to run the example as-is.  @emph{NOTE:} Android users should see the
Android specific documentation later in the manual. @xref{Use With Android}.

The client performs the following steps.

@itemize @bullet
@item It creates a connection source which handles connections to the database.
@item It instantiates a AccountDaoImpl.
@item The @code{accounts} database table is created. This step is not needed if the table already exists.
@end itemize

@example
public class AccountApp @{

    public static void main(String[] args) throws Exception @{

        // this uses h2 by default but change to match your database
        String databaseUrl = "jdbc:h2:mem:account";
        // create a connection source to our database
        ConnectionSource connectionSource =
            new JdbcConnectionSource(databaseUrl);

        // instantiate the dao
        AccountDaoImpl accountDao = new AccountDaoImpl(connectionSource);

        // if you need to create the 'accounts' table make this call
        TableUtils.createTable(connectionSource, Account.class);
 @end example

Once we have configured our database objects, we can use them to create an Account, persist it to the database, and query for it from
the database by its ID:

@example
        // create an instance of Account
        Account account = new Account();
        account.setName("Jim Coakley");

        // persist the account object to the database
        // it should return 1 for the 1 row inserted
        if (accountDao.create(account) != 1) @{
            throw new Exception("Failure adding account");
        @}
		
        // retrieve the account
        Account account2 = accountDao.queryForId("Jim Coakley");
        System.out.println("Account: " + account2.getName());

        // close the connection source
        connectionSource.close();
    @}
@}
@end example

You should be able to get started using @value{package} by this point. To understand more of the functionality available with @value{package},
continue on with the next section.  @xref{Using}.

@c ----------------------------------------------------------------
@node Using, Class Setup, Starting Client, Top
@chapter How to Use

@menu
* Class Setup::                 How to setup your classes to be persisted.
* Persisted Types::             Data types that can be persisted.
* DAO Setup::                   How to configure the Database Access Objects.
* Connection Source::           Setting up connections to databases.
* Database Type::               Defining your database type.
* Database Notes::              Support databases and associated notes.
* Complete Wiring::             Tying all of the wiring together.
* DAO Usage::                   Using the Database Access Objects.
* Identity Columns::            How identity fields and columns work.
@end menu

@c ----------------------------------------------------------------
@node Class Setup, Local Annotations, Using, Using
@section Setting Up Your Classes

To setup your classes to be persisted you need to do the following things:

@enumerate
@item Add the @@DatabaseTable annotation to the top of each class.  You can also use @@Entity.
@item Add the @@DatabaseField annotation right before each field to be persisted.  You can also use @@Column and others.
@item Add a no-argument constructor to each class with at least package visibility.
@end enumerate

@menu
* Local Annotations::                Adding the annotations to your classes.
* Javax Persistence Annotations::    Using javax.persistence annotations instead.
* No Arg Constructor::               A no-argument-constructor is also required.
@end menu

@c ----------------------------------------------------------------
@node Local Annotations, Javax Persistence Annotations, Class Setup, Class Setup
@subsection Adding @value{package} Annotations

@cindex annotations
@cindex java annotations
@cindex @@DatabaseTable
@cindex DatabaseTable annotation
Annotations are special code markers have have been available in Java since version 5 that provide meta information
about classes, methods, or fields.  To specify what classes and fields to store in the database, @value{package}
supports either its own annotations (@code{@@DatabaseTable} and @code{@@DatabaseField}) or the more standard
annotations from the @code{javax.persistence} package.  @xref{Javax Persistence Annotations}.   Annotations are the
easiest way to configure your classes but you can also configure the class using Java code or Spring XML.
@xref{Class Configuration}.

With @value{package} annotations, for each of the Java classes that you would like to persist to your SQL database, you
will need to add the @code{@@DatabaseTable} annotation right above the @code{public class} line.  Each class marked with
one of these annotations will be persisted into its own database table.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@DatabaseTable} annotations can have an optional @code{tableName} argument which specifies the name of the table
that corresponds to the class.   If not specified, the class name, all lowercase, is used by default.  With the above example
each @code{Account} object will be persisted as a row in the @code{accounts} table in the database.  If the @code{tableName}
was not specified, the @code{account} table would be used instead.

@cindex @@DatabaseField
@cindex DatabaseField annotation
Additionally, for each of the classes, you will need to add a @code{@@DatabaseField} annotation to each of the @emph{fields}
in the class that are to be persisted to the database.  Each field is persisted as a column of a database row.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{

    @@DatabaseField(id = true)
    private String name;

    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}
@end example

In the above example, each row in the @code{accounts} table has 2 columns:

@itemize @bullet
@item the @code{name} column which is a string and also is the database identity (id) of the row
@item the @code{password} column, also a string which can not be null
@end itemize 

The @@DatabaseField annotation can have the following fields:

@table @code

@cindex column name
@cindex name of database column
@anchor{columnName}
@item columnName

String name of the column in the database that will hold this field. If not set then the field name, all lowercase, is used instead.

@cindex field type
@cindex jdbc type
@cindex SQL type
@item dataType

The type of the field as the DataType class.  Usually the type is taken from Java class of the field and does not need
to be specified.  This corresponds to the SQL type.  @xref{Persisted Types}.

@cindex default value
@item defaultValue

String default value of the field when we are creating a new row in the table.  Default is none.

@cindex field width
@cindex width of field
@cindex length of field
@item width

Integer width of array fields -- usually for strings.  Some databases do not support this unfortunately.  Default for 
those that do is 255.

@cindex can be null
@cindex null value allowed
@item canBeNull

Boolean whether the field can be assigned to null value. Default is true.  If set to false then you must provide a value
for this field on every object inserted into the database.

@cindex id field
@cindex key field
@cindex primary key field
@item id

Boolean whether the field is the id field or not. Default is false. Only one field can have this set in a class. Id fields
uniquely identity a row.  If you don't have it set then you won't be able to use the query, update, refresh, and delete by
ID methods. Only one of this, @code{generatedId}, and @code{generatedIdSequence} can be specified.  @xref{Id Column}.

@cindex generated id
@cindex auto-generated id
@item generatedId

Boolean whether the field is an auto-generated id field. Default is false.  Only one field can have this set in a class.
This tells the database to auto-generate a corresponding id for every row inserted.  When an object with a generated-id
is created using the @code{Dao.create()} method, the database will generate an id for the row which will be returned and
set in the object by the create method.  Some databases require sequences for generated ids in which case the sequence
name will be auto-generated. To specify the name of the sequence use @code{generatedIdSequence}. Only one of this,
@code{id}, and @code{generatedIdSequence} can be specified.  @xref{GeneratedId Column}.

@cindex generated id sequence
@cindex database sequences
@cindex sequences
@item generatedIdSequence

String name of the sequence number to be used to generate this value.  Same as @code{generatedId} but you can specify the
sequence name to use.  Default is none. Only one field can have this set in a class. This is only necessary for databases
which require sequences for generated ids.  If you use generatedId instead then the code will auto-generate a sequence name.
Only one of this, @code{id}, and @code{generatedId} can be specified.  @xref{GeneratedIdSequence Column}.

@cindex foreign objects
@cindex remote objects
@item foreign

@cindex refreshing foreign objects
Boolean setting which identifies this field as corresponding to another class that is also stored in the database.
Default is false.  The field can not be a primitive type.  The other class must have an id field (either @code{id},
@code{generatedId}, or @code{generatedIdSequence}) which will be stored in this table. When an object is returned
from a query call, any foreign objects will @emph{just} have the id field set.  @xref{Foreign Objects}.

@cindex useGetSet
@cindex get and set method usage
@cindex using get and set methods
@cindex field access using getters and setters 
@item useGetSet

Boolean that says that the field should be accessed with get and set methods.  Default is false which instead uses
direct field access via Java reflection.  This may be necessary if the object you are storing has
protections around it.

@emph{NOTE:} The name of the get method @emph{must} match getXxx() where Xxx is the name of the field with the first
letter capitalized. The get @emph{must} return a class which matches the field's exactly. The set method @emph{must}
match setXxx(), have a single argument whose class matches the field's exactly, and return void.  For example:

@example
@@DatabaseField(useGetSet = true)
private Integer orderCount;

public Integer getOrderCount() @{
  return orderCount;
@}

public void setOrderCount(Integer orderCount) @{
  this.orderCount = orderCount;
@}
@end example

@cindex unknownEnumName
@cindex enumerated name unknown
@anchor{unknownEnumName}
@item unknownEnumName

If the field is a Java enumerated type then you can specify the name of a enumerated value which will be used if the
value of a database row is not found in the enumerated type.  If this is not specified and a database row @emph{does}
contain an unknown name or ordinal value then a @code{SQLException} is thrown when the row is being read from the database.
This is useful to handle backwards compatibility when handling out-of-date database values as well as forwards
compatibility if old software is accessing up-to-date data or if you have to roll a release back.

@cindex throwIfNull
@cindex primitive null values
@cindex null values and primitives
@item throwIfNull

Boolean that tells @value{package} to throw an exception if it sees a null value in a database row and is trying to store
it in a primitive field.  By default it is false.  If it is false and the database field is null, then the value of the
primitive will be set to 0 (false, null, etc.).  This can only be used on a primitive field.

@item persisted

Set this to be false (default true) to not store this field in the database. This is useful if you want to have
the annotation on all of your fields but turn off the writing of some of them to the database.

@cindex parse format
@cindex format, field
@item format

This allows you to specify format information of a particular field.  Right now only the Date fields support it when
a default value is being converted or if you are using the @code{JAVA_DATE_STRING} type.

@cindex unique constraint
@cindex constraint, unique
@item unique

Adds a constraint to the field that it has to be unique across all rows in the table.  This allows you to have a
unique field in the table even though it is not the id field.  For example, you might have an Account class which
has a generated account-id but you also want the email address to be unique across all Accounts.

@end table

@c ----------------------------------------------------------------
@node Javax Persistence Annotations, No Arg Constructor, Local Annotations, Class Setup
@subsection Using javax.persistence Annotations

@cindex javax.persistence
@cindex @@Entity
@cindex Entity annotation
Instead of using the @value{package} annotations (@pxref{Local Annotations}), you can use the more standard
annotations from the @code{javax.persistence} package.  In place of the @code{@@DatabaseTable} annotation, you can
use the @code{javax.persistence} @code{@@Entity} annotation.  For example:

@example
@@Entity(name = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@Entity} annotations can have an optional @code{name} argument which specifies the table name.   If not
specified, the class name all lowercase is used by default.

@cindex @@Column
@cindex @@Id
@cindex @@GeneratedValue
@cindex Column annotation
@cindex Id annotation
@cindex GeneratedValue annotation
@cindex @@OneToOne
@cindex OneToOne annotation
@cindex @@ManyToOne
@cindex ManyToOne annotation
Instead of using the @code{@@DatabaseField} annotation on each of the fields, you can use the @code{javax.persistence}
annotations: @code{@@Column}, @code{@@Id}, @code{@@GeneratedValue}, @code{@@OneToOne}, and @code{@@ManyToOne}. For example:

@example
@@Entity(name = "accounts")
public class Account @{

    @@Id
    private String name;

    @@Column(nullable = false)
    private String password;
    @dots{}
@end example

The following @code{javax.persistence} annotations and fields are supported:

@table @code

@item @@Column

Specifies the field to be persisted to the database.  You can also just specify the @code{@@Id} annotation.  The
following annotation fields are supported, the rest are ignored.

@table @code

@item name

Used to specify the name of the associated database column.  If not provided then the field name is taken.

@cindex field width
@cindex width of field
@cindex length of field
@item length

Specifies the length (or width) of the database field.  Maybe only applicable for Strings and only supported by
certain database types.  Default for those that do is 255.   Same as the @code{width} field in the
@code{@@DatabaseField} annotation.

@cindex can be null
@cindex null value allowed
@item nullable

Set to true to have a field not be able to be inserted into the database with a null value.  Same as the
@code{canBeNull} field in the @code{@@DatabaseField} annotation.

@cindex unique constraint
@cindex constraint, unique
@item unique

Adds a constraint to the field that it has to be unique across all rows in the table.  Same as the
@code{unique} field in the @code{@@DatabaseField} annotation.

@end table

@cindex id field
@cindex key field
@cindex primary key field
@item @@Id

Used to specify a field to be persisted to the database as a primary row-id.  If you want to have the id be
auto-generated, you will need to also specify the @code{@@GeneratedValue} annotation.

@item @@GeneratedValue

Used to define an id field as having a auto-generated value.  This is only used in addition to the @code{@@Id}
annotation.  See the @code{generatedId} field in the @code{@@DatabaseField} annotation for more details.

@item @@OneToOne or @@ManyToOne

Fields with these annotations are assumed to be foreign fields.  @xref{Foreign Objects}.  @value{package} does
@emph{not} enforce the many or one relationship nor does it use any of the annotation fields.  It just uses the
existence of either of these annotations to indicate that it is a foreign object.

@end table

If the @code{@@Column} annotation is used on a field that has a unknown type then it is assumed to be a
Serializable field and the object should implement @code{java.io.Serializable}.  @xref{serializable}.

@c ----------------------------------------------------------------
@node No Arg Constructor, Persisted Types, Javax Persistence Annotations, Class Setup
@subsection Adding a No-Argument-Constructor

@cindex no argument constructor
@cindex constructor with no args
After you have added the class and field annotations, you will also need to add a no-argument constructor with
@emph{at least} package visibility.  When an object is returned from a query, @value{package} constructs the object
using Java reflection and a constructor needs to be called.

@example
Account() @{
  	// all persisted classes must define a no-arg constructor
  	// with at least package visibility
@}
@end example

So your final example Account class with annotations and constructor would look like:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
	
    @@DatabaseField(id = true)
    private String name;
    
    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}

    Account() @{
        // all persisted classes must define a no-arg constructor
        // with at least package visibility
    @}
    @dots{}
@}
@end example

@c ----------------------------------------------------------------
@node Persisted Types, DAO Setup, No Arg Constructor, Using
@section Persisted Data Types

@cindex persisted types
@cindex types that are persisted
The following Java types can be persisted to the database by @value{package}.  Database specific code
helps to translate between the SQL types and the database specific handling of those types.
@xref{Database Type}.

@table @code

@cindex String
@item String (DataType.STRING)

Persisted as SQL type VARCHAR.  

@cindex boolean
@item boolean or Boolean (DataType.BOOLEAN or DataType.BOOLEAN_OBJ)

Persisted as SQL type BOOLEAN.

@cindex Date
@cindex java date
@cindex date formats
@item java.util.Date (DataType.JAVA_DATE, DataType.JAVA_DATE_LONG, or JAVA_DATE_STRING)

Persisted as SQL type TIMESTAMP.  @emph{NOTE:} This is a different class from @code{java.sql.Date}.
@emph{NOTE:} Certain databases only provide seconds resolution so the milliseconds will be 0.

You can also specify the @code{dataType} field to the @code{@@DatabaseField} annotation as a @code{DataType.JAVA_DATE_LONG}
in which case the milliseconds value of the @code{Date} will be stored as an LONG.  Or you can use
@code{DataType.JAVA_DATE_STRING} in which case the date will be stored as a string in @code{yyyy-MM-dd HH:mm:ss.SSSSSS}
format.  You can use the @code{format} field in @code{DatabaseField} to set the date to another format.

@emph{NOTE:} Because of reentrant issues with @code{SimpleDateFormat}, synchronization is done
every time a JAVA_DATE_STRING date is converted to/from the database.

@cindex byte
@item byte or Byte (DataType.BYTE or DataType.BYTE_OBJ)

Persisted as SQL type TINYINT.

@cindex short
@item short or Short (DataType.SHORT or DataType.SHORT_OBJ)

Persisted as SQL type SMALLINT.

@cindex int
@item int or Integer (DataType.INTEGER or DataType.INTEGER_OBJ)

Persisted as SQL type INTEGER.

@cindex long
@item long or Long (DataType.LONG or DataType.LONG_OBJ)

Persisted as SQL type BIGINT.

@cindex float
@item float or Float (DataType.FLOAT or DataType.FLOAT_OBJ)

Persisted as SQL type FLOAT.

@cindex double
@item double or Double (DataType.DOUBLE or DataType.DOUBLE_OBJ)

Persisted as SQL type DOUBLE.

@cindex Serializable
@cindex persist objects
@anchor{serializable}
@item Serializable (DataType.SERIALIZABLE)

Persisted as SQL type VARBINARY.  This is a special type that serializes an object as a sequence of bytes
and then deserializes it on the way back.  The field must be an object that implements the @code{java.io.Serializable}
interface.  Depending on the database type, there will be limits to the size of the object that can be stored.  YMMV.

@cindex Enum
@cindex enumerated types
@item enum or Enum (DataType.ENUM_STRING or DataType.ENUM_INTEGER)

Persisted by default as the enumerated value's string @emph{name} as a VARCHAR type.  You can also specify the
@code{dataType} field (from the @code{@@DatabaseField} annotation) as a @code{DataType.ENUM_INTEGER} in which case the
@code{ordinal} of the enum value will be stored as an INTEGER.  The name is the default (and recommended) because
it allows you to add additional enums anywhere in the list without worrying about having to convert data later.
If you insert (or remove) an enum from the list that is being stored as a number, then old data will be un-persisted
incorrectly.

@cindex unknownEnumName
You can also also specify an @emph{unknownEnumName} name with the @code{@@DatabaseField} annotation which will be
used if an unknown value is found in the database. @xref{unknownEnumName}. 

@end table

@emph{NOTE:} @value{package} also supports the concept of foreign objects where the id of another object is
stored in the database.  @xref{Foreign Objects}.

@c ----------------------------------------------------------------
@node DAO Setup, Connection Source, Persisted Types, Using
@section Setting Up the DAOs

@cindex DAO
@cindex database access object
@cindex id column
@cindex Dao interface
Once you have annotated your classes, you will need to create the DAO class(es).  The pattern that we recommend
is to define an interface which extends the @code{Dao} interface and will be used in the code.  The interface
isn't required but it is a good pattern so your code is less tied to JDBC for persistence.  Each DAO has two generic
parameters: the class we are persisting with the DAO, and the class of the ID-column that will be used to
identify a specific database row.  If you class does not have an ID field, you can put @code{Object} or @code{Void}
as the 2nd argument.  For example, in the above @code{Account} class, the "name" field is the ID column (id = true)
so the ID class is @code{String}.  Example:

@example
/** Account DAO which has a String id (Account.name) */
public interface AccountDao extends Dao<Account, String> @{
    // empty wrapper, you can add additional DAO methods here
@}
@end example

Here's the example implementation of this interface.

@cindex jdbc dao implementation
@example
/** JDBC implementation of the AccountDao interface. */
public class AccountDaoImpl extends BaseDaoImpl<Account, String>
  implements AccountDao @{
    public AccountDaoImpl(ConnectionSource connectionSource) throws SQLException @{
        super(connectionSource, Account.class);
    @}
@}
@end example

That's all you need to define your DAO classes.  You are free to add more methods to your DAO interfaces and
implementations if there are specific operations that are needed and not provided by the Dao base classes.
More on how to use these DAOs later. @xref{DAO Usage}.

@cindex createDao method
As mentioned above (@pxref{Starting DAO}), you are not @emph{required} to create a DAO class for every one of your persisted
objects. You can use the @code{createDao} static method on the @code{BaseDaoImpl} class to create a DAO class without having
to define one.

@c ----------------------------------------------------------------
@node Connection Source, Database Type, DAO Setup, Using
@section JDBC Connection Sources

@emph{NOTE:} With regards to connection sources, Android users should see the Android specific documentation later in the manual.
@xref{Use With Android}.

@cindex data source
@cindex connection source
@cindex database connection
@cindex simple connection source
To use the database and the DAO objects, you will need to configure what JDBC calls a @code{DataSource} (see the
@code{javax.sql.DataSource} class).  The @code{DataSource} is a factory for connections to the physical SQL
database.  Since @value{package} also supports non-JDBC connections, we use a subset of the @code{DataSource}
methods in the @code{ConnectionSource} interface so we can support non-JDBC database handlers.  Here is a code example
that creates a simple, single-connection source.

@cindex JdbcConnectionSource
@cindex connection source, simple
@example
// single connection source example
ConnectionSource connectionSource =
  new JdbcConnectionSource("jdbc:h2:mem:account");
@end example

@cindex pooled connection source
@cindex connection pooling
One of the more recent additions (10/2010) to the package is the @code{JdbcPooledConnectionSource}.  It is a relatively
simple implementation of a pooled connection source.  As database connections are released, instead of being closed they
are added to an internal list so they can be reallocated at a later time.  New connections are created on demand only if
there are no dormant connections that can be reused.  @code{JdbcPooledConnectionSource} is also synchronized and can be
used my multiple threads.  It has settings for the maximum number of free connections before they are closed as well as
a maximum age before a connection is closed.

@example
// single connection source example
JdbcPooledConnectionSource connectionSource =
  new JdbcPooledConnectionSource("jdbc:h2:mem:account");
// only keep the connections open for 5 minutes
connectionSource.setMaxConnectionAgeMillis(5 * 60 * 1000);
@end example

@cindex other data sources
@cindex external data sources
@cindex use with external data source
@cindex DataSourceConnectionSource
There are many other, external data sources that can be used instead, including more robust and probably higher-performance
pooled connection managers. You can instantiate your own directly and wrap it in the @code{DataSourceConnectionSource} class
which delegates to it.  Then you set that on the DAOs directly.

@cindex BasicDataSource
@cindex DataSourceConnectionSource
@example
// basic Apache data source
BasicDataSource dataSource = new BasicDataSource();
dataSource.setUrl("jdbc:h2:mem:account");
// we wrap it in the DataSourceConnectionSource
ConnectionSource connectionSource = 
  new DataSourceConnectionSource(dataSource);
@end example

@cindex close data source
@cindex destroy data source
When you are done with your @code{ConnectionSource}, you will want to call a @code{close()} method to close any
underlying connections.  Something like the following pattern is recommended.

@example
JdbcConnectionSource connectionSource =
    new JdbcPooledConnectionSource("jdbc:h2:mem:account");
try @{
    // work with the data-source and DAOs
    @dots{}
@} finally @{
    connectionSource.close();
@}
@end example

Unfortunately, the @code{DataSource} interface does not have a close method so you will have to close the @code{DataSource}
by hand -- the @code{close()} method on the @code{DataSourceConnectionSource} does @emph{nothing}.

@c ----------------------------------------------------------------
@node Database Type, Database Notes, Connection Source, Using
@section Database Type

@cindex database type
@value{package} uses an internal @code{DatabaseType} object which defines all of the per-database information necessary
to support the various features on all of the different database types.  The @code{JdbcConnectionSource} uses the database
URL to pick the correct @code{DatabaseType}.  If it picks an incorrect one then you may need to set the @code{DatabaseType}
on the connection source @emph{directly}.  For example:

@example
String databaseUrl = "jdbc:derby://dbserver1:1527/";
DatabaseType databaseType = new DerbyClientServerDatabaseType();
ConnectionSource connectionSource =
   new JdbcConnectionSource(databaseUrl, databaseType);
@end example

Android users do not need to worry about this because the @code{AndroidConnectionSource} always uses the
@code{SqliteAndroidDatabaseType}.  @xref{Use With Android}.

For more information about the database specific code in the DatabaseType see later in the manual.  @xref{Database Type Details}.

@c ----------------------------------------------------------------
@node Database Notes, Complete Wiring, Database Type, Using
@section Supported Databases

@value{package} supports the following database flavors.  Some of them have some specific documentation that needs to be obeyed.

@table @asis

@cindex MySQL
@item MySQL

Tables are created in MySQL with the InnoDB engine by default using @code{CREATE TABLE ... ENGINE=InnoDB}.  If you want to use
another engine, you can instantiate the @code{MysqlDatabaseType} directly and use the @code{setCreateTableSuffix()} method to use
the default or another engine.  Also, MySQL does some funky stuff with the last-modification time if a @code{Date} is defined as a
@code{TIMESTAMP} so @code{DATETIME} was used instead.

@cindex Postgres
@item Postgres

@cindex Microsoft SQL Server
@cindex SQL Server
@item Microsoft SQL Server

@cindex H2
@item H2

@cindex Derby
@item Derby

There are two drivers for Derby: one embedded and one client/server.  Right now we will only detect and use the embedded driver.
You will have to set the @code{DerbyClientServerDatabaseType} on your ConnectionSource directly.  @xref{Database Type}.

@cindex HSQLDB
@item HSQLDB

@cindex SQLite
@item SQLite

There are multiple SQLite drivers out there.  Make sure you use the Xerial one (@uref{http://www.xerial.org/trac/Xerial/wiki/SQLiteJDBC})
and not the Zentus one (@uref{http://www.zentus.com/sqlitejdbc/}) which does not support generated ids.

@cindex Android SQLite
@item Android SQLite

Android's SQLite database is accessed through direct calls to the Android database API methods.

@cindex DB2
@item DB2

I do not have access to an DB2 database so I cannot run any tests to make sure that my support for it works well.  Please contact me if you have
an Oracle database that I can develop against.

@cindex Oracle
@item Oracle

I do not have access to an Oracle database so I cannot run any tests to make sure that my support for it works well.  Please contact me if you have
an Oracle database that I can develop against.

@end table

@cindex database not supported
Please contact the author if your database is not supported.

@c ----------------------------------------------------------------
@node Complete Wiring, DAO Usage, Database Notes, Using
@section Tying It All Together

@cindex usage example
So you have annotated the objects to be persisted, added the no-arg constructor, defined your DAO classes,
created your @code{DataSource}, and established your @code{DatabaseType}.  You are ready to start persisting and
querying your database objects.  The following code ties it all together:

@example
// h2 by default but change to match your database
String databaseUrl = "jdbc:h2:mem:account";
JdbcConnectionSource connectionSource =
  new JdbcConnectionSource(databaseUrl);

// instantiate the dao
AccountDaoImpl accountDao = new AccountDaoImpl(connectionSource);

// if you need to create the 'accounts' table make this call
TableUtils.createTable(connectionSource, Account.class);

// create an instance of Account
Account account = new Account("Jim Coakley");

// persist the account object to the database
// it should return 1 for the 1 row inserted
if (accountDao.create(account) != 1) @{
  // error handling @dots{} 
@}
// other code @dots{}

// destroy the data source which should close underlying connections
connectionSource.destroy();
@end example

@cindex code examples
For more examples, see the @code{com.j256.ormlite.examples} package test classes in the Java -jdbc sources jar.

@c ----------------------------------------------------------------
@node DAO Usage, Identity Columns, Complete Wiring, Using
@section DAO Usage

@cindex DAO usage
@cindex using the DAOs

The following database operations are easily accomplished by using the DAO classes:

@table @asis

@cindex creating a database row
@cindex saving an object
@cindex persisting an object
@cindex writing an object
@item create and persist an object to the database

This inserts a new row to the database table associated with the object.

@example
Account account = new Account();
account.name = "Jim Coakley";
// only 1 row should have been affected
if (accountDao.create(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex query for id
@item query for it's id column 

If the object has an id field defined by the annotations, then we can lookup an object in the database using its id.

@example
Account account = accountDao.queryForId(name);
if (account == null) @{
  account not found handling @dots{} 
@}
@end example

@cindex updating an object
@item update the database row associated with the object

If you change fields in an object in memory, you must call update to persist those changes to the database.  This
also requires an id field. 

@example
account.password = "_secret";
// 1 row should be updated
if (accountDao.update(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex refreshing an object
@item refreshing our object if the database has changed

If some other entity has changed a row the database corresponding to an object in memory, you will need to refresh that
object to get the memory object up-to-date.  This also requires an id field. 

@example
// 1 row should be found
if (accountDao.refresh(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex deleting an object
@item delete the account from the database

Removes the row that corresponds to the object from the database.  Once the object has been deleted from the database,
you can continue to use the object in memory but any update or refresh calls will fail.  This also requires an id field.

@example
// 1 row should be affected
if (accountDao.delete(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex iterator
@cindex iterating through all rows
@item iterate through all of the rows in a table:

The DAO is also an iterator so you can easily run through all of the rows in the database:

@example
// page through all of the accounts in the database
for (Account account : accountDao) @{
    System.out.println(account.getName());
@}
@end example

@cindex closing an iterator 
@emph{NOTE:} you must page through @emph{all} items for the iterator to close the underlying SQL object.   If you don't
go all of the way, the garbage collector will close the SQL statement some time later which is considered bad form.

@end table

@c ----------------------------------------------------------------
@node Identity Columns, Id Column, DAO Usage, Using
@section Identity Columns

Database rows are identified by a particular column which is defined as the @emph{identity} column.  This can either be
supplied by the user or auto-generated by the database.  Identity columns have unique values for every row in the table
and they are required if you want to delete, refresh, or update a particular row using the DAO.  To configure a field as
an identity field, you should use one (and only one) of the following three settings from @code{@@DatabaseField}:
@code{id}, @code{generatedId}, or @code{generatedIdSequence}.

@menu
* Id Column::                        Using fields with id = true.
* GeneratedId Column::               Using fields with generatedId = true.
* GeneratedIdSequence Column::       Using fields with generatedIdSequence = ...
@end menu

@c ----------------------------------------------------------------
@node Id Column, GeneratedId Column, Identity Columns, Identity Columns
@subsection Fields With id

@cindex identity field
@cindex id column
With our @code{Account} example class, the string @code{name} field has been marked with @code{id = true}.  This means
that the @code{name} is the identity column for the object.  Each account stored in the database must have a unique
value for the @code{name} field -- you cannot have two rows with the name "John Smith".

@example
public class Account @{
    @@DatabaseField(id = true)
    private String name;
    @dots{}
@}
@end example

When you use the DAO to lookup an account with a particular name, you will use the identity field to locate the
@code{Account} object in the database:

@example
Account account = accountDao.queryForId("John Smith");
if (account == null) @{
    // the name "John Smith" does not match any rows
@}
@end example

@cindex updateId
@cindex change id value
@cindex update identity of object
If you need to change the value of an object's id field, you must use the @code{Dao.updateId()} method which takes the
current object still with its @emph{old} id value and the new value.  @value{package} has to first locate the object
by its old id and then update it with the new id.  @xref{updateId}.

@c ----------------------------------------------------------------
@node GeneratedId Column, GeneratedIdSequence Column, Id Column, Identity Columns
@subsection Fields With generatedId

@cindex generated identity field
@cindex generatedId column
You can configure a long or integer field to be a @emph{generated} identity column.  The id number column for each row
will then be automatically generated by the database.  

@example
public class Order @{
    @@DatabaseField(generatedId = true)
    private int id;
    @dots{}
@}
@end example

When an @code{Order} object is passed to @code{create} and stored to the database, the generated identity value is returned
by the database and set on the object by @value{package}.  In the majority of database types, the generated value starts at
1 and increases by 1 every time a new row is inserted into the table.

@example
// build our order object without and id
Order order = new Order("Jim Sanders", 12.34);
@dots{}
if (orderDao.create(order) != 1) @{
   // error handling unless 1 row was inserted
@}
System.out.println("Order id " + order.getId() + " was persisted to the database");
// query for the order with an id of 1372
order = orderDao.queryForId(1372);
if (order == null) @{
    // none of the order rows have an id of 1372
@}
@end example

In the above code example, an order is constructed with name and amount (for example).  When it is passed to the DAO's
@code{create} method, the id field has not been set.  After it has been saved to the database, the generated-id will
be set on the id field by @value{package} and will be available when @code{getId()} is called on the order after the
@code{create} method returns.

@emph{NOTE:} Depending on the database type, you may not be able to change the value of an auto-generated id field.

@c ----------------------------------------------------------------
@node GeneratedIdSequence Column, Statement Builder, GeneratedId Column, Identity Columns
@subsection Fields With generatedIdSequence

@cindex generated identity sequence name
@cindex generatedIdSequence column

Some databases use what's called a sequence number generator to provide the generated id value.  If you use
@code{generatedId = true} with those databases, a sequence name will be auto-generated by @value{package}.
If, however, you need to set the name of the sequence to match existing schema, you can used the
@code{generatedIdSequence} value which takes a string name for the sequence.

@example
public class Order @{
    @@DatabaseField(generatedIdSequence = "order_id_seq")
    private int id;
    @dots{}
@}
@end example

In the above example, the @code{id} value is again automatically generated but using a sequence with the name
@code{order_id_seq}.  This will throw an exception if you are working with a database which does not support
sequences.

@emph{NOTE:} Depending on the database type, you may not be able to change the value of an auto-generated id field.

@c ----------------------------------------------------------------
@node Statement Builder, QueryBuilder Basics, GeneratedIdSequence Column, Top
@chapter Custom Statement Builder

@cindex query builder
@cindex custom query builder
@cindex custom statement builder
The DOAs have methods to query for an object that matches an id field (@code{queryForId}) as well as query for all
objects (@code{queryForAll}) and iterating through all of the objects in a table (@code{iterator}).  However, for more
specified queries, there is the @code{queryBuilder()} method which returns a @code{QueryBuilder} object for the DAO
with which you can construct custom queries to return a sub-set of the table.

@menu
* QueryBuilder Basics::         How to start using the query builder.
* Building Queries::            How to build simple and complex queries.
* Building Statements::         How to build update and delete statements.
* Select Arguments::            Using arguments to queries.
@end menu

@c ----------------------------------------------------------------
@node QueryBuilder Basics, Building Queries, Statement Builder, Statement Builder
@section Query Builder Basics

Here's how you use the query builder to construct custom queries.  First, it is a good pattern to
set the column names of the fields with Java constants so you can use them in queries.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
    public static final String PASSWORD_FIELD_NAME = "password"; 
	
	@dots{}
    @@DatabaseField(canBeNull = false, columnName = PASSWORD_FIELD_NAME)
    private String password;
	@dots{}
@end example

This allows us to construct queries using the password field name without having the renaming of a field in the future break
our queries.  This should be done @emph{even} if the name of the field and the column name are the same.

@cindex where
@example
// get our query builder from the DAO
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
// the 'password' field must be equal to "qwerty"
queryBuilder.where().eq(Account.PASSWORD_FIELD_NAME, "qwerty");
// prepare our sql statement
PreparedQuery<Account, String> preparedQuery =
  queryBuilder.prepare();
// query for all accounts that have that password
List<Account> accountList = accountDao.query(preparedQuery);
@end example

@cindex prepared statement
You get a @code{QueryBuilder} object from the @code{Dao.queryBuilder} method, call methods on it to build your custom
query, call @code{queryBuilder.prepare()} which returns a @code{PreparedQuery} object, and then pass the @code{PreparedQuery}
to the DAO's @code{query} or @code{iterator} methods.

@c ----------------------------------------------------------------
@node Building Queries, Building Statements, QueryBuilder Basics, Statement Builder
@section Building Queries

@cindex building queries
There are a couple of different ways that you can build queries.  The @code{QueryBuilder} has been written for ease of use
as well for power users.  Simple queries can be done linearly:

@example
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
// get the WHERE object to build our query
Where where = queryBuilder.where();
// the name field must be equal to "foo"
where.eq(Account.NAME_FIELD_NAME, "foo");
// and
where.and();
// the password field must be equal to "_secret"
where.eq(Account.PASSWORD_FIELD_NAME, "_secret");
PreparedQuery<Account, String> preparedQuery =
  queryBuilder.prepare();
@end example

The SQL query that will be generated from the above example will be approximately:

@example
SELECT * FROM account
  WHERE (name = 'foo' AND password = '_secret')
@end example

@cindex chain query methods
If you'd rather chain the methods onto one line (like StringBuilder), this can also be written as:

@example
queryBuilder.where()
  .eq(Account.NAME_FIELD_NAME, "foo")
  .and()
  .eq(Account.PASSWORD_FIELD_NAME, "_secret");
@end example

If you'd rather use parenthesis to group the comparisons properly then you can call:

@example
Where where = queryBuilder.where();
where.and(where.eq(Account.NAME_FIELD_NAME, "foo"),
          where.eq(Account.PASSWORD_FIELD_NAME, "_secret"));
@end example

@cindex complex query
All three of the above call formats produce the same SQL.  For complex queries that mix ANDs and ORs, the last
format may be necessary to get the grouping correct.  For example, here's a complex query:

@example
Where where = queryBuilder.where();
where.or(
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "foo"),
    where.eq(Account.PASSWORD_FIELD_NAME, "_secret")),
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "bar"),
    where.eq(Account.PASSWORD_FIELD_NAME, "qwerty")));
@end example

This produces the following approximate SQL:

@example
SELECT * FROM account
  WHERE ((name = 'foo' AND password = '_secret')
         OR (name = 'bar' AND password = 'qwerty'))
@end example

@cindex order by
@cindex group by
@cindex like
@cindex in
@cindex is null
@cindex comparisons
The @code{QueryBuilder} also allows you to set what specific select columns you want returned, specify the 'ORDER BY'
and 'GROUP BY' fields, and various other SQL features (LIKE, IN, >, >=, <, <=, <>, IS NULL, DISTINCT, @dots{}).  See the
javadocs on@code{QueryBuilder} and @code{Where} classes for more information.  A good SQL reference site can be found
at @uref{http://www.w3schools.com/Sql/}.

@c ----------------------------------------------------------------
@node Building Statements, Select Arguments, Building Queries, Statement Builder
@section Building Statements

@cindex deleteBuilder
@cindex updateBuilder
@cindex custom update statements
@cindex custom delete statements
@anchor{deleteBuilder}
@anchor{updateBuilder}
The DAO can also be used to construct custom @code{UPDATE} and @code{DELETE} statements.  Update statements
are used to change certain fields in rows from the table that match the @code{WHERE} pattern -- or update @emph{all}
rows if no @code{where()}. Delete statements are used to delete rows from the table that match the @code{WHERE}
pattern -- or delete @emph{all} rows if no @code{where()}.  

For example, if you want to update the passwords for all of the Accounts in your table that are currently null to
the string "none", then you might do something like the following:

@example
UpdateBuilder<Account, String> updateBuilder =
  accountDao.updateBuilder();
// update the password to be "none"
updateBuilder.updateColumnValue("password", "none");
// only update the rows where password is null
updateBuilder.where().isNull(Account.PASSWORD_FIELD_NAME);
accountDao.update(updateBuilder.prepare());
@end example

With update, you can also specify the update value to be an expression:

@example
// update hasDogs boolean to true if dogC > 0
updateBuilder.updateColumnExpression(
  "hasDogs", "dogC > 0");
@end example

To help you construct your expressions, you can use the UpdateBuilder's escape methods @code{escapeColumnName} and
@code{escapeValue} can take a string or a @code{StringBuilder}.  This will protect you if columns or values are reserved words. 

If, instead, you wanted to delete the rows in the Accounts table whose password is currently null, then you might do
something like the following:

@example
DeleteBuilder<Account, String> deleteBuilder =
  accountDao.deleteBuilder();
// only delete the rows where password is null
deleteBuilder.where().isNull(Account.PASSWORD_FIELD_NAME);
accountDao.delete(deleteBuilder.prepare());
@end example

@c ----------------------------------------------------------------
@node Select Arguments, Foreign Objects, Building Statements, Statement Builder
@section Using Select Arguments

@cindex query arguments
@cindex select arguments
@cindex arguments to queries
@cindex sql ?
The arguments that are used in WHERE operations can be specified directly as value arguments (as in the above examples) or as a
@code{SelectArg} object.  SelectArgs are used to set the value of an argument at a later time -- they generate a SQL '@code{?}'.
For example:

@example
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
Where where = queryBuilder.where();
SelectArg selectArg = new SelectArg();
// define our query as 'name = ?'
where.eq(Account.NAME_FIELD_NAME, selectArg);
// prepare it so it is ready for later query or iterator calls
PreparedQuery<Account, String> preparedQuery =
  queryBuilder.prepare();

// later we can set the select argument and issue the query
selectArg.setValue("foo");
List<Account> accounts = accountDao.query(preparedQuery);
// then we can set the select argument to another
// value and re-run the query
selectArg.setValue("bar");
accounts = accountDao.query(preparedQuery);
@end example

@emph{NOTE:} @code{SelectArg} objects have protection against being used in more than one column name.  You must instantiate a
new object if you want to use a @code{SelectArg} with another column.

@c ----------------------------------------------------------------
@node Foreign Objects, Use With Android, Select Arguments, Top
@chapter Foreign Object Fields

@cindex foreign objects
@value{package} supports the concept of "foreign" objects where one or more of the fields correspond to an object
are persisted in another table in the same database.  For example, if you had an @code{Order} objects in your database
and each @code{Order} had a corresponding @code{Account} object, then the @code{Order} object would have foreign
@code{Account} field.  With foreign objects, @emph{just} the id field from the @code{Account} is persisted
to the @code{Order} table as the column "@code{account_id}".  For example, the @code{Order} class might look
something like:

@example
@@DatabaseTable(tableName = "orders")
public class Order @{

    @@DatabaseField(generatedId = true)
    private int id;
    
    @@DatabaseField(canBeNull = false, foreign = true)
    private Account account;
    @dots{}
@}
@end example

When the @code{Order} table was created, something like the following SQL would be generated:

@example
CREATE TABLE `orders`
   (`id` INTEGER AUTO_INCREMENT , `account_id` INTEGER,
    PRIMARY KEY (`id`)); 
@end example

@emph{Notice} that the name of the field is @emph{not} @code{account} but is instead @code{account_id}.  You will need to
use this field name if you are querying for it.  You can set the column name using the @code{columnName} field in the
@code{DatabaseField} annotation. @xref{columnName}.

@cindex refreshing foreign objects
@cindex foreign object refreshing
When you query for an order, you will get an @code{Order} object with an account field object that @emph{only} has its id
field set -- all of the fields in the foreign @code{Account} object will have default values (null, 0, false, etc.).  If
you want to use other fields in the @code{Account}, you must call @code{refresh} on the @code{accountDao} class to get the
@code{Account} object filled in.  For example:

@example
if (accountDao.refresh(order.getAccount()) != 1) @{
  // error handling @dots{} 
@}
@end example

@emph{NOTE:} Because we use refresh, foreign objects are therefor @emph{required} to have an id field.

@c ----------------------------------------------------------------
@node Use With Android, How to Upgrade, Foreign Objects, Top
@chapter Using With Android

@cindex use with Android OS
@cindex Android OS support
@cindex droid support

Because of the lack of support for JDBC in Android OS, @value{package} makes direct calls to the Android database APIs
to access SQLite databases.  You should make sure that you have downloaded and are depending on the
@code{ormlite-android.jar} file and @emph{not} the @code{ormlite-jdbc.jar} version.  This part of the code is the
newest and although tested and used in some projects, the proper patterns on @emph{how} to use it have not solidified.
Feedback on this would be most welcome.

After you have read the getting started section (@pxref{Getting Started}), the following instructions should be
followed to help you get @value{package} working under Android OS.

@enumerate

@item You will need to create your own database helper class which should probably extend the @code{OrmLiteSqliteOpenHelper}  
class.  This class creates and upgrades the database when your app is installed and can also provide the DAO classes
used by your other classes.  Your helper class must implement the methods
@code{onCreate(SQLiteDatabase sqliteDatabase, ConnectionSource connectionSource)} and
@code{onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion)}.
@code{onCreate} creates the database when your app is first installed while @code{onUpgrade} handles the upgrading
of the database tables when you upgrade your app to a new version.  There is a sample @code{DatabaseHelper} class as well as
examples projects online: @uref{http://ormlite.sourceforge.net/android/examples/}. 

@item The helper can be kept open across all activities in your app with the same Sqlite database connection reused by
all threads.  If you open multiple connections to the same database, stale data and unexpected results may occur.
We recommend using the @code{OpenHelperManager} to monitor the usage of the helper -- it will create it on the first
access, track each time a part of your code is using it, and then it will close the last time the helper is released.

@item The @code{OpenHelperManager} will by default look for the full class name of your own database helper class
in the @code{open_helper_classname} value defined in @code{res/values/strings.xml}.  You can instead set a
@code{SqliteOpenHelperFactory} on the manager directly in a @code{static @{@}} block in your code.   

@item  Once you have defined your database helper and are managing it correctly, you will need to use it in your @code{Activity}
classes.  An easy way to use the @code{OpenHelperManager} is to extend @code{OrmLiteBaseActivity} for each of your
activity classes -- there is also @code{OrmLiteBaseService} and @code{OrmLiteBaseTabActivity}.  These classes provide a
@code{getHelper()} method to access the database helper whenever it is needed and will automatically release the helper
in the @code{onDestroy()} method.  There is a sample @code{HelloAndroid} activity class in the the sample section of the tests 
and on the web site along with a @code{SampleData} example class.

@item If you do not want to extend the base classes then you will need to duplicate their basic functionality of calling
@code{OpenHelperManager.getHelper(Context context)} at the start of your code, save the helper and use it as much as 
you want, and then calling @code{OpenHelperManager.release()} when you are done with it.

@item The Android native SQLite database type is @code{SqliteAndroidDatabaseType} and is used by the base classes internally.

@end enumerate

Please see the example code posted to the website for more information: @uref{http://ormlite.sourceforge.net/android/examples/}.
Again, feedback on this is welcome.

@c ----------------------------------------------------------------
@node How to Upgrade, 3.X to 4.0, Use With Android, Top
@chapter Upgrading Old Versions

@menu
* 3.X to 4.0::                 Upgrade from version 3.X to 4.0
* 2.X to 3.2::                 Upgrade from version 2.X to 3.2
* 2.3 to 2.4::                 Upgrade from version 2.3 to 2.4
@end menu

@c ----------------------------------------------------------------
@node 3.X to 4.0, 2.X to 3.2, How to Upgrade, How to Upgrade
@section Upgrade from Version 3.X to 4.0

Removed any outside usage of the @code{DatabaseType} since the @code{ConnectionSource} now provides it.  Also added
features to be able to prepare update and delete statements.  To provide type safety, we've moved back to using
@code{QueryBuilder} so we can have @code{UpdateBuilder} and @code{DeleteBuilder}.  And instead of a @code{PreparedStmt}
there is @code{PreparedQuery}, @code{PreparedUpdate}, and @code{PreparedDelete}.  Here are the details:

@itemize @bullet

@item We have removed most of the cases where the user has to deal with the @code{DatabaseType}.
All you need to set on the DAOs is the @code{ConnectionSource} which provides the database type 
internally.  To create and drop the tables, also, you only need the @code{ConnectionSource}.

@item Constructing a @code{BaseDaoImpl} now self-initializes if it is constructed with a
@code{ConnectionSource}.  This validates the class configurations meaning that it now throws a
@code{SQLException}.

@item Constructing a @code{JdbcConnectionSource} or @code{DataSourceConnectionSource} also now
throw a @code{SQLException} since they also now self-initialize if they are constructed with the URL.
This creates the internal database type and loads the driver class for it.  

@item Deprecated the @code{createJdbcConnectionSource} method in the @code{DatabaseTypeUtils} and
turned the @code{loadDriver} method into a no-op.  You now just instantiate the @code{JdbcConnectionSource}
directly and there is no need for referencing the @code{DatabaseTypeUtils} anymore.

@item @code{Dao.statementBuilder()} method changed (back) to @code{Dao.queryBuilder()}.

@item @code{Dao.queryBuilder()} returns a @code{QueryBuilder} instead of a @code{StatementBuilder}.

@item You now call @code{distinct()} and @code{limit()} on the @code{QueryBuilder}.  Unfortunately,
there are no deprecated methods for them on the @code{StatementBuilder}.

@item You now call @code{selectColumns()} on the @code{QueryBuilder} instead of @code{columns()}
since now we have columns also in the @code{UpdateBuilder}.  Unfortunately, there are no deprecated
methods for them on the @code{StatementBuilder}.

@item You call @code{QueryBuilder.prepare()} instead of @code{StatementBuilder.prepareStatement()}.
It returns a @code{PreparedQuery} instead of a @code{PreparedStmt}.  You pass a @code{PreparedQuery}
into the @code{Dao.query()} and @code{Dao.iterator()} methods instead of a @code{PreparedStmt}.

@item We removed the @code{DatabaseTypeFactory} class since it was no longer needed for Spring
configurations.

@item Removed @code{BaseJdbcDao} since it had been deprecated in 3.X.

@end itemize

@c ----------------------------------------------------------------
@node 2.X to 3.2, 2.3 to 2.4, 3.X to 4.0, How to Upgrade
@section Upgrade from Version 2.X to 3.2

The 3.2 release involved a @emph{very} large code reorganization and migration.  The project was basically split into 3 pieces:
core functionality, JDBC database handlers, and the new Android handler.  With significant help from Kevin G, we abstracted all
of the database calls into 3 interfaces: @code{ConnectionSource} (like a @code{DataSource}), @code{DatabaseConnection} (like a
@code{Connection}) and @code{DatabaseResults} (like a @code{ResultSet}).  Once we had the interfaces in place, we wrote
delegation classes for JDBC and Android handlers.  This means that as of 3.X we release 3 packages: ormlite-core (for developers),
ormlite-jdbc (for people connecting to JDBC databases), and ormlite-android (for Android users).  Both the JDBC and Android
packages include all of the core code as well.

Along the way a number of specific changes were made to the methods and classes:

@itemize @bullet

@item Since we split off the JDBC, we renamed the @code{BaseJdbcDao} to be @code{BaseDaoImpl} in the core package. You will
need to adjust any DAOs that you have.

@item We are in the process of allowing custom delete and update methods so we took the major upgrade opportunity to
rename the @code{QueryBuilder} object to be @code{StatementBuilder}.

@item Because of the above, we also renamed @code{Dao.queryBuilder()} method to be @code{queryBuilder()}.

@item Also renamed the @code{PreparedQuery} object to be @code{PreparedStmt}.

@item One of the big changes for those of you using an external JDBC @code{DataSource} is that you no longer set it on the
DAO directly.  You need to wrap your @code{DataSource} in a @code{DataSourceDatabaseConnection} wrapper class which gets
set on the DAO instead.

@end itemize

There were no on-disk changes unless you somehow managed to get ORMLite working previously on Android.  Since we were using
JDBC before to do the data marshalling and now are doing it by hand, some of the data representations may have changed.  Sorry for
the lack of detail here.

@c ----------------------------------------------------------------
@node 2.3 to 2.4, Advanced, 2.X to 3.2, How to Upgrade
@section Upgrade from Version 2.3 to 2.4

A bug was fixed in 2.4 with how we were handling Derby and Hsqldb.  Both of these databases seem to be capitalizing table and field
names in certain situations which meant that customized queries of @value{package} generated tables were affected.  In version 2.4,
all tables and field names are capitalized in the SQL generated for Derby and Hsqldb databases. This means that if you have data
in these databases from a pre 2.4 version, the 2.4 version will not be able to find the tables and fields without renaming to be
uppercase.

@c ----------------------------------------------------------------
@node Advanced, Spring Configuration, 2.3 to 2.4, Top
@chapter Advanced Concepts

@menu
* Spring Configuration::       How to wire @value{package} in Spring.
* Class Configuration::        Alternate ways to configure your classes.
* Database Type Details::      Description of the database specific code.
* DAO Methods::                What functionality is provided by the DAO.
* Logging::                    How to log messages with @value{package}.
* Dependencies::               External dependencies of @value{package}.
@end menu

@c ----------------------------------------------------------------
@node Spring Configuration, Class Configuration, Advanced, Advanced
@section Spring Configuration

@cindex spring framework
@cindex configuration with Spring
@value{package} contains some classes which make it easy to configure the various database classes using
the Spring framework.  For more information about the Spring Framework, see @uref{http://www.springsource.org/}.

@table @code

@item TableCreator

@cindex auto create tables
@cindex create tables
@cindex auto drop tables
@cindex drop tables
Spring bean that auto-creates any tables that it finds DAOs for if the system property @code{ormlite.auto.create.tables}
has been set to true. It will also auto-drop any tables that were auto-created if the property
@code{ormlite.auto.drop.tables} has been set to true.  This should be used carefully and probably only in tests.

@end table

@cindex spring examples
Here's an example of a full Spring configuration.

@example
<!-- URL used for database, probably should be in properties file -->
<bean id="databaseUrl" class="java.lang.String">
    <!-- we are using the in-memory H2 database in this example -->
    <constructor-arg index="0" value="jdbc:h2:mem:account" />
</bean>

<!-- datasource used by @value{package} to connect to the database -->
<bean id="connectionSource"
    class="com.j256.ormlite.jdbc.JdbcConnectionSource"
    init-method="initialize">
    <property name="url" ref="databaseUrl" />
    <!-- probably should use system properties for these too -->
    <property name="username" value="foo" />
    <property name="password" value="bar" />
</bean>

<!-- abstract dao that is common to all defined daos -->
<bean id="baseDao" abstract="true" init-method="initialize">
    <property name="connectionSource" ref="connectionSource" />
</bean>

<!-- our daos -->
<bean id="accountDao"
    class="com.j256.ormlite.examples.common.AccountDaoImpl"
    parent="baseDao" />
@end example

@c ----------------------------------------------------------------
@node Class Configuration, Database Type Details, Spring Configuration, Advanced
@section Class Configuration

The simplest mechanism for configuring a class to be persisted by @value{package} is to use the @code{@@DatabaseTable}
and @code{@@DatabaseField} annotations.  @xref{Local Annotations}.  However if you do not own the class you are
persisting or there are permission problems with the class, you may want to configure the class using Java code instead.

@cindex configure a class in code
To configure a class in code, you use the @code{DatabaseFieldConfig} and @code{DatabaseTableConfig} objects.
The field config object holds all of the details that are in the @code{@@DatabaseField} annotation as well as
the name of the corresponding field in the object.  The @code{DatabaseTableConfig} object holds the class and the
corresponding list of @code{DatabaseFieldConfig}s.  For example, to configure the @code{Account} object using Java code
you'd do something like the following:

@example
List<DatabaseFieldConfig> fieldConfigs =
    new ArrayList<DatabaseFieldConfig>();
fieldConfigs.add(new DatabaseFieldConfig("name", null, DataType.UNKNOWN,
    null, 0, false, false, true, null, false, null, false));
fieldConfigs.add(new DatabaseFieldConfig("password", null,
    DataType.UNKNOWN, null, 0, false, false, false, null, false, null,
    false));
DatabaseTableConfig<Account> accountTableConfig
    = new DatabaseTableConfig<Account>(Account.class, fieldConfigs);

AccountDaoImpl accountDao =
    new AccountDaoImpl(connectionSource, accountTableConfig);
@end example

@cindex spring wire a class
See the Javadocs for the @code{DatabaseFieldConfig} class for the fields to pass to the constructor.  You can also
use the no-argument constructor and call the setters for each field.  You use the setters as well when you are
configuring a class using Spring wiring.  Here is the above example in Spring:

@example
<bean id="accountTableConfig"
  class="com.j256.ormlite.table.DatabaseTableConfig">
    <property name="dataClass"
        value="com.j256.ormlite.examples.common.Account" />
    <property name="tableName" value="account" />
    <property name="fieldConfigs">
        <list>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="name" />
                <property name="id" value="true" />
            </bean>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="password" />
                <property name="canBeNull" value="false" />
            </bean>
        </list>
    </property>
</bean>
@end example

@c ----------------------------------------------------------------
@node Database Type Details, DAO Methods, Class Configuration, Advanced
@section Database Specific Code

@cindex database type
@cindex database specific code
@value{package} isolates the database-specific code in the @code{DatabaseType} classes found in
@code{com.j256.ormlite.db}.  Each of the supported databases has a class there which implements the code needed to
handle the unique features of the database (H2DatabaseType, MySqlDatabaseType, etc.).   If you want to help develop
and test against other SQL databases, a externally available server that the author could connect to and test
against would be appreciated.  Please contact the author if your database is not supported or if you want to help.

The following methods are currently used by the system to isolate the database specific behavior in one place.
See the javadocs for the @code{DatabaseType} class for more information.

@table @code

@item getDriverUrlPart

Return the part in the database URI which identifies the particular database.  Usually the
URI is in the form jdbc:XXX:@dots{} where XXX is the driver url part.

@item getDriverClassName

Returns the class name of the driver that may or may not be in the classpath depending on what database is
being used.

@item loadDriver

Load the driver class associated with this database so it can wire itself into JDBC.

@item appendColumnArg

Takes a field type and appends the SQL necessary to create the field.  It may also generate arguments
for the end of the table create statement or commands that must run before or after the table create.

@item convertColumnName

Convert and return the column name for table and sequence creation. Often this is necessary to fix case issues.

@item dropColumnArg

Takes a field type and adds all of the commands necessary to drop the column from the database.

@item appendEscapedEntityName

Add a entity-name (table or column name) word to the SQL wrapped in the proper characters to escape it.
This avoids problems with table, column, and sequence-names being reserved words.

@item appendEscapedWord

Add the word to the string builder wrapped in the proper characters to escape it. This avoids problems with
data values being reserved words.

@item generateIdSequenceName

Return the name of an ID sequence based on the table-name and the field-type of the id.  This is required
by some database types when we have generated ids.

@item getCommentLinePrefix

Return the prefix to put at the front of a SQL line to mark it as a comment.

@item isIdSequenceNeeded

Return true if the database needs a sequence when you insert for generated IDs.  Some databases handle
generated ids internally.

@item getFieldConverter

Return the field converter associated with a particular field type.  This allows the database instance to
convert a field as necessary before it goes to the database.

@item isVarcharFieldWidthSupported

Return true if the database supports the width parameter on VARCHAR fields.

@item isLimitSupported

Return true if the database supports the LIMIT sql command.

@item isLimitAfterSelect

Return true if the LIMIT should be called after SELECT otherwise at the end of the WHERE (the default).

@item appendLimitValue

Add the necessary SQL to limit the results to a certain number.

@item appendSelectNextValFromSequence

Add the SQL necessary to get the next-value from a sequence. This is only necessary if
isIdSequenceNeeded returns true.

@item appendCreateTableSuffix

Append the SQL necessary to properly finish a CREATE TABLE line.

@item isCreateTableReturnsZero

Returns true if a 'CREATE TABLE' statement should return 0. False if > 0.

@item isEntityNamesMustBeUpCase

Returns true if table and field names should be made uppercase.  This is an unfortunate "feature" of Derby and Hsqldb.
See the Javadocs for the class for more information.

@end table

@c ----------------------------------------------------------------
@node DAO Methods, Logging, Database Type Details, Advanced
@section DAO Methods

@cindex dao methods
The DAO classes provide the following methods that you can use to store your objects to your database.
This list may be out of date.  See the @code{Dao} interface class for the latest methods.

@table @code

@cindex query for id
@item queryForId(ID id)

Looks up the id in the database and retrieves an object associated with it.

@cindex query for first
@item queryForFirst(PreparedQuery<T> preparedQuery)

Query for and return the first item in the object table which matches a prepared statement. This can be used to return
the object that matches a single unique column.  You should use queryForId if you want to query for the id column.

@cindex query for all
@item queryForAll()

Query for all of the items in the object table and return a list of them. For medium sized or large tables,
this may load a lot of objects into memory so you should consider using the @code{iterator} method instead.

@cindex query for all raw
@cindex raw select statements
@cindex executing raw select statements
@item queryForAllRaw(String query)

Query for all of the items in the object table that match the SQL select query argument. This method allows you
to do special queries that aren't supported otherwise. For medium sized or large tables, this may load a lot of 
objects into memory so you should consider using the @code{iteratorRaw} method instead.

@cindex query builder
@cindex statement builder
@item queryBuilder()

Create and return a new @code{QueryBuilder} object which allows you to build a custom query.  @xref{QueryBuilder Basics}.

@cindex update builder
@item updateBuilder()

Create and return a new @code{UpdateBuilder} object which allows you to build a custom update statement.  @xref{updateBuilder}.

@cindex delete builder
@item deleteBuilder()

Create and return a new @code{DeleteBuilder} object which allows you to build a custom delete statement.  @xref{deleteBuilder}.

@cindex query for objects
@item query(PreparedQuery<T> preparedQuery)

Query for the items in the object table which match a prepared statement.  @xref{Statement Builder}.  This returns a
list of matching objects. For medium sized or large tables, this may load a lot of objects into memory so you
should consider using the @code{iterator} method instead.  

@cindex creating an object
@item create(T data)

Create a new entry in the database from an object.  Should return 1 indicating 1 row was inserted.

@cindex updating an object
@item update(T data)

Save the fields from an object to the database. If you have made changes to an object, this is how you persist
those changes to the database. You cannot use this method to update the id field -- see updateId.  This should
return 1 since 1 row was updated.

@cindex update an object id
@anchor{updateId}
@item updateId(T data)

Update an object in the database to change its id to a new id. The data @emph{must} have its current id set and
the new-id is passed in as an argument.  After the id has been updated in the database, the id field of the data
object will also be changed.  This should return 1 since 1 row was updated.

@cindex update custom statement
@cindex custom update statement
@item update(PreparedUpdate<T> preparedUpdate)

Update objects that match a custom update statement.

@cindex refreshing an object
@item refresh(T data, ID newId)

Does a query for the object's id and copies in each of the field values from the database to refresh the data
parameter. Any local object changes to persisted fields will be overwritten.  If the database has been updated
this brings your local object up-to-date.  This should return 1 since 1 row was retrieved.

@cindex deleting an object
@item delete(T data)

Delete an object from the database.  This should return 1 since 1 row was removed.

@cindex delete multiple objects
@item delete (Collection<T> datas)

Delete a collection of objects from the database using an IN SQL clause.  This returns the number of rows that
were deleted.

@cindex delete objects by id
@item deleteIds(Collection<ID> ids)

Delete the objects that match the collection of ids from the database using an IN SQL clause.   This returns the
number of rows that were deleted.  

@cindex delete custom statement
@cindex custom delete statement
@item delete(PreparedDelete<T> preparedDelete)

Delete objects that match a custom delete statement.

@cindex iterator
@item iterator

This method satisfies the @code{Iterable} Java interface for the class and allows you to iterate through the objects
in the table using SQL.  This method allows you to do something like:

@example
for (Account account : accountDao) @{ @dots{} @}
@end example

@emph{WARNING:} See the @code{Dao} class for warnings about using this method.

@item iterator(PreparedQuery<T> preparedQuery)

Same is the @code{iterator} method but with a prepared statement parameter. @xref{Statement Builder}.

@item iteratorRaw(String query)

Same as the prepared statement iterator except it takes a raw SQL select statement argument.  This is the iterator version
of the @code{queryForAllRaw} method.  Although you should use the @code{iterator} method for most queries, this method
allows you to do special queries that aren't supported otherwise.  Like the above iterator methods, you must call close
on the returned @code{RawResults} object once you are done with it. 

@end table

@c ----------------------------------------------------------------
@node Logging, Dependencies, DAO Methods, Advanced
@section @value{package} Logging

@cindex logging information
@value{package} uses a log system which can plug into Apache commons logging, Log4j, Android Log, or its own internal
log implementations.  The logger code in @code{com.j256.ormlite.logger} first looks for the
@code{org.apache.commons.logging.LogFactory} class in the classpath -- if found it will use Apache commons logging.
If that class is not found it then looks for @code{org.apache.log4j.Logger} and if found will use Log4j.  Next it
looks for @code{android.util.Log} and if found will use the Android internal logger.  If none of these classes are
available it will use an internal logger -- see @code{LocalLog}.  The logger code also provides simple @{@}
argument expansion like @code{slf4j} which means that you can save on @code{toString()} calls and @code{StringBuilder} operations
if the log level is not high enough.  This allows me to do something like the following:

@example
private static Logger logger =
  LoggerFactory.getLogger(QueryBuilder.class);
@dots{}
logger.debug("built statement @{@}", statement);
@end example

If you are using log4j (through Apache commons logging or directly), you can use something
like the following as your log4j.properties file to see details about the SQL calls.

@cindex log4j properties file
@example
log4j.rootLogger=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout

# print the date in ISO 8601 format
log4j.appender.stdout.layout.ConversionPattern=%d@{ISO8601@} [%p] %c@{1@} %m%n

# be more verbose with our code
log4j.logger.com.j256.ormlite=DEBUG

# to enable logging of arguments to all of the SQL calls
# uncomment the following line
#log4j.logger.com.j256.ormlite.stmt.mapped.BaseMappedStatement=TRACE
@end example

@cindex logging sql arguments
@cindex sql argument logging
@emph{Notice} that you can uncomment the last line in the above log4j.properties file to log the arguments to the
various SQL calls.  This may expose passwords or other sensitive information in the database so probably should
only be used during debugging and should not be the default.

@c ----------------------------------------------------------------
@node Dependencies, Contributions, Logging, Advanced
@section External Dependencies

@value{package} does not have any direct dependencies.  It has logging classes that depend on Apache commons-logging
and Log4j but these classes will @emph{not} be referenced unless they exist in the classpath.
  
If you want to get the @value{package} Junit tests to run, there are test dependencies on the following packages:

@table @code

@item javax.persistence

For testing the compatibility annotations @code{@@Column} and the like.

@item org.junit

We use Junit for our unit tasks.

@item org.easymock.easymock

We use, and are in love with, EasyMock.  @uref{http://easymock.org/}.  It allows us to mock out dependencies so we can
concentrate on testing a particular class instead of the whole package. 

@item com.h2database

As a test database implementation, H2 is very fast and simple to use.  Not as recommended as a production level database.

@item org.apache.log4j

For logging to files using the @code{log4j.properties} config.  In the log4j package, you can exclude the following
dependencies: @code{com.sun.jmx.jmxri}, @code{com.sun.jdmk.jmxtools}, @code{javax.activation.activation},
@code{javax.jms.jms}, @code{javax.mail.mail}.

@end table

@c ----------------------------------------------------------------
@node Contributions, Index of Concepts, Dependencies, Top
@chapter Contributions

There are a couple of people that I'd like to thank who helped with the project.

@table @asis

@item Kevin Galligan

Kevin was the impetus and the author of a good bit of the Android compatible code.  He wrote the Android level support classes
and did a ton of beta-testing of it.  He's also provided all of the Android examples.  Thanks much Kevin.  See @uref{http://www.kagii.com/}.

@item Jim Gloor

Jim was one of the Java gurus at a previous company.  Thanks much for his JDBC code samples that started this effort.

@item Nelson Erb

Nelson is our self-appointed documentation and testing volunteer.  He did a great job summarizing sections of this document
so we could create a better 'Getting Started' section.  He will also be working on tests. 

@item Robert Adamsky

I worked with Robert at a company where he laid out our entire DAO and hibernate class hierarchy.  The @code{DAO} interface and the
@code{BaseDaoImpl} where in some part modeled after his code.  Thanks dude.  

@end table

Thanks much to them all.
@c ----------------------------------------------------------------
@node Index of Concepts,, Contributions, Top
@unnumbered Index of Concepts

@printindex cp
@contents

@bye
