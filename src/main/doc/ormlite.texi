\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename ormlite.info
@settitle ORM Lite Documentation
@setchapternewpage odd
@headings double
@c %**end of header
  
@dircategory Libraries
@direntry
* ORMLite: (orm lite).			Lightweight ORM package.
@end direntry

@c ----------------------------------------------------------------
@c This file has the new style title page commands.
@c Also, it uses `@@include' files instead of `@@input' files.

@c Run using special version of `texinfo.tex'.

@c Also, run `makeinfo' rather than `texinfo-format-buffer'.
@c ----------------------------------------------------------------

@c ----------------------------------------------------------------
@set ormlite_version 2.3
@set ormlite_date June 2010
@set package ORMLite
@c ----------------------------------------------------------------

@ifinfo
This file is an introduction to the ORM Lite package which is a simple Object Relationship Mapping package.

Copyright 2010 by Gray Watson.

Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice
and this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified versions of this manual under the conditions for
verbatim copying, provided also that the chapter entitled ``Copying'' are included exactly as in the
original, and provided that the entire resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual into another language, under the
above conditions for modified versions, except that the chapter entitled ``Copying'' may be included in a
translation approved by the author instead of in the original English.
@end ifinfo

@titlepage
@title ORM Lite Package
@subtitle Version @value{ormlite_version}
@subtitle @value{ormlite_date}
@author Gray Watson

@page
Copyright 2010 by Gray Watson.

Published by Gray Watson

Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice
and this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified versions of this manual under the conditions for
verbatim copying, provided also that the chapter entitled ``Copying'' are included exactly as in the
original, and provided that the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual into another language, under the
above conditions for modified versions, except that the chapter entitled ``Copying'' may be included in a
translation approved by the author instead of in the original English.
@end titlepage

@c ----------------------------------------------------------------
@node Top, Getting Started, (dir), (dir)
@top @value{package}

Version @value{ormlite_version} -- @value{ormlite_date}

@cindex introduction
@cindex author
@cindex object relational mapping
@cindex hibernate
@cindex ibatis
@value{package} provides a lightweight Object Relational Mapping between Java classes and SQL databases -- see
@uref{http://en.wikipedia.org/wiki/Object-relational_mapping}.  There are certainly more mature ORMs which
provide this functionality including Hibernate and iBatis.  However, the author wanted a simple yet powerful
wrapper around the JDBC functions and Hibernate and iBatis are significantly more complicated with many
dependencies.

@cindex databases supported
@cindex supported databases
ORMLite supports natively MySQL, Postgres, Microsoft SQL Server, H2, Derby, HSQLDB, and Sqlite and can be
extended to additional ones relatively easily.  There are also initial implementations for DB2 and Oracle
although the author needs access to each of these database types to tune the support.  Contact the author if
your database is not supported.

@cindex code examples
@cindex examples of code
To get started quickly with @value{package}, see the code examples down in the @code{com.j256.ormlite.examples}
package test classes in the Java sources jar down in @code{src/test/java}.  They contain a couple different
examples with working code.
@ifhtml
There is also a PDF version of this documentation -- see
@uref{http://ormlite.sourceforge.net/javadoc/doc-files/ormlite.pdf}.
@end ifhtml
@iftex
There is also a HTML version of this documentation -- see
@uref{http://ormlite.sourceforge.net/javadoc/doc-files/ormlite.html}.
@end iftex

Gray Watson @uref{http://256.com/gray/}

@menu
* Getting Started::             How to start to use @value{package}.
* DAO Usage::                   Using the Database Access Objects.
* Query Builder::               How to utilize the custom query builder.
* Foreign Objects::             Fields that represent foreign objects.
* Advanced::                    More advanced concepts with @value{package}.
* Index of Concepts::           Index of concepts in the manual.
@end menu

@c ----------------------------------------------------------------
@node Getting Started, Dependencies, Top, Top
@chapter Getting Started

@menu
* Dependencies::                The external dependencies of @value{package}.
* Class Setup::                 How to setup your classes to be persisted.
* Persisted Types::             The data types that are persisted.
* DAOs::                        How to configure the Database Access Objects.
* DataSource::                  Setting up your JDBC data source.
* Connection::                  How to connect to your database.
* Complete Wiring::             Tying all of the wiring together.
@end menu

@c ----------------------------------------------------------------
@node Dependencies, Class Setup, Getting Started, Getting Started
@section External Dependencies

@value{package} depends on the following external packages.  You must make sure
that these are listed in your Maven, Ant, or @dots{} configuration files.

@table @code

@item org.apache.commons.logging

For logging, @value{package} has a loose wrapper around apache commons-logging.  You
can remove this dependency by editing @code{com.j256.ormlite.logger.Logger}.  As of
this writing, we use version 1.1.1 of commons logging.  Previous or later versions 
should also work.

@item javax.persistence

To provide compatibility with other persistence packages, @value{package} depends on
the JavaX persistence annotations.  As of this writing, we use version 1.0 of the
persistence package.

@end table

For those maven-ites, here is the section from the pom that you will need to mirror.

@example
<properties>
    <ormlite-version>@value{ormlite_version}</ormlite-version>
    <persistence-api-version>1.0</persistence-api-version>
    <commons-logging-version>1.1.1</commons-logging-version>
    @dots{}
</properties>
<dependencies>
    <dependency>
        <groupId>com.j256</groupId>
        <artifactId>ormlite</artifactId>
        <version>$@{ormlite-version@}</version>
    </dependency>
    <dependency>
        <groupId>javax.persistence</groupId>
        <artifactId>persistence-api</artifactId>
        <version>$@{persistence-api-version@}</version>
    </dependency>
    <dependency>
        <groupId>commons-logging</groupId>
        <artifactId>commons-logging</artifactId>
        <version>$@{commons-logging-version@}</version>
    </dependency>
    @dots{}
</dependencies>
@end example 

If you want to get the @value{package} Junit tests to run, there are test dependencies on the following packages:

@table @code

@item org.junit

We use Junit for our unit tasks.  Pretty simple/easy.

@item org.easymock.easymock

We use, and are in love with, EasyMock.  @uref{http://easymock.org/}.  It allows us to mock out dependencies so we can
concentrate on testing a particular class instead of the whole package. 

@item com.h2database

As a test database implementation, H2 is fast and easy to use.  Not as recommended as a production level database.

@item org.apache.log4j

For logging to files using the @code{log4j.properties} config.  In the log4j package, you can exclude the following:
@code{com.sun.jmx.jmxri}, @code{com.sun.jdmk.jmxtools}, @code{javax.activation.activation}, @code{javax.jms.jms},
@code{javax.mail.mail}.

@end table

@c ----------------------------------------------------------------
@node Class Setup, Local Annotations, Dependencies, Getting Started
@section Setting Up Your Classes

To setup your classes to be persisted you need to do the following things:

@enumerate
@item Add the @@DatabaseTable annotation to the top of our class.  You can also use @@Entity
@item Add the @@DatabaseField annotation right before each field to be persisted.  You can also use @@Column and others.
@item Add a no-argument constructor with at least package permissions.
@end enumerate

@menu
* Local Annotations::                Adding the annotations to your classes.
* Javax Persistence Annotations::    Using javax.persistence annotations instead.
* No Arg Constructor::               No argument constructor is also required.
@end menu

@c ----------------------------------------------------------------
@node Local Annotations, Javax Persistence Annotations, Class Setup, Class Setup
@subsection Adding @value{package} Annotations to Your Classes

@cindex annotations
@cindex java annotations
@cindex @@DatabaseTable
@cindex DatabaseTable annotation
Annotations are special code markers have have been available in Java since version 5 that provide meta information
about classes, methods, or fields.  To specify what classes and fields to store in the database, @value{package}
supports either its own annotations (@code{@@DatabaseTable} and @code{@@DatabaseField}) or the more standard
annotations from the @code{javax.persistence} package.  @xref{Javax Persistence Annotations}.   Annotations are the
easiest way to configure your classes but you can also configure the class using Java code or Spring XML.
@xref{Class Configuration}.

With @value{package} annotations, for each of the Java classes that you would like to persist to your SQL database, you
will need to add the @code{@@DatabaseTable} annotation right above the @code{public class} line.  Each class marked with
one of these annotations will be persisted into its own database table.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@DatabaseTable} annotations can have an optional @code{tableName} argument which specifies the name of the table
that corresponds to the class.   If not specified, the class name all lowercase is used by default.

@cindex @@DatabaseField
@cindex DatabaseField annotation
Additionally, for each of the classes, you will need to add a @code{@@DatabaseField} annotation to each of the @emph{fields}
in the class that are to be persisted to the database.  Each field is persisted as a column of a database row.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{

    @@DatabaseField(id = true)
    private String name;

    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}
@end example

The @@DatabaseField annotation can have the following fields:

@table @code

@cindex column name
@cindex name of database column
@item columName

String name of the column in the database that will hold this field. If not set then the field name all lowercase is used instead.

@cindex field type
@cindex jdbc type
@cindex SQL type
@item jdbcType

The type of the field as the JdbcType class.  Usually the type is taken from Java class of the field and does not need
to be specified.  This corresponds to the SQL type.  @xref{Persisted Types}.

@cindex default value
@item defaultValue

String default value of the field when we are creating a new row in the table.  Default is none.

@cindex field width
@cindex width of field
@cindex length of field
@item width

Integer width of array fields -- usually for strings.  Some databases do not support this unfortunately.  Default for 
those that do is 255.

@cindex can be null
@cindex null value allowed
@item canBeNull

Boolean whether the field can be assigned to null or have no value. Default is true.

@cindex id field
@item id

Boolean whether the field is the id field or not. Default is false. Only one field can have this set in a class. Id fields
uniquely identity a row.  If you don't have it set then you won't be able to use the query, update, refresh, and delete by
ID methods. Only one of this, @code{generatedId}, and @code{generatedIdSequence} can be specified.

@cindex generated id
@cindex auto-generated id
@item generatedId

Boolean whether the field is an auto-generated id field. Default is false.  Only one field can have this set in a class.
This tells the database to auto-generate a corresponding id for every row inserted.  Some databases require sequences for
generated ids in which case the sequence name will be auto-generated. To specify the name of the sequence use
@code{generatedIdSequence}. Only one of this, @code{id}, and @code{generatedIdSequence} can be specified.

@cindex generated id sequence
@cindex database sequences
@cindex sequences
@item generatedIdSequence

String name of the sequence number to be used to generate this value.  Same as @code{generatedId} but you can specify the
sequence name to use.  Default is none. Only one field can have this set in a class. This is only necessary for databases
which require sequences for generated ids.  If you use generatedId instead then the code will auto-generate a sequence name.
Only one of this, @code{id}, and @code{generatedId} can be specified.

@cindex foreign objects
@cindex remote objects
@item foreign

@cindex refreshing foreign objects
Boolean setting which identifies this field as corresponding to another class that is also stored in the database.
Default is false.  The field must not be a primitive type.  The other class must have an id field (either @code{id},
@code{generatedId}, or @code{generatedIdSequence}) which will be stored in this table. When an object is returned
from a query call, any foreign objects will just have the id field set in it.  @xref{Foreign Objects}.

@cindex useGetSet
@cindex get and set method usage
@cindex using get and set methods
@cindex field access using getters and setters 
@item useGetSet

Boolean that says that the field should be accessed with get and set methods.  Default is false which instead uses
direct field access via Java reflection.  This may be necessary if the object you are storing has
protections around it.

@emph{NOTE:} The name of the get method @emph{must} match getXxx() where Xxx is the name of the field with the first
letter capitalized. The get @emph{must} return a class which matches the field's exactly. The set method @emph{must}
match setXxx(), have a single argument whose class matches the field's exactly, and return void.  For example:

@example
@@DatabaseField
private Integer orderCount;

public Integer getOrderCount() @{
  return orderCount;
@}

public void setOrderCount(Integer orderCount) @{
  this.orderCount = orderCount;
@}
@end example

@cindex unknownEnumName
@cindex enumerated name unknown
@item unknownEnumName

If the field is a Java enumerated type then you can specify the name of a enumerated value which will be used if the
value of a database row is not found in the enumerated type.  If this is not specified and a row @emph{does} contain
an unknown name or ordinal value then a @code{SQLException} is thrown.  This is useful to handle backwards compatibility
when handling out-of-date database values as well as forwards compatibility if old software is accessing up-to-date
data or if you have to roll a release back.

@cindex throwIfNull
@cindex primitive null values
@cindex null values and primitives
@item throwIfNull

Boolean that tells @value{package} to throw an exception if it sees a null value in a row and is trying to store it in
a primitive field.  By default it is false.  If it is false and the database field is null, then the value of the
primitive will be set to 0.  This can only be used on a primitive field.

@end table

@c ----------------------------------------------------------------
@node Javax Persistence Annotations, No Arg Constructor, Local Annotations, Class Setup
@subsection Using javax.persistence Annotations Instead

@cindex javax.persistence
@cindex @@Entity
@cindex Entity annotation
Instead of using the @value{package} annotations (@pxref{Local Annotations}), you can use the more standard
annotations from the @code{javax.persistence} package.  In place of the @code{@@DatabaseTable} annotation, you can
use the @code{javax.persistence} @code{@@Entity} annotation.  For example:

@example
@@Entity(name = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@Entity} annotations can have an optional @code{name} argument which specifies the table name.   If not
specified, the class name all lowercase is used by default.

@cindex @@Column
@cindex @@Id
@cindex @@GeneratedValue
@cindex Column annotation
@cindex Id annotation
@cindex GeneratedValue annotation
@cindex @@OneToOne
@cindex OneToOne annotation
@cindex @@ManyToOne
@cindex ManyToOne annotation
Instead of using the @code{@@DatabaseField} annotation on each of the fields, you can use the @code{javax.persistence}
annotations: @code{@@Column}, @code{@@Id}, @code{@@GeneratedValue}, @code{@@OneToOne}, and @code{@@ManyToOne}. For example:

@example
@@Entity(name = "accounts")
public class Account @{

    @@Id
    private String name;

    @@Column(nullable = false)
    private String password;
    @dots{}
@end example

The following @code{javax.persistence} annotations and fields are supported:

@table @code

@item @@Column

Specifies the field to be persisted to the database.  You can also just specify the @code{@@Id} annotation.  The
following annotation fields are supported, the rest are ignored.

@table @code

@item name

Used to specify the name of the associated database column.  If not provided then the field name is taken.

@cindex field width
@cindex width of field
@cindex length of field
@item length

Specifies the length (or width) of the database field.  Maybe only applicable for Strings and only supported by
certain database types.  Default for those that do is 255.   Same as the @code{width} field in the
@code{@@DatabaseField} annotation.

@cindex can be null
@cindex null value allowed
@item nullable

Set to true to have a field not be able to be inserted into the database with a null value.  Same as the
@code{canBeNull} field in the @code{@@DatabaseField} annotation.

@end table

@item @@Id

Used to specify a field to be persisted to the database as a primary row-id.  If you want to have the id be
auto-generated, you will need to also specify the @code{@@GeneratedValue} annotation.

@item @@GeneratedValue

Used to define an id field as having a auto-generated value.  This is only used in addition to the @code{@@Id}
annotation.  See the @code{generatedId} field in the @code{@@DatabaseField} annotation for more details.

@item @@OneToOne or @@ManyToOne

Fields with these annotations are assumed to be foreign fields.  @xref{Foreign Objects}.  @value{package} does
@emph{not} enforce the many or one relationship nor does it use any of the annotation fields.  It just uses the
existence of either of these annotations to indicate that it is a foreign object.

@end table

If the @code{@@Column} annotation is used on a field that has a unknown type then it is assumed to be a
Serializable field and the object should implement @code{java.io.Serializable}.  @xref{Persisted Types}.

@c ----------------------------------------------------------------
@node No Arg Constructor, Persisted Types, Javax Persistence Annotations, Class Setup
@subsection Adding a No Argument Constructor to Your Class

@cindex no argument constructor
@cindex constructor with no args
After you have added the class and field annotations, you will also need to add a no-argument constructor with
@emph{at least} package visibility.  When an object is returned from a query, @value{package} constructs the object
using Java reflection and a constructor needs to be called.

@example
Account() @{
  	// all persisted classes must define a no-arg constructor
  	// with at least package visibility
@}
@end example

So your final example Account class with annotations and constructor would look like:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
	
    @@DatabaseField(id = true)
    private String name;
    
    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}

    Account() @{
        // all persisted classes must define a no-arg constructor
        // with at least package visibility
    @}
    @dots{}
@}
@end example

@c ----------------------------------------------------------------
@node Persisted Types, DAOs, No Arg Constructor, Getting Started
@section Types That can be Persisted

@cindex persisted types
@cindex types that are persisted
The following Java types can be persisted to the database by @value{package}.  Database specific code
helps to translate between the SQL types and the database specific handling of those types.
@xref{Database Type}.

@table @code

@cindex String
@item String

Persisted as SQL type VARCHAR.

@cindex boolean
@item Boolean or boolean

Persisted as SQL type BOOLEAN.

@cindex Date
@item java.util.Date

Persisted as SQL type TIMESTAMP.  @emph{NOTE:} This is @emph{not} @code{java.sql.Date} which is a different
class.

@cindex byte
@item Byte or byte

Persisted as SQL type TINYINT.

@cindex short
@item Short or short

Persisted as SQL type SMALLINT.

@cindex int
@item Integer or int

Persisted as SQL type INTEGER.

@cindex long
@item Long or long

Persisted as SQL type BIGINT.

@cindex float
@item Float or float

Persisted as SQL type FLOAT.

@cindex double
@item Double or double

Persisted as SQL type DOUBLE.

@cindex Serializable
@cindex persist objects
@item Serializable

Persisted as SQL type VARBINARY.  This is a special type that serializes an object as a sequence of bytes
and then deserializes it on the way back.  The field must be an object that implements the @code{java.io.Serializable}
interface.  Depending on the database type, there will be limits to the size of the object that can be stored.  YMMV.

@cindex Enum
@cindex enumerated types
@item Enum or enum

Persisted by default as the enumerated value's string @emph{name} as a VARCHAR type.  You can also specify the
@code{jdbcType} field to the @code{@@DatabaseField} annotation as a @code{JdbcType.ENUM_INTEGER} in which case the
@code{ordinal} of the enum value will be stored as an INTEGER.  The name is the default (and recommended) because
it allows you to add additional enums anywhere in the list without worrying about having to convert data later.

@cindex unknownEnumName
You can also also specify an @emph{unknownEnumName} name with the @code{@@DatabaseField} annotation which will be
used if an unknown value is found in the database. @xref{Local Annotations}. 

@end table

@emph{NOTE:} @value{package} also supports the concept of foreign objects where the id of another object is
stored in the database.  @xref{Foreign Objects}.

@c ----------------------------------------------------------------
@node DAOs, DataSource, Persisted Types, Getting Started
@section Defining the DAOs

@cindex DAO
@cindex database access object
A typical Java pattern is to isolate the database operations in Database Access Objects or DAO classes.  Each DAO
provides create, delete, update, etc. type of functionality and usually specialize in the handling a particular
persisted class.

@cindex id column
@cindex BaseDao interface
Once you have annotated your classes, you will need to create the DAO class(es).  The pattern that we recommend
is to define a DAO interface which extends the @code{BaseDao} interface and will be used in the code.  The interface
isn't required but it is a good pattern so your code is less tied to JDBC for persistence.  Each DAO has two generic
parameters: the class we are persisting with the DAO, and the class of the ID-column that will be used to
identify a specific database row.  If you class does not have an ID field, you can put @code{Object} or @code{Void}
as the 2nd argument.  For example, in the above @code{Account} class, the "name" field is the ID column (id = true)
so the ID class is @code{String}.  Example:

@cindex dao interface
@example
/** Account DAO which has a String id (Account.name) */
public interface AccountDao extends BaseDao<Account, String> @{
    // empty wrapper, you can add additional DAO methods here
@}
@end example

The implementation of this interface takes a @code{DatabaseType} object in its constructor which identifies the
per-database flavor class.  @xref{Database Type}.  Example:

@cindex jdbc dao implementation
@example
/** JDBC implementation of the AccountDao interface. */
public class AccountJdbcDao extends BaseJdbcDao<Account, String>
  implements AccountDao @{
    public AccountJdbcDao(DatabaseType databaseType) @{
        super(databaseType, Account.class);
    @}
@}
@end example

That's all you need to define your DAO classes.  You are free to add more methods to your DAO interfaces and
implementations if there are specific operations that are needed and not provided by the Dao base classes.
More on how to use these DAOs later. @xref{DAO Usage}.

@c ----------------------------------------------------------------
@node DataSource, Connection, DAOs, Getting Started
@section JDBC Data Sources

@cindex data source
@cindex database connection
@cindex simple data source
To use the database and the DAO objects, you will need to configure what JDBC calls a @code{DataSource} (see the
@code{javax.sql.DataSource} class).  The @code{DataSource} is a factory for connections to the physical SQL
database.  Here is a code example that creates a simple data source.

@cindex DatabaseTypeUtils
@cindex simple data source
@cindex data source, simple
@example
// single connection data source example
DataSource dataSource =
  DatabaseTypeUtils.createSimpleDataSource("jdbc:h2:mem:account");
@end example

@cindex pooled connections
@cindex connection pooling
There are many other data sources that can be used instead, including pooled connections which will create new
connections on demand and re-use existing dormant connections. You can instantiate your own without the
DatabaseTypeUtils and set it on the DAOs directly.

@cindex close data source
@cindex destroy data source
When you are done with your DataSource, you will want to call the close() or destroy() method to close any underlying 
@code{java.sql.Connection} objects.  Something like the following pattern is recommended.

@example
SimpleDataSource dataSource = null;
try @{
    dataSource = new SimpleDataSource();
    dataSource.setURL("jdbc:h2:mem:account");
    dataSource.setUsername("billy");
    dataSource.setPassword("_secret");
    // work with the data-source and DAOs
    @dots{}
@} finally @{
    if (dataSource != null) @{
        dataSource.close();
    @}
@}
@end example

@c ----------------------------------------------------------------
@node Connection, Complete Wiring, DataSource, Getting Started
@section Database Connections

@cindex database type
@cindex DatabaseTypeUtils
@value{package} works with a @code{DatabaseType} object which defines all of the per-database information necessary to
support the various features on all of the different database types.  @xref{Database Type}.  To instantiate a
@code{DatabaseType}, you can either use the @code{DatabaseTypeUtils} class or call your database class directly.  You
can pass in the database URL or pass in an already created @code{DataSource} object:

@table @asis

@item use the DatabaseTypeUtils class with the database URI
@example
DatabaseType databaseType =
  DatabaseTypeUtils.createDatabaseType("jdbc:h2:mem:account");
@end example

@item use DatabaseTypeUtils with an already established javax.sql.DataSource
@example
DatabaseType databaseType =
  DatabaseTypeUtils.createDatabaseType(dataSource);
@end example

@item instantiate a DatabaseType class directly 
@example
DatabaseType databaseType = new H2DatabaseType();
@end example

@end table

@cindex load database driver
@cindex database driver load
After you instantiate your DatabaseType, you will need to call the loadDriver() method to make sure that
the driver has wired itself into JDBC appropriately.

@example
DatabaseType databaseType = new H2DatabaseType();
databaseType.loadDriver();
@end example

For more information about the database specific code in the DatabaseType.  @xref{Database Type}.

@c ----------------------------------------------------------------
@node Complete Wiring, DAO Usage, Connection, Getting Started
@section Tying It All Together

@cindex usage example
So you have annotated the objects to persist, added the no-arg constructor, defined your DAO classes, established your
DatabaseType, and created your DataSource.  You are ready to start persisting and querying your database objects.  The
following code ties it all together:

@example
// h2 by default but change to match your database
String databaseUrl = "jdbc:h2:mem:account";
SingleConnectionDataSource dataSource =
  DatabaseTypeUtils.createSimpleDataSource(databaseUrl);
DatabaseType databaseType =
  DatabaseTypeUtils.createDatabaseType(dataSource);
databaseType.loadDriver();

// instantiate the dao
AccountJdbcDao accountDao = new AccountJdbcDao(databaseType);
accountDao.setDataSource(dataSource);
// _must_ make this call after the setters
accountDao.initialize();

// if you need to create the 'accounts' table make this call
TableUtils.createTable(databaseType, dataSource, Account.class);

// create an instance of Account
Account account = new Account();
account.name = "Jim Coakley";

// persist the account object to the database
// it should return 1 for the 1 row inserted
if (accountDao.create(account) != 1) @{
  error handling @dots{} 
@}
@dots{}

// destroy the data source which should close underlying connections
dataSource.destroy();
@end example

@cindex initialize
@cindex spring
@emph{NOTE:} as you see in the above example, if you are instantiating a DAO class outside of Spring
then you will need to call @code{initialize()} method to properly initialize the class.

@cindex code examples
For more examples, see the @code{com.j256.ormlite.examples} package test classes in the Java sources jar down in
@code{src/test/java}.

@c ----------------------------------------------------------------
@node DAO Usage, Basic DAO Usage, Complete Wiring, Top
@chapter Using the DAOs

@cindex DAO usage
@cindex using the DAOs
@menu
* Basic DAO Usage::             Basic commands provided by the DAOs.
* DAO Methods::                 What functionality is provided by the DAO.
@end menu

@c ----------------------------------------------------------------
@node Basic DAO Usage, DAO Methods, DAO Usage, DAO Usage
@section Basic DAO Usage

The following database operations are easily accomplished by using the DAO classes:

@table @asis

@cindex creating a database row
@cindex saving an object
@cindex persisting an object
@cindex writing an object
@item create and persist an object to the database

This inserts a new row to the database table associated with the object.

@example
Account account = new Account();
account.name = "Jim Coakley";
// only 1 row should have been affected
if (accountDao.create(account) != 1) @{
  error handling @dots{} 
@}
@end example

@cindex query for id
@item query for it's id column 

If the object has an id field defined by the annotations, then we can lookup an object in the database using its id.

@example
Account account = accountDao.queryForId(name);
if (account == null) @{
  account not found handling @dots{} 
@}
@end example

@cindex updating an object
@item update the database row associated with the object

If you change fields in an object, you must call update to persist those changes to the database.  This also requires
an id field. 

@example
account.password = "_secret";
// 1 row should be updated
if (accountDao.update(account) != 1) @{
  error handling @dots{} 
@}
@end example

@cindex refreshing an object
@item refreshing our object if the database has changed

If some other entity has changed a row the database corresponding to an object in memory, you will need to refresh that
object to get the memory object up-to-date.  This also requires an id field. 

@example
// 1 row should be found
if (accountDao.refresh(account) != 1) @{
  error handling @dots{} 
@}
@end example

@cindex deleting an object
@item delete the account from the database

Removes the row that corresponds to the object from the database.  This also requires an id field.

@example
// 1 row should be affected
if (accountDao.delete(account) != 1) @{
  error handling @dots{} 
@}
@end example

@cindex iterator
@cindex iterating through all rows
@item iterate through all of the rows in a table:

The DAO is also an iterator so you can easily run through all of the rows in the database:

@example
// page through all of the accounts in the database
for (Account account : accountDao) @{
    System.out.println(account.getName());
@}
@end example

@cindex closing an iterator 
@emph{NOTE:} you must page through _all_ items for the iterator to close the underlying SQL object.   If you don't
go all of the way, the garbage collector will close the SQL statement some time later which is considered bad form.

@end table

@c ----------------------------------------------------------------
@node DAO Methods, Query Builder, Basic DAO Usage, DAO Usage
@section DAO Methods

@cindex dao methods
The DAO classes provide the following methods that you can use to store your objects to your database.
This list may be out of date.  See the @code{Dao} interface class for the latest methods.

@table @code

@cindex query for id
@item queryForId

Looks up the id in the database and retrieves an object associated with it.

@cindex query for first
@item queryForFirst

Query for and return the first item in the object table which matches a prepared query. This can be used to return
the object that matches a single unique column.  You should use queryForId if you want to query for the id column.

@cindex query for all
@item queryForAll

Query for all of the items in the object table and return a list of them. For medium sized or large tables,
you should consider using the iterator method instead.

@cindex query builder
@item queryBuilder

Create and return a new QueryBuilder object which allows you to build a custom query.  @xref{Query Builder}.

@cindex query for objects
@item query

Query for the items in the object table which match a prepared query.  @xref{Query Builder}.  This returns a
list of matching objects. For medium sized or large tables, you should consider using the iterator method instead.  

@cindex creating an object
@item create

Create a new entry in the database from an object.  Should return 1 indicating 1 row was inserted.

@cindex updating an object
@item update

Save the fields from an object to the database. If you have made changes to an object, this is how you persist
those changes to the database. You cannot use this method to update the id field -- see updateId.  This should
return 1 since 1 row was updated.

@cindex update an object id
@item updateId

Update an object in the database to change its id to a new id. The data @emph{must} have its current id set and
the new-id is passed in as an argument.  After the id has been updated in the database, the id field of the data
object will also be changed.  This should return 1 since 1 row was updated.

@cindex refreshing an object
@item refresh

Does a query for the object's id and copies in each of the field values from the database to refresh the data
parameter. Any local object changes to persisted fields will be overwritten.  If the database has been updated
this brings your local object up-to-date.  This should return 1 since 1 row was retrieved.

@cindex deleting an object
@item delete

Delete an object from the database.  This should return 1 since 1 row was removed.

@cindex delete multiple objects
@item delete (collection)

Delete a collection of objects from the database using an IN SQL clause.  This returns the number of rows that
were deleted.

@cindex delete object by id
@item deleteIds

Delete the objects that match the collection of ids from the database using an IN SQL clause.   This returns the
number of rows that were deleted.  

@cindex iterator
@item iterator

This method satisfies the @code{Iterable} Java interface for the class and allows you to iterate through the objects
in the table using SQL.  This method allows you to do something like:

@example
for (Account account : accountDao) @{ @dots{} @}
@end example

@emph{WARNING:} See the @code{Dao} class for warnings about using this method.

@item iterator (prepared query)

Same is the iterator method but with a prepared query parameter. @xref{Query Builder}.

@end table

@c ----------------------------------------------------------------
@node Query Builder, QueryBuilder Basics, DAO Methods, Top
@chapter Custom Query Builder

@cindex query builder
@cindex custom query builder
The DOAs have methods to query for an object that matches an id field (@code{queryForId}) as well as query for all
objects (@code{queryForAll}) and iterating through all of the objects in a table (@code{iterator}).  For more specified
queries, there is also a @code{queryBuilder()} method which returns a @code{QueryBuilder} object for the DAO with which
you can construct custom queries to return a sub-set of the table.

@menu
* QueryBuilder Basics::         How to start using the Query Builder.
* Building Queries::            How to build simple and complex queries.
* Select Arguments::            Using arguments to queries.
@end menu

@c ----------------------------------------------------------------
@node QueryBuilder Basics, Building Queries, Query Builder, Query Builder
@section Query Builder Basics

Here's how you use the query builder to construct custom queries.  First, it is a good pattern to set the column
names of the fields with Java constants so you can use them in queries.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
    public static final String PASSWORD_FIELD_NAME = "password"; 
	
	@dots{}
    @@DatabaseField(canBeNull = false, columnName = PASSWORD_FIELD_NAME)
    private String password;
	@dots{}
@end example

This allows us to construct queries using the password field name without having the renaming of a field in the future break
our queries.  This should be done @emph{even} if the name of the field and the column name are the same.

@cindex where
@example
// get our QueryBuilder from the DAO
QueryBuilder<Account, String> queryBuilder = accountDao.queryBuilder();
// set the WHERE to: the 'password' field must be equal to "qwerty"
queryBuilder.where().eq(Account.PASSWORD_FIELD_NAME, "qwerty");
PreparedQuery<Account, String> preparedQuery =
  queryBuilder.prepareQuery();
// query for all accounts that have that password
List<Account> accountList = accountDao.query(preparedQuery);
@end example

@cindex prepared query
You get a @code{QueryBuilder} object from DAO, call methods on it to build your custom query, call @code{queryBuilder.prepareQuery()}
which returns a @code{PreparedQuery} object, and then pass the @code{PreparedQuery} to the query or iterator methods.

@c ----------------------------------------------------------------
@node Building Queries, Select Arguments, QueryBuilder Basics, Query Builder
@section Building Queries

@cindex building queries
There are a couple of different ways that you can build queries.  The QueryBuilder has been written for ease of use
as well for power users.  Simple queries can be done linearly:

@example
QueryBuilder<Account, String> queryBuilder = accountDao.queryBuilder();
// get the WHERE object to build our query
Where where = queryBuilder.where();
// the name field must be equal to "foo"
where.eq(Account.NAME_FIELD_NAME, "foo");
// and
where.and();
// the password field must be equal to "_secret"
where.eq(Account.PASSWORD_FIELD_NAME, "_secret");
PreparedQuery<Account, String> preparedQuery =
  queryBuilder.prepareQuery();
@end example

The SQL query that will be generated from the above example will be approximately:

@example
SELECT * FROM account
  WHERE (name = 'foo' AND password = '_secret')
@end example

@cindex chain query methods
If you'd rather chain the methods onto one line (like StringBuilder), this can also be written as:

@example
queryBuilder.where()
  .eq(Account.NAME_FIELD_NAME, "foo")
  .and()
  .eq(Account.PASSWORD_FIELD_NAME, "_secret");
@end example

If you'd rather use parenthesis to group the comparisons properly then you can call:

@example
Where where = queryBuilder.where();
where.and(where.eq(Account.NAME_FIELD_NAME, "foo"),
          where.eq(Account.PASSWORD_FIELD_NAME, "_secret"));
@end example

@cindex complex query
All three of the above call formats produce the same SQL.  For complex queries that mix ANDs and ORs, the last
format may be necessary to get the grouping correct.  For example, here's a complex query:

@example
Where where = queryBuilder.where();
where.or(
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "foo"),
    where.eq(Account.PASSWORD_FIELD_NAME, "_secret")),
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "bar"),
    where.eq(Account.PASSWORD_FIELD_NAME, "qwerty")));
@end example

This produces the following approximate SQL:

@example
SELECT * FROM account
  WHERE ((name = 'foo' AND password = '_secret')
         OR (name = 'bar' AND password = 'qwerty'))
@end example

@cindex order by
@cindex group by
@cindex like
@cindex in
@cindex is null
@cindex comparisons
The @code{QueryBuilder} also allows you to set what specific columns you want returned, specify the 'ORDER BY' and 'GROUP BY'
fields, and various other SQL features (LIKE, IN, >, >=, <, <=, <>, IS NULL, @dots{}).  See the javadocs on @code{QueryBuilder}
and @code{Where} classes for more information.  A good SQL reference site can be found at @uref{http://www.w3schools.com/Sql/}.

@c ----------------------------------------------------------------
@node Select Arguments, Foreign Objects, Building Queries, Query Builder
@section Using Select Arguments

@cindex query arguments
@cindex select arguments
@cindex arguments to queries
@cindex sql ?
The arguments that are used in WHERE operations can be specified directly as value arguments (as in the above examples) or as a
@code{SelectArg} object.  SelectArgs are used to set the value of an argument at a later time -- they generate a SQL '@code{?}'.
For example:

@example
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
Where where = queryBuilder.where();
SelectArg selectArg = new SelectArg();
// define our query as 'name = ?'
where.eq(Account.NAME_FIELD_NAME, selectArg);
// prepare it so it is ready for later query or iterator calls
PreparedQuery<Account, String> preparedQuery =
  queryBuilder.prepareQuery();

// later we can set the select argument and issue the query
selectArg.setValue("foo");
List<Account> accounts = accountDao.query(preparedQuery);
// then we can set the select argument to another
// value and re-run the query
selectArg.setValue("bar");
accounts = accountDao.query(preparedQuery);
@end example

@emph{NOTE:} @code{SelectArg} objects have protection against being used in more than one column name.  You must instantiate a
new object if you want to use a @code{SelectArg} with another column.

@c ----------------------------------------------------------------
@node Foreign Objects, Advanced, Select Arguments, Top
@chapter Foreign Object Fields

@cindex foreign objects
@value{package} supports the concept of "foreign" objects where one or more of the fields correspond to an object
persisted in another table in the same database.  For example, if you had an @code{Order} objects in your database
and each @code{Order} had a corresponding @code{Account} object, then the @code{Order} object would have foreign
@code{Account} field.  With foreign objects, @emph{just} the id field from the @code{Account} is persisted
to the @code{Order} table as the column "@code{account_id}".  For example, the @code{Order} class might look
something like:

@example
@@DatabaseTable(tableName = "orders")
public class Order @{

    @@DatabaseField(generatedId = true)
    private int id;
    
    @@DatabaseField(canNull = false, foreign = true)
    private Account account;
    @dots{}
@}
@end example

When the @code{Order} table was created, something like the following SQL would be generated:

@example
CREATE TABLE `orders`
   (`id` INTEGER AUTO_INCREMENT , `account_id` INTEGER, PRIMARY KEY (`id`)); 
@end example

@cindex refreshing foreign objects
@cindex foreign object refreshing
When you query for an order, you will get an @code{Order} object with an account field object that @emph{only} has its id
field set -- all of the fields in the foreign @code{Account} object will have default values (null, 0, false, etc.).  If
you want to use other fields in the @code{Account}, you can use a refresh call to set all of the fields in the
@code{Account} object.  For example:

@example
if (accountDao.refresh(order.getAccount()) != 1) @{
  error handling @dots{} 
@}
@end example

@emph{NOTE:} Because we use refresh, foreign objects are therefor @emph{required} to have an id field.

@c ----------------------------------------------------------------
@node Advanced, Spring Configuration, Foreign Objects, Top
@chapter Advanced Concepts

@menu
* Spring Configuration::       How to wire @value{package} in Spring.
* Class Configuration::        Alternate ways to configure your classes.
* Database Type::              Description of the database specific code.
* Logging::                    How to log messages with @value{package}.
@end menu

@c ----------------------------------------------------------------
@node Spring Configuration, Class Configuration, Advanced, Advanced
@section Spring Configuration

@cindex spring framework
@cindex configuration with Spring
@value{package} contains some classes which make it easy to configure the various database classes using
the Spring framework.  For more information about the Spring Framework, see @uref{http://www.springsource.org/}.

@table @code

@item DatabaseTypeFactory

@cindex DatabaseTypeFactory
This factory class is used for Spring injections of the database types to the DAOs and other classes.  Often, the
@code{databaseUrl} parameter is provided by a system property.

@example
<!-- database type factory-bean which is a databaseType -->
<bean id="databaseTypeFactory"
    class="com.j256.ormlite.db.DatabaseTypeFactory"
    init-method="initialize">
    <property name="databaseUrl" value="jdbc:h2:mem:account" />
</bean>
<bean id="databaseType" class="com.j256.ormlite.db.DatabaseType"
    factory-bean="databaseTypeFactory"
    factory-method="getDatabaseType" />
<bean id="driverClassName" class="java.lang.String"
    factory-bean="databaseTypeFactory"
    factory-method="getDriverClassName" />
@end example

@item TableCreator

@cindex auto create tables
@cindex create tables
@cindex auto drop tables
@cindex drop tables
Spring bean that auto-creates any tables that it finds DAOs for if the system property @code{ormlite.auto.create.tables}
has been set to true. It will also auto-drop any tables that were auto-created if the property
@code{ormlite.auto.drop.tables} has been set to true.  This should be used carefully and probably only in tests.

@end table

@cindex spring examples
Here's an example of a full Spring configuration.

@example
<!-- URL used for database, probably should be in properties file -->
<bean id="databaseUrl" class="java.lang.String">
    <!-- we are using the in-memory H2 database in this example -->
    <constructor-arg index="0" value="jdbc:h2:mem:account" />
</bean>
<!-- database type factory -->
<bean id="databaseTypeFactory"
    class="com.j256.ormlite.db.DatabaseTypeFactory"
    init-method="initialize">
    <property name="databaseUrl" value="jdbc:h2:mem:account" />
</bean>
<!-- used to get database-type out of database-type factory -->
<bean id="databaseType" class="com.j256.ormlite.db.DatabaseType"
    factory-bean="databaseTypeFactory"
    factory-method="getDatabaseType" />
<!-- used to get driver-class name out of database-type factory -->
<bean id="driverClassName" class="java.lang.String"
    factory-bean="databaseTypeFactory"
    factory-method="getDriverClassName" />

<!-- datasource used by @value{package} to connect to the database -->
<bean id="dataSource"
    class="com.j256.ormlite.support.SimpleDataSource"
    init-method="initialize">
    <property name="url" ref="databaseUrl" />
    <!-- probably should use system properties for these too -->
    <property name="username" value="foo" />
    <property name="password" value="bar" />
</bean>

<!-- abstract dao that is common to all defined daos -->
<bean id="baseDao" abstract="true" init-method="initialize">
    <property name="dataSource" ref="dataSource" />
    <property name="databaseType" ref="databaseType" />
</bean>

<!-- our daos -->
<bean id="accountDao"
    class="com.j256.ormlite.examples.common.AccountJdbcDao"
    parent="baseDao" />
@end example

@c ----------------------------------------------------------------
@node Class Configuration, Database Type, Spring Configuration, Advanced
@section Class Configuration

The simplest mechanism for configuring a class to be persisted by @value{package} is to use the @code{@@DatabaseTable}
and @code{@@DatabaseField} annotations.  @xref{Local Annotations}.  However if you do not own the class you are
persisting or there are permission problems with the class, you may want to configure the class using Java code instead.

@cindex configure a class in code
To configure a class in code, you use the @code{DatabaseFieldConfig} and @code{DatabaseTableConfig} objects.
The field config object holds all of the details that are in the @code{@@DatabaseField} annotation as well as
the name of the corresponding field in the object.  The @code{DatabaseTableConfig} object holds the class and the
corresponding list of @code{DatabaseFieldConfig}s.  For example, to configure the @code{Account} object using Java code
you'd do something like the following:

@example
List<DatabaseFieldConfig> fieldConfigs =
    new ArrayList<DatabaseFieldConfig>();
fieldConfigs.add(new DatabaseFieldConfig("name", null, JdbcType.UNKNOWN,
    null, 0, false, false, true, null, false, null, false));
fieldConfigs.add(new DatabaseFieldConfig("password", null,
    JdbcType.UNKNOWN, null, 0, false, false, false, null, false, null,
    false));
DatabaseTableConfig<Account> accountTableConfig
    = new DatabaseTableConfig<Account>(Account.class, fieldConfigs);

AccountJdbcDao accountJdbcDao = new AccountJdbcDao();
// set our table config on the dao
accountJdbcDao.setTableConfig(accountTableConfig);
accountJdbcDao.setDatabaseType(databaseType);
accountJdbcDao.setDataSource(dataSource);
accountJdbcDao.afterPropertiesSet();
@end example

@cindex spring wire a class
See the Javadocs for the @code{DatabaseFieldConfig} class for the fields to pass to the constructor.  You can also
use the no-argument constructor and call the setters for each field.  You use the setters as well when you are
configuring a class using Spring wiring.  Here is the above example in Spring:

@example
<bean id="accountTableConfig"
  class="com.j256.ormlite.table.DatabaseTableConfig">
    <property name="dataClass"
        value="com.j256.ormlite.examples.common.Account" />
    <property name="tableName" value="account" />
    <property name="fieldConfigs">
        <list>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="name" />
                <property name="id" value="true" />
            </bean>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="password" />
                <property name="canBeNull" value="false" />
            </bean>
        </list>
    </property>
</bean>
@end example

@c ----------------------------------------------------------------
@node Database Type, Logging, Class Configuration, Advanced
@section Database Specific Code

@cindex database type
@cindex database specific code
@value{package} isolates the database-specific code in the @code{DatabaseType} classes found in
@code{com.j256.ormlite.db}.  Each of the supported databases has a class there which implements the code needed to
handle the unique features of the database (H2DatabaseType, MySqlDatabaseType, etc.).   If you want to help develop
and test against other SQL databases, a externally available server that the author could connect to and test
against would be appreciated.  Please contact the author if your database is not supported or if you want to help.

The following methods are currently used by the system to isolate the database specific behavior in one place.
See the javadocs for the @code{DatabaseType} class for more information.

@table @code

@item getDriverUrlPart

Return the part in the database URI which identifies the particular database.  Usually the
URI is in the form jdbc:XXX:@dots{} where XXX is the driver url part.

@item getDriverClassName

Returns the class name of the driver that may or may not be in the ClassPath depending on what database is
being used.

@item loadDriver

Load the driver class associated with this database so it can wire itself into JDBC.

@item appendColumnArg

Takes a field type and appends the SQL necessary to create the field.  It may also generate arguments
for the end of the table create statement or commands that must run before or after the table create.

@item dropColumnArg

Takes a field type and adds all of the commands necessary to drop the column from the database.

@item appendEscapedEntityName

Add a entity-name (table or column name) word to the SQL wrapped in the proper characters to escape it.
This avoids problems with table, column, and sequence-names being reserved words.

@item appendEscapedWord

Add the word to the string builder wrapped in the proper characters to escape it. This avoids problems with
data values being reserved words.

@item generateIdSequenceName

Return the name of an ID sequence based on the tableName and the fieldType of the id.  This is required
by some database types when we have generated ids.

@item getCommentLinePrefix

Return the prefix to put at the front of a SQL line to mark it as a comment.

@item isIdSequenceNeeded

Return true if the database needs a sequence when you insert for generated IDs.  Some databases handle
generated ids internally.

@item getFieldConverter

Return the field converter associated with a particular field type.  This allows the database instance to
convert a field as necessary before it goes to the database.

@item isVarcharFieldWidthSupported

Return true if the database supports the width parameter on VARCHAR fields.

@item isLimitSupported

Return true if the database supports the LIMIT sql command.

@item isLimitAfterSelect

Return true if the LIMIT should be called after SELECT otherwise at the end of the WHERE (the default).

@item appendLimitValue

Add the necessary SQL to limit the results to a certain number.

@item appendSelectNextValFromSequence

Add the SQL necessary to get the next-value from a sequence. This is only necessary if
isIdSequenceNeeded returns true.

@item appendCreateTableSuffix

Append the SQL necessary to properly finish a CREATE TABLE line.

@end table

@c ----------------------------------------------------------------
@node Logging, Index of Concepts, Database Type, Advanced
@section @value{package} Logging

@cindex logging information
@value{package} uses a loose wrapper around Apache commons logging that provides simple @{@} argument expansion
like slf4j.  You can use something like the following as your log4j.properties file to see details about the SQL calls.

@cindex log4j properties file
@example
log4j.rootLogger=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout

# print the date in ISO 8601 format
log4j.appender.stdout.layout.ConversionPattern=%d@{ISO8601@} [%p] %c@{1@} %m%n

# be more verbose with our code
log4j.logger.com.j256.ormlite=DEBUG

# to enable logging of arguments to all of the SQL calls
# uncomment the following line
#log4j.logger.com.j256.ormlite.stmt.mapped.BaseMappedStatement=TRACE
@end example

@cindex logging sql arguments
@cindex sql argument logging
@emph{Notice} that you can uncomment the last line in the above log4j.properties file to log the arguments to the
various SQL calls.  This may expose passwords or other sensitive information in the database so probably should
only be used during debugging and should not be the default.

@c ----------------------------------------------------------------
@node Index of Concepts,, Logging, Top
@unnumbered Index of Concepts

@printindex cp
@contents

@bye
