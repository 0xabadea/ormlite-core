\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename ormlite.info
@settitle ORM Lite Documentation
@setchapternewpage odd
@headings double
@c %**end of header

@dircategory Libraries
@direntry
* ORMLite: (orm lite).			Lightweight ORM package.
@end direntry

@c ----------------------------------------------------------------
@c This file has the new style title page commands.
@c Also, it uses `@@include' files instead of `@@input' files.

@c Run using special version of `texinfo.tex'.

@c Also, run `makeinfo' rather than `texinfo-format-buffer'.
@c ----------------------------------------------------------------

@c ----------------------------------------------------------------
@set ormlite_version 3.1
@set ormlite_date September 2010
@set package ORMLite
@c ----------------------------------------------------------------

@ifinfo
This file is an introduction to the ORM Lite package which is a simple Object Relationship Mapping package.

Copyright 2010 by Gray Watson.

Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice
and this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified versions of this manual under the conditions for
verbatim copying, provided also that the chapter entitled ``Copying'' are included exactly as in the
original, and provided that the entire resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual into another language, under the
above conditions for modified versions, except that the chapter entitled ``Copying'' may be included in a
translation approved by the author instead of in the original English.
@end ifinfo

@titlepage
@title ORM Lite Package
@subtitle Version @value{ormlite_version}
@subtitle @value{ormlite_date}
@author Gray Watson

@page
Copyright 2010 by Gray Watson.

Published by Gray Watson

Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice
and this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified versions of this manual under the conditions for
verbatim copying, provided also that the chapter entitled ``Copying'' are included exactly as in the
original, and provided that the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual into another language, under the
above conditions for modified versions, except that the chapter entitled ``Copying'' may be included in a
translation approved by the author instead of in the original English.
@end titlepage

@c ----------------------------------------------------------------
@node Top, Getting Started, (dir), (dir)
@top @value{package}

Version @value{ormlite_version} -- @value{ormlite_date}

@cindex introduction
@cindex author
@cindex object relational mapping
@cindex hibernate
@cindex ibatis
@value{package} provides a lightweight Object Relational Mapping between Java classes and SQL databases -- see
@uref{http://en.wikipedia.org/wiki/Object-relational_mapping}.  There are certainly more mature ORMs which
provide this functionality including Hibernate and iBatis.  However, the author wanted a simple yet powerful
wrapper around the JDBC functions and Hibernate and iBatis are significantly more complicated with many
dependencies.

@cindex databases supported
@cindex supported databases
@value{package} supports natively MySQL, Postgres, Microsoft SQL Server, H2, Derby, HSQLDB, and Sqlite and can be
extended to additional ones relatively easily.  There are also initial implementations for DB2 and Oracle
although the author needs access to each of these database types to tune the support.  Contact the author if
your database is not supported.

@cindex code examples
@cindex examples of code
To get started quickly with @value{package}, see the code examples down in the @code{com.j256.ormlite.examples}
package test classes in the Java sources jar down in @code{src/test/java}.  They contain a couple different
examples with working code.
@ifhtml
There is also a PDF version of this documentation -- see
@uref{http://ormlite.sourceforge.net/javadoc/doc-files/ormlite.pdf}.
@end ifhtml
@iftex
There is also a HTML version of this documentation -- see
@uref{http://ormlite.sourceforge.net/javadoc/doc-files/ormlite.html}.
@end iftex

Gray Watson @uref{http://256.com/gray/}

@menu
* Getting Started::             How to start to use @value{package}.
* DAO Usage::                   Using the Database Access Objects.
* Statement Builder::           How to utilize the custom statement builder.
* Foreign Objects::             Fields that represent foreign objects.
* Advanced::                    More advanced concepts with @value{package}.
* Contributions::               Contributions from others who helped.
* Index of Concepts::           Index of concepts in the manual.
@end menu

@c ----------------------------------------------------------------
@node Getting Started, Dependencies, Top, Top
@chapter Getting Started

@menu
* Dependencies::                External dependencies of @value{package}.
* Class Setup::                 How to setup your classes to be persisted.
* Persisted Types::             Data types that can be persisted.
* DAOs::                        How to configure the Database Access Objects.
* ConnectionSource::            Setting up connections to databases.
* Database Type::               Defining your database type.
* Complete Wiring::             Tying all of the wiring together.
@end menu

@c ----------------------------------------------------------------
@node Dependencies, Class Setup, Getting Started, Getting Started
@section External Dependencies

@value{package} does not have any direct dependencies.  It has logging classes that depend on Apache commons-logging
and Log4j but these classes will @emph{not} be referenced unless they exist in the classpath.
  
If you want to get the @value{package} Junit tests to run, there are test dependencies on the following packages:

@table @code

@item javax.persistence

For testing the compatibility annotations @code{@@Column} and the like.

@item org.junit

We use Junit for our unit tasks.

@item org.easymock.easymock

We use, and are in love with, EasyMock.  @uref{http://easymock.org/}.  It allows us to mock out dependencies so we can
concentrate on testing a particular class instead of the whole package. 

@item com.h2database

As a test database implementation, H2 is very fast and simple to use.  Not as recommended as a production level database.

@item org.apache.log4j

For logging to files using the @code{log4j.properties} config.  In the log4j package, you can exclude the following
dependencies: @code{com.sun.jmx.jmxri}, @code{com.sun.jdmk.jmxtools}, @code{javax.activation.activation},
@code{javax.jms.jms}, @code{javax.mail.mail}.

@end table

@c ----------------------------------------------------------------
@node Class Setup, Local Annotations, Dependencies, Getting Started
@section Setting Up Your Classes

To setup your classes to be persisted you need to do the following things:

@enumerate
@item Add the @@DatabaseTable annotation to the top of each class.  You can also use @@Entity.
@item Add the @@DatabaseField annotation right before each field to be persisted.  You can also use @@Column and others.
@item Add a no-argument constructor with at least package visibility to each class.
@end enumerate

@menu
* Local Annotations::                Adding the annotations to your classes.
* Javax Persistence Annotations::    Using javax.persistence annotations instead.
* No Arg Constructor::               No argument constructor is also required.
@end menu

@c ----------------------------------------------------------------
@node Local Annotations, Javax Persistence Annotations, Class Setup, Class Setup
@subsection Adding @value{package} Annotations to Your Classes

@cindex annotations
@cindex java annotations
@cindex @@DatabaseTable
@cindex DatabaseTable annotation
Annotations are special code markers have have been available in Java since version 5 that provide meta information
about classes, methods, or fields.  To specify what classes and fields to store in the database, @value{package}
supports either its own annotations (@code{@@DatabaseTable} and @code{@@DatabaseField}) or the more standard
annotations from the @code{javax.persistence} package.  @xref{Javax Persistence Annotations}.   Annotations are the
easiest way to configure your classes but you can also configure the class using Java code or Spring XML.
@xref{Class Configuration}.

With @value{package} annotations, for each of the Java classes that you would like to persist to your SQL database, you
will need to add the @code{@@DatabaseTable} annotation right above the @code{public class} line.  Each class marked with
one of these annotations will be persisted into its own database table.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@DatabaseTable} annotations can have an optional @code{tableName} argument which specifies the name of the table
that corresponds to the class.   If not specified, the class name all lowercase is used by default.  With the above example
each @code{Account} object will be persisted as a row in the @code{accounts} table in the database.

@cindex @@DatabaseField
@cindex DatabaseField annotation
Additionally, for each of the classes, you will need to add a @code{@@DatabaseField} annotation to each of the @emph{fields}
in the class that are to be persisted to the database.  Each field is persisted as a column of a database row.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{

    @@DatabaseField(id = true)
    private String name;

    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}
@end example

In this example, each row in the @code{accounts} table has 2 columns, the @code{name} column which is a string and also is the
database identity (id) of the row and the @code{password} column, also a string which can not be null. 

The @@DatabaseField annotation can have the following fields:

@table @code

@cindex column name
@cindex name of database column
@item columName

String name of the column in the database that will hold this field. If not set then the field name all lowercase is used instead.

@cindex field type
@cindex jdbc type
@cindex SQL type
@item dataType

The type of the field as the DataType class.  Usually the type is taken from Java class of the field and does not need
to be specified.  This corresponds to the SQL type.  @xref{Persisted Types}.

@cindex default value
@item defaultValue

String default value of the field when we are creating a new row in the table.  Default is none.

@cindex field width
@cindex width of field
@cindex length of field
@item width

Integer width of array fields -- usually for strings.  Some databases do not support this unfortunately.  Default for 
those that do is 255.

@cindex can be null
@cindex null value allowed
@item canBeNull

Boolean whether the field can be assigned to null or have no value. Default is true.

@cindex id field
@item id

Boolean whether the field is the id field or not. Default is false. Only one field can have this set in a class. Id fields
uniquely identity a row.  If you don't have it set then you won't be able to use the query, update, refresh, and delete by
ID methods. Only one of this, @code{generatedId}, and @code{generatedIdSequence} can be specified.

@cindex generated id
@cindex auto-generated id
@item generatedId

Boolean whether the field is an auto-generated id field. Default is false.  Only one field can have this set in a class.
This tells the database to auto-generate a corresponding id for every row inserted.  Some databases require sequences for
generated ids in which case the sequence name will be auto-generated. To specify the name of the sequence use
@code{generatedIdSequence}. Only one of this, @code{id}, and @code{generatedIdSequence} can be specified.

@cindex generated id sequence
@cindex database sequences
@cindex sequences
@item generatedIdSequence

String name of the sequence number to be used to generate this value.  Same as @code{generatedId} but you can specify the
sequence name to use.  Default is none. Only one field can have this set in a class. This is only necessary for databases
which require sequences for generated ids.  If you use generatedId instead then the code will auto-generate a sequence name.
Only one of this, @code{id}, and @code{generatedId} can be specified.

@cindex foreign objects
@cindex remote objects
@item foreign

@cindex refreshing foreign objects
Boolean setting which identifies this field as corresponding to another class that is also stored in the database.
Default is false.  The field can not be a primitive type.  The other class must have an id field (either @code{id},
@code{generatedId}, or @code{generatedIdSequence}) which will be stored in this table. When an object is returned
from a query call, any foreign objects will just have the id field set.  @xref{Foreign Objects}.

@cindex useGetSet
@cindex get and set method usage
@cindex using get and set methods
@cindex field access using getters and setters 
@item useGetSet

Boolean that says that the field should be accessed with get and set methods.  Default is false which instead uses
direct field access via Java reflection.  This may be necessary if the object you are storing has
protections around it.

@emph{NOTE:} The name of the get method @emph{must} match getXxx() where Xxx is the name of the field with the first
letter capitalized. The get @emph{must} return a class which matches the field's exactly. The set method @emph{must}
match setXxx(), have a single argument whose class matches the field's exactly, and return void.  For example:

@example
@@DatabaseField(useGetSet = true)
private Integer orderCount;

public Integer getOrderCount() @{
  return orderCount;
@}

public void setOrderCount(Integer orderCount) @{
  this.orderCount = orderCount;
@}
@end example

@cindex unknownEnumName
@cindex enumerated name unknown
@item unknownEnumName

If the field is a Java enumerated type then you can specify the name of a enumerated value which will be used if the
value of a database row is not found in the enumerated type.  If this is not specified and a database row @emph{does}
contain an unknown name or ordinal value then a @code{SQLException} is thrown when the row is being read from the database.
This is useful to handle backwards compatibility when handling out-of-date database values as well as forwards
compatibility if old software is accessing up-to-date data or if you have to roll a release back.

@cindex throwIfNull
@cindex primitive null values
@cindex null values and primitives
@item throwIfNull

Boolean that tells @value{package} to throw an exception if it sees a null value in a row and is trying to store it in
a primitive field.  By default it is false.  If it is false and the database field is null, then the value of the
primitive will be set to 0.  This can only be used on a primitive field.

@item persisted

Set this to be false (default true) to not store this field in the database. This is useful if you want to have
the annotation on all of your fields but turn off the writing of some of them to the database.

@cindex parse format
@cindex format, field
@item format

This allows you to specify format information of a particular field.  Right now only the Date fields support it when
a default value is being converted or if you are using the @code{JAVA_DATE_STRING} type.

@end table

@c ----------------------------------------------------------------
@node Javax Persistence Annotations, No Arg Constructor, Local Annotations, Class Setup
@subsection Using javax.persistence Annotations Instead

@cindex javax.persistence
@cindex @@Entity
@cindex Entity annotation
Instead of using the @value{package} annotations (@pxref{Local Annotations}), you can use the more standard
annotations from the @code{javax.persistence} package.  In place of the @code{@@DatabaseTable} annotation, you can
use the @code{javax.persistence} @code{@@Entity} annotation.  For example:

@example
@@Entity(name = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@Entity} annotations can have an optional @code{name} argument which specifies the table name.   If not
specified, the class name all lowercase is used by default.

@cindex @@Column
@cindex @@Id
@cindex @@GeneratedValue
@cindex Column annotation
@cindex Id annotation
@cindex GeneratedValue annotation
@cindex @@OneToOne
@cindex OneToOne annotation
@cindex @@ManyToOne
@cindex ManyToOne annotation
Instead of using the @code{@@DatabaseField} annotation on each of the fields, you can use the @code{javax.persistence}
annotations: @code{@@Column}, @code{@@Id}, @code{@@GeneratedValue}, @code{@@OneToOne}, and @code{@@ManyToOne}. For example:

@example
@@Entity(name = "accounts")
public class Account @{

    @@Id
    private String name;

    @@Column(nullable = false)
    private String password;
    @dots{}
@end example

The following @code{javax.persistence} annotations and fields are supported:

@table @code

@item @@Column

Specifies the field to be persisted to the database.  You can also just specify the @code{@@Id} annotation.  The
following annotation fields are supported, the rest are ignored.

@table @code

@item name

Used to specify the name of the associated database column.  If not provided then the field name is taken.

@cindex field width
@cindex width of field
@cindex length of field
@item length

Specifies the length (or width) of the database field.  Maybe only applicable for Strings and only supported by
certain database types.  Default for those that do is 255.   Same as the @code{width} field in the
@code{@@DatabaseField} annotation.

@cindex can be null
@cindex null value allowed
@item nullable

Set to true to have a field not be able to be inserted into the database with a null value.  Same as the
@code{canBeNull} field in the @code{@@DatabaseField} annotation.

@end table

@item @@Id

Used to specify a field to be persisted to the database as a primary row-id.  If you want to have the id be
auto-generated, you will need to also specify the @code{@@GeneratedValue} annotation.

@item @@GeneratedValue

Used to define an id field as having a auto-generated value.  This is only used in addition to the @code{@@Id}
annotation.  See the @code{generatedId} field in the @code{@@DatabaseField} annotation for more details.

@item @@OneToOne or @@ManyToOne

Fields with these annotations are assumed to be foreign fields.  @xref{Foreign Objects}.  @value{package} does
@emph{not} enforce the many or one relationship nor does it use any of the annotation fields.  It just uses the
existence of either of these annotations to indicate that it is a foreign object.

@end table

If the @code{@@Column} annotation is used on a field that has a unknown type then it is assumed to be a
Serializable field and the object should implement @code{java.io.Serializable}.  @xref{Persisted Types}.

@c ----------------------------------------------------------------
@node No Arg Constructor, Persisted Types, Javax Persistence Annotations, Class Setup
@subsection Adding a No Argument Constructor to Your Class

@cindex no argument constructor
@cindex constructor with no args
After you have added the class and field annotations, you will also need to add a no-argument constructor with
@emph{at least} package visibility.  When an object is returned from a query, @value{package} constructs the object
using Java reflection and a constructor needs to be called.

@example
Account() @{
  	// all persisted classes must define a no-arg constructor
  	// with at least package visibility
@}
@end example

So your final example Account class with annotations and constructor would look like:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
	
    @@DatabaseField(id = true)
    private String name;
    
    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}

    Account() @{
        // all persisted classes must define a no-arg constructor
        // with at least package visibility
    @}
    @dots{}
@}
@end example

@c ----------------------------------------------------------------
@node Persisted Types, DAOs, No Arg Constructor, Getting Started
@section Persisted Data Types

@cindex persisted types
@cindex types that are persisted
The following Java types can be persisted to the database by @value{package}.  Database specific code
helps to translate between the SQL types and the database specific handling of those types.
@xref{Database Type}.

@table @code

@cindex String
@item String (DataType.STRING)

Persisted as SQL type VARCHAR.  

@cindex boolean
@item boolean or Boolean (DataType.BOOLEAN or DataType.BOOLEAN_OBJ)

Persisted as SQL type BOOLEAN.

@cindex Date
@cindex java date
@cindex date formats
@item java.util.Date (DataType.JAVA_DATE, DataType.JAVA_DATE_LONG, or JAVA_DATE_STRING)

Persisted as SQL type TIMESTAMP.  @emph{NOTE:} This is a different class from @code{java.sql.Date}.
@emph{NOTE:} Certain databases only provide seconds resolution so the milliseconds will be 0.

You can also specify the @code{dataType} field to the @code{@@DatabaseField} annotation as a @code{DataType.JAVA_DATE_LONG}
in which case the milliseconds value of the @code{Date} will be stored as an LONG.  Or you can use
@code{DataType.JAVA_DATE_STRING} in which case the date will be stored as a string in @code{yyyy-MM-dd HH:mm:ss.SSSSSS}
format.  You can use the @code{format} field in @code{DatabaseField} to set the date to another format.

@emph{NOTE:} Because of reentrant issues with @code{SimpleDateFormat}, synchronization is done
every time a JAVA_DATE_STRING date is converted to/from the database.

@cindex byte
@item byte or Byte (DataType.BYTE or DataType.BYTE_OBJ)

Persisted as SQL type TINYINT.

@cindex short
@item short or Short (DataType.SHORT or DataType.SHORT_OBJ)

Persisted as SQL type SMALLINT.

@cindex int
@item int or Integer (DataType.INTEGER or DataType.INTEGER_OBJ)

Persisted as SQL type INTEGER.

@cindex long
@item long or Long (DataType.LONG or DataType.LONG_OBJ)

Persisted as SQL type BIGINT.

@cindex float
@item float or Float (DataType.FLOAT or DataType.FLOAT_OBJ)

Persisted as SQL type FLOAT.

@cindex double
@item double or Double (DataType.DOUBLE or DataType.DOUBLE_OBJ)

Persisted as SQL type DOUBLE.

@cindex Serializable
@cindex persist objects
@item Serializable (DataType.SERIALIZABLE)

Persisted as SQL type VARBINARY.  This is a special type that serializes an object as a sequence of bytes
and then deserializes it on the way back.  The field must be an object that implements the @code{java.io.Serializable}
interface.  Depending on the database type, there will be limits to the size of the object that can be stored.  YMMV.

@cindex Enum
@cindex enumerated types
@item enum or Enum (DataType.ENUM_STRING or DataType.ENUM_INTEGER)

Persisted by default as the enumerated value's string @emph{name} as a VARCHAR type.  You can also specify the
@code{dataType} field to the @code{@@DatabaseField} annotation as a @code{DataType.ENUM_INTEGER} in which case the
@code{ordinal} of the enum value will be stored as an INTEGER.  The name is the default (and recommended) because
it allows you to add additional enums anywhere in the list without worrying about having to convert data later.
If you insert (or remove) an enum from the list that is being stored as a number, then old data will be un-persisted
incorrectly.

@cindex unknownEnumName
You can also also specify an @emph{unknownEnumName} name with the @code{@@DatabaseField} annotation which will be
used if an unknown value is found in the database. @xref{Local Annotations}. 

@end table

@emph{NOTE:} @value{package} also supports the concept of foreign objects where the id of another object is
stored in the database.  @xref{Foreign Objects}.

@c ----------------------------------------------------------------
@node DAOs, ConnectionSource, Persisted Types, Getting Started
@section Defining the DAOs

@cindex DAO
@cindex database access object
A typical Java pattern is to isolate the database operations in Database Access Objects or DAO classes.  Each DAO
provides create, delete, update, etc. type of functionality and usually specialize in the handling a particular
persisted class.

@cindex id column
@cindex Dao interface
Once you have annotated your classes, you will need to create the DAO class(es).  The pattern that we recommend
is to define a DAO interface which extends the @code{Dao} interface and will be used in the code.  The interface
isn't required but it is a good pattern so your code is less tied to JDBC for persistence.  Each DAO has two generic
parameters: the class we are persisting with the DAO, and the class of the ID-column that will be used to
identify a specific database row.  If you class does not have an ID field, you can put @code{Object} or @code{Void}
as the 2nd argument.  For example, in the above @code{Account} class, the "name" field is the ID column (id = true)
so the ID class is @code{String}.  Example:

@example
/** Account DAO which has a String id (Account.name) */
public interface AccountDao extends Dao<Account, String> @{
    // empty wrapper, you can add additional DAO methods here
@}
@end example

The implementation of this interface takes a @code{DatabaseType} object in its constructor which identifies the
per-database flavor class.  @xref{Database Type}.  Example:

@cindex jdbc dao implementation
@example
/** JDBC implementation of the AccountDao interface. */
public class AccountDaoImpl extends BaseDaoImpl<Account, String>
  implements AccountDao @{
    public AccountDaoImpl(DatabaseType databaseType) @{
        super(databaseType, Account.class);
    @}
@}
@end example

That's all you need to define your DAO classes.  You are free to add more methods to your DAO interfaces and
implementations if there are specific operations that are needed and not provided by the Dao base classes.
More on how to use these DAOs later. @xref{DAO Usage}.

@cindex createDao method
You are not @emph{required} to create a DAO class for every one of your persisted objects.  You can use the
@code{createDao} static method on the @code{BaseDaoImpl} class to create a DAO class without having to define
one.  For example:

@example
Dao<Account, String> accountDao =
  BaseDaoImpl.createDao(databaseType, connectionSource, Account.class);
Dao<Order, Integer> orderDao =
  BaseDaoImpl.createDao(databaseType, connectionSource, Order.class);
@end example

@c ----------------------------------------------------------------
@node ConnectionSource, Database Type, DAOs, Getting Started
@section Connection Sources

@cindex data source
@cindex connection source
@cindex database connection
@cindex simple connection source
To use the database and the DAO objects, you will need to configure what JDBC calls a @code{DataSource} (see the
@code{javax.sql.DataSource} class).  The @code{DataSource} is a factory for connections to the physical SQL
database.  Since @value{package} also supports non-JDBC connections, we use a subset of the @code{DataSource}
methods in the @code{ConnectionSource} interface.  Here is a code example that creates a simple connection source.

@cindex DatabaseTypeUtils
@cindex connection source, simple
@example
// single connection source example
ConnectionSource connectionSource =
  DatabaseTypeUtils.createJdbcConnectionSource("jdbc:h2:mem:account");
@end example

@cindex pooled connections
@cindex connection pooling
There are many other data sources that can be used instead, including pooled connections which will create new
connections on demand and re-use existing dormant connections. You can instantiate your own without the
@code{DatabaseTypeUtils} and wrap it in the @code{DataSourceConnectionSource} which just delegates to it.  Then
you set that on the DAOs directly.

@cindex BasicDataSource
@cindex DataSourceConnectionSource
@example
// basic Apache data source
BasicDataSource dataSource = new BasicDataSource();
dataSource.setUrl("jdbc:h2:mem:account");
// we wrap it in the DataSourceConnectionSource
Dao<Account, String> accountDao =
  BaseDaoImpl.createDao(databaseType,
     new DataSourceConnectionSource(dataSource), Account.class);
@end example

@cindex close data source
@cindex destroy data source
When you are done with your @code{ConnectionSource} or @code{DataSource}, you will want to call a close() or destroy()
method (if applicable) to close any underlying connections.  Something like the following pattern
is recommended.

@example
JdbcConnectionSource connectionSource = null;
try @{
    connectionSource = new JdbcConnectionSource();
    connectionSource.setURL("jdbc:h2:mem:account");
    connectionSource.setUsername("billy");
    connectionSource.setPassword("_secret");
    // work with the data-source and DAOs
    @dots{}
@} finally @{
    if (connectionSource != null) @{
        connectionSource.close();
    @}
@}
@end example

@c ----------------------------------------------------------------
@node Database Type, Complete Wiring, ConnectionSource, Getting Started
@section Database Type

@cindex database type
@cindex DatabaseTypeUtils
@value{package} works with a @code{DatabaseType} object which defines all of the per-database information necessary to
support the various features on all of the different database types.  @xref{Database Type}.  To instantiate a
@code{DatabaseType}, you can either use the @code{DatabaseTypeUtils} class or call your database class directly.

@example
// use the DatabaseTypeUtils class with the database URI
DatabaseType databaseType =
  DatabaseTypeUtils.createDatabaseType("jdbc:h2:mem:account");

// _OR_ instantiate a DatabaseType class directly 
DatabaseType databaseType = new H2DatabaseType();
@end example

@cindex load database driver
@cindex database driver load
After you instantiate your DatabaseType, you will need to call the loadDriver() method to make sure that
the driver has wired itself into JDBC appropriately.

@example
DatabaseType databaseType = new H2DatabaseType();
databaseType.loadDriver();
@end example

For more information about the database specific code in the DatabaseType.  @xref{Database Type Details}.

@c ----------------------------------------------------------------
@node Complete Wiring, DAO Usage, Database Type, Getting Started
@section Tying It All Together

@cindex usage example
So you have annotated the objects to be persisted, added the no-arg constructor, defined your DAO classes,
created your @code{DataSource}, and established your @code{DatabaseType}.  You are ready to start persisting and
querying your database objects.  The following code ties it all together:

@example
// h2 by default but change to match your database
String databaseUrl = "jdbc:h2:mem:account";
JdbcConnectionSource connectionSource =
  DatabaseTypeUtils.createJdbcConnectionSource(databaseUrl);
DatabaseType databaseType =
  DatabaseTypeUtils.createDatabaseType(databaseUrl);
databaseType.loadDriver();

// instantiate the dao
AccountDaoImpl accountDao = new AccountDaoImpl();
accountDao.setDatabaseType(databaseType);
accountDao.setConnectionSource(connectionSource);
// _must_ make this call after the setters
accountDao.initialize();

// if you need to create the 'accounts' table make this call
TableUtils.createTable(databaseType, connectionSource, Account.class);

// create an instance of Account
Account account = new Account("Jim Coakley");

// persist the account object to the database
// it should return 1 for the 1 row inserted
if (accountDao.create(account) != 1) @{
  // error handling @dots{} 
@}
// other code @dots{}

// destroy the data source which should close underlying connections
connectionSource.destroy();
@end example

@cindex initialize
@cindex spring
@emph{NOTE:} as you see in the above example, if you are instantiating a DAO class outside of Spring
then you will need to call @code{initialize()} method to properly initialize the class.

@cindex code examples
For more examples, see the @code{com.j256.ormlite.examples} package test classes in the Java sources jar down in
@code{src/test/java}.

@c ----------------------------------------------------------------
@node DAO Usage, Basic DAO Usage, Complete Wiring, Top
@chapter Using the DAOs

@cindex DAO usage
@cindex using the DAOs
@menu
* Basic DAO Usage::             Basic commands provided by the DAOs.
* DAO Methods::                 What functionality is provided by the DAO.
@end menu

@c ----------------------------------------------------------------
@node Basic DAO Usage, DAO Methods, DAO Usage, DAO Usage
@section Basic DAO Usage

The following database operations are easily accomplished by using the DAO classes:

@table @asis

@cindex creating a database row
@cindex saving an object
@cindex persisting an object
@cindex writing an object
@item create and persist an object to the database

This inserts a new row to the database table associated with the object.

@example
Account account = new Account();
account.name = "Jim Coakley";
// only 1 row should have been affected
if (accountDao.create(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex query for id
@item query for it's id column 

If the object has an id field defined by the annotations, then we can lookup an object in the database using its id.

@example
Account account = accountDao.queryForId(name);
if (account == null) @{
  account not found handling @dots{} 
@}
@end example

@cindex updating an object
@item update the database row associated with the object

If you change fields in an object in memory, you must call update to persist those changes to the database.  This
also requires an id field. 

@example
account.password = "_secret";
// 1 row should be updated
if (accountDao.update(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex refreshing an object
@item refreshing our object if the database has changed

If some other entity has changed a row the database corresponding to an object in memory, you will need to refresh that
object to get the memory object up-to-date.  This also requires an id field. 

@example
// 1 row should be found
if (accountDao.refresh(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex deleting an object
@item delete the account from the database

Removes the row that corresponds to the object from the database.  Once the object has been deleted from the database,
you can continue to use the object in memory but any update or refresh calls will fail.  This also requires an id field.

@example
// 1 row should be affected
if (accountDao.delete(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex iterator
@cindex iterating through all rows
@item iterate through all of the rows in a table:

The DAO is also an iterator so you can easily run through all of the rows in the database:

@example
// page through all of the accounts in the database
for (Account account : accountDao) @{
    System.out.println(account.getName());
@}
@end example

@cindex closing an iterator 
@emph{NOTE:} you must page through @emph{all} items for the iterator to close the underlying SQL object.   If you don't
go all of the way, the garbage collector will close the SQL statement some time later which is considered bad form.

@end table

@c ----------------------------------------------------------------
@node DAO Methods, Statement Builder, Basic DAO Usage, DAO Usage
@section DAO Methods

@cindex dao methods
The DAO classes provide the following methods that you can use to store your objects to your database.
This list may be out of date.  See the @code{Dao} interface class for the latest methods.

@table @code

@cindex query for id
@item queryForId

Looks up the id in the database and retrieves an object associated with it.

@cindex query for first
@item queryForFirst

Query for and return the first item in the object table which matches a prepared statement. This can be used to return
the object that matches a single unique column.  You should use queryForId if you want to query for the id column.

@cindex query for all
@item queryForAll

Query for all of the items in the object table and return a list of them. For medium sized or large tables,
this may load a lot of objects into memory so you should consider using the @code{iterator} method instead.

@cindex query for all raw
@cindex raw select statements
@cindex executing raw select statements
@item queryForAllRaw

Query for all of the items in the object table that match the SQL select query argument. This method allows you
to do special queries that aren't supported otherwise. For medium sized or large tables, this may load a lot of 
objects into memory so you should consider using the @code{iteratorRaw} method instead.

@cindex query builder
@cindex statement builder
@item statementBuilder

Create and return a new @code{StatementBuilder} object which allows you to build a custom query.  @xref{Statement Builder}.

@cindex query for objects
@item query

Query for the items in the object table which match a prepared statement.  @xref{Statement Builder}.  This returns a
list of matching objects. For medium sized or large tables, this may load a lot of objects into memory so you
should consider using the @code{iterator} method instead.  

@cindex creating an object
@item create

Create a new entry in the database from an object.  Should return 1 indicating 1 row was inserted.

@cindex updating an object
@item update

Save the fields from an object to the database. If you have made changes to an object, this is how you persist
those changes to the database. You cannot use this method to update the id field -- see updateId.  This should
return 1 since 1 row was updated.

@cindex update an object id
@item updateId

Update an object in the database to change its id to a new id. The data @emph{must} have its current id set and
the new-id is passed in as an argument.  After the id has been updated in the database, the id field of the data
object will also be changed.  This should return 1 since 1 row was updated.

@cindex refreshing an object
@item refresh

Does a query for the object's id and copies in each of the field values from the database to refresh the data
parameter. Any local object changes to persisted fields will be overwritten.  If the database has been updated
this brings your local object up-to-date.  This should return 1 since 1 row was retrieved.

@cindex deleting an object
@item delete

Delete an object from the database.  This should return 1 since 1 row was removed.

@cindex delete multiple objects
@item delete (collection)

Delete a collection of objects from the database using an IN SQL clause.  This returns the number of rows that
were deleted.

@cindex delete objects by id
@item deleteIds

Delete the objects that match the collection of ids from the database using an IN SQL clause.   This returns the
number of rows that were deleted.  

@cindex iterator
@item iterator

This method satisfies the @code{Iterable} Java interface for the class and allows you to iterate through the objects
in the table using SQL.  This method allows you to do something like:

@example
for (Account account : accountDao) @{ @dots{} @}
@end example

@emph{WARNING:} See the @code{Dao} class for warnings about using this method.

@item iterator (prepared statement)

Same is the @code{iterator} method but with a prepared statement parameter. @xref{Statement Builder}.

@item iteratorRaw

Same as the prepared statement iterator except it takes a raw SQL select statement argument.  This is the iterator version
of the @code{queryForAllRaw} method.  Although you should use the @code{iterator} method for most queries, this method
allows you to do special queries that aren't supported otherwise.  Like the above iterator methods, you must call close
on the returned RawResults object once you are done with it. 

@end table

@c ----------------------------------------------------------------
@node Statement Builder, StatementBuilder Basics, DAO Methods, Top
@chapter Custom Statement Builder

@cindex query builder
@cindex custom query builder
@cindex custom statement builder
The DOAs have methods to query for an object that matches an id field (@code{queryForId}) as well as query for all
objects (@code{queryForAll}) and iterating through all of the objects in a table (@code{iterator}).  However, for more
specified queries, there is the @code{statementBuilder()} method which returns a @code{StatementBuilder} object for the DAO
with which you can construct custom queries to return a sub-set of the table.

@menu
* StatementBuilder Basics::     How to start using the Statement Builder.
* Building Queries::            How to build simple and complex queries.
* Select Arguments::            Using arguments to queries.
@end menu

@c ----------------------------------------------------------------
@node StatementBuilder Basics, Building Queries, Statement Builder, Statement Builder
@section Statement Builder Basics

Here's how you use the statement builder to construct custom queries and other statements.  First, it is a good pattern to
set the column names of the fields with Java constants so you can use them in queries.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
    public static final String PASSWORD_FIELD_NAME = "password"; 
	
	@dots{}
    @@DatabaseField(canBeNull = false, columnName = PASSWORD_FIELD_NAME)
    private String password;
	@dots{}
@end example

This allows us to construct queries using the password field name without having the renaming of a field in the future break
our queries.  This should be done @emph{even} if the name of the field and the column name are the same.

@cindex where
@example
// get our StatementBuilder from the DAO
StatementBuilder<Account, String> statementBuilder = accountDao.statementBuilder();
// set the WHERE to: the 'password' field must be equal to "qwerty"
statementBuilder().eq(Account.PASSWORD_FIELD_NAME, "qwerty");
PreparedStmt<Account, String> preparedStmt =
  statementBuilder.prepareStatment();
// query for all accounts that have that password
List<Account> accountList = accountDao.query(preparedStmt);
@end example

@cindex prepared statement
You get a @code{StatementBuilder} object from the DAO, call methods on it to build your custom query, call
@code{statementBuilder.prepareStatment()} which returns a @code{PreparedStmt} object, and then pass the @code{PreparedStmt} to
the query or iterator methods.

@c ----------------------------------------------------------------
@node Building Queries, Select Arguments, StatementBuilder Basics, Statement Builder
@section Building Queries

@cindex building queries
There are a couple of different ways that you can build queries.  The @code{StatementBuilder} has been written for ease of use
as well for power users.  Simple queries can be done linearly:

@example
StatementBuilder<Account, String> statementBuilder = accountDao.statementBuilder();
// get the WHERE object to build our query
Where where = statementBuilder();
// the name field must be equal to "foo"
where.eq(Account.NAME_FIELD_NAME, "foo");
// and
where.and();
// the password field must be equal to "_secret"
where.eq(Account.PASSWORD_FIELD_NAME, "_secret");
PreparedStmt<Account, String> preparedStmt =
  statementBuilder.prepareStatement();
@end example

The SQL query that will be generated from the above example will be approximately:

@example
SELECT * FROM account
  WHERE (name = 'foo' AND password = '_secret')
@end example

@cindex chain query methods
If you'd rather chain the methods onto one line (like StringBuilder), this can also be written as:

@example
statementBuilder.where()
  .eq(Account.NAME_FIELD_NAME, "foo")
  .and()
  .eq(Account.PASSWORD_FIELD_NAME, "_secret");
@end example

If you'd rather use parenthesis to group the comparisons properly then you can call:

@example
Where where = statementBuilder.where();
where.and(where.eq(Account.NAME_FIELD_NAME, "foo"),
          where.eq(Account.PASSWORD_FIELD_NAME, "_secret"));
@end example

@cindex complex query
All three of the above call formats produce the same SQL.  For complex queries that mix ANDs and ORs, the last
format may be necessary to get the grouping correct.  For example, here's a complex query:

@example
Where where = statementBuilder.where();
where.or(
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "foo"),
    where.eq(Account.PASSWORD_FIELD_NAME, "_secret")),
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "bar"),
    where.eq(Account.PASSWORD_FIELD_NAME, "qwerty")));
@end example

This produces the following approximate SQL:

@example
SELECT * FROM account
  WHERE ((name = 'foo' AND password = '_secret')
         OR (name = 'bar' AND password = 'qwerty'))
@end example

@cindex order by
@cindex group by
@cindex like
@cindex in
@cindex is null
@cindex comparisons
The @code{StatementBuilder} also allows you to set what specific columns you want returned, specify the 'ORDER BY' and 'GROUP BY'
fields, and various other SQL features (LIKE, IN, >, >=, <, <=, <>, IS NULL, @dots{}).  See the javadocs on @code{StatementBuilder}
and @code{Where} classes for more information.  A good SQL reference site can be found at @uref{http://www.w3schools.com/Sql/}.

@c ----------------------------------------------------------------
@node Select Arguments, Foreign Objects, Building Queries, Statement Builder
@section Using Select Arguments

@cindex query arguments
@cindex select arguments
@cindex arguments to queries
@cindex sql ?
The arguments that are used in WHERE operations can be specified directly as value arguments (as in the above examples) or as a
@code{SelectArg} object.  SelectArgs are used to set the value of an argument at a later time -- they generate a SQL '@code{?}'.
For example:

@example
StatementBuilder<Account, String> statementBuilder =
  accountDao.statementBuilder();
Where where = statementBuilder.where();
SelectArg selectArg = new SelectArg();
// define our query as 'name = ?'
where.eq(Account.NAME_FIELD_NAME, selectArg);
// prepare it so it is ready for later query or iterator calls
PreparedStmt<Account, String> preparedStmt =
  statementBuilder.prepareQuery();

// later we can set the select argument and issue the query
selectArg.setValue("foo");
List<Account> accounts = accountDao.query(preparedStmt);
// then we can set the select argument to another
// value and re-run the query
selectArg.setValue("bar");
accounts = accountDao.query(preparedStmt);
@end example

@emph{NOTE:} @code{SelectArg} objects have protection against being used in more than one column name.  You must instantiate a
new object if you want to use a @code{SelectArg} with another column.

@c ----------------------------------------------------------------
@node Foreign Objects, Advanced, Select Arguments, Top
@chapter Foreign Object Fields

@cindex foreign objects
@value{package} supports the concept of "foreign" objects where one or more of the fields correspond to an object
persisted in another table in the same database.  For example, if you had an @code{Order} objects in your database
and each @code{Order} had a corresponding @code{Account} object, then the @code{Order} object would have foreign
@code{Account} field.  With foreign objects, @emph{just} the id field from the @code{Account} is persisted
to the @code{Order} table as the column "@code{account_id}".  For example, the @code{Order} class might look
something like:

@example
@@DatabaseTable(tableName = "orders")
public class Order @{

    @@DatabaseField(generatedId = true)
    private int id;
    
    @@DatabaseField(canNull = false, foreign = true)
    private Account account;
    @dots{}
@}
@end example

When the @code{Order} table was created, something like the following SQL would be generated:

@example
CREATE TABLE `orders`
   (`id` INTEGER AUTO_INCREMENT , `account_id` INTEGER,
    PRIMARY KEY (`id`)); 
@end example

@cindex refreshing foreign objects
@cindex foreign object refreshing
When you query for an order, you will get an @code{Order} object with an account field object that @emph{only} has its id
field set -- all of the fields in the foreign @code{Account} object will have default values (null, 0, false, etc.).  If
you want to use other fields in the @code{Account}, you can use a refresh call to set all of the fields in the
@code{Account} object.  For example:

@example
if (accountDao.refresh(order.getAccount()) != 1) @{
  // error handling @dots{} 
@}
@end example

@emph{NOTE:} Because we use refresh, foreign objects are therefor @emph{required} to have an id field.

@c ----------------------------------------------------------------
@node Advanced, Spring Configuration, Foreign Objects, Top
@chapter Advanced Concepts

@menu
* Spring Configuration::       How to wire @value{package} in Spring.
* Class Configuration::        Alternate ways to configure your classes.
* Database Type Details::      Description of the database specific code.
* Logging::                    How to log messages with @value{package}.
* Use With Android::           Using @value{package} on the Android OS.
@end menu

@c ----------------------------------------------------------------
@node Spring Configuration, Class Configuration, Advanced, Advanced
@section Spring Configuration

@cindex spring framework
@cindex configuration with Spring
@value{package} contains some classes which make it easy to configure the various database classes using
the Spring framework.  For more information about the Spring Framework, see @uref{http://www.springsource.org/}.

@table @code

@item DatabaseTypeFactory

@cindex DatabaseTypeFactory
This factory class is used for Spring injections of the database types to the DAOs and other classes.  Often, the
@code{databaseUrl} parameter is provided by a system property.

@example
<!-- database type factory-bean which is a databaseType -->
<bean id="databaseTypeFactory"
    class="com.j256.ormlite.db.DatabaseTypeFactory"
    init-method="initialize">
    <property name="databaseUrl" value="jdbc:h2:mem:account" />
</bean>
<bean id="databaseType" class="com.j256.ormlite.db.DatabaseType"
    factory-bean="databaseTypeFactory"
    factory-method="getDatabaseType" />
<bean id="driverClassName" class="java.lang.String"
    factory-bean="databaseTypeFactory"
    factory-method="getDriverClassName" />
@end example

@item TableCreator

@cindex auto create tables
@cindex create tables
@cindex auto drop tables
@cindex drop tables
Spring bean that auto-creates any tables that it finds DAOs for if the system property @code{ormlite.auto.create.tables}
has been set to true. It will also auto-drop any tables that were auto-created if the property
@code{ormlite.auto.drop.tables} has been set to true.  This should be used carefully and probably only in tests.

@end table

@cindex spring examples
Here's an example of a full Spring configuration.

@example
<!-- URL used for database, probably should be in properties file -->
<bean id="databaseUrl" class="java.lang.String">
    <!-- we are using the in-memory H2 database in this example -->
    <constructor-arg index="0" value="jdbc:h2:mem:account" />
</bean>
<!-- database type factory -->
<bean id="databaseTypeFactory"
    class="com.j256.ormlite.db.DatabaseTypeFactory"
    init-method="initialize">
    <property name="databaseUrl" value="jdbc:h2:mem:account" />
</bean>
<!-- used to get database-type out of database-type factory -->
<bean id="databaseType" class="com.j256.ormlite.db.DatabaseType"
    factory-bean="databaseTypeFactory"
    factory-method="getDatabaseType" />
<!-- used to get driver-class name out of database-type factory -->
<bean id="driverClassName" class="java.lang.String"
    factory-bean="databaseTypeFactory"
    factory-method="getDriverClassName" />

<!-- datasource used by @value{package} to connect to the database -->
<bean id="connectionSource"
    class="com.j256.ormlite.jdbc.JdbcConnectionSource"
    init-method="initialize">
    <property name="url" ref="databaseUrl" />
    <!-- probably should use system properties for these too -->
    <property name="username" value="foo" />
    <property name="password" value="bar" />
</bean>

<!-- abstract dao that is common to all defined daos -->
<bean id="baseDao" abstract="true" init-method="initialize">
    <property name="connectionSource" ref="connectionSource" />
    <property name="databaseType" ref="databaseType" />
</bean>

<!-- our daos -->
<bean id="accountDao"
    class="com.j256.ormlite.examples.common.AccountDaoImpl"
    parent="baseDao" />
@end example

@c ----------------------------------------------------------------
@node Class Configuration, Database Type Details, Spring Configuration, Advanced
@section Class Configuration

The simplest mechanism for configuring a class to be persisted by @value{package} is to use the @code{@@DatabaseTable}
and @code{@@DatabaseField} annotations.  @xref{Local Annotations}.  However if you do not own the class you are
persisting or there are permission problems with the class, you may want to configure the class using Java code instead.

@cindex configure a class in code
To configure a class in code, you use the @code{DatabaseFieldConfig} and @code{DatabaseTableConfig} objects.
The field config object holds all of the details that are in the @code{@@DatabaseField} annotation as well as
the name of the corresponding field in the object.  The @code{DatabaseTableConfig} object holds the class and the
corresponding list of @code{DatabaseFieldConfig}s.  For example, to configure the @code{Account} object using Java code
you'd do something like the following:

@example
List<DatabaseFieldConfig> fieldConfigs =
    new ArrayList<DatabaseFieldConfig>();
fieldConfigs.add(new DatabaseFieldConfig("name", null, DataType.UNKNOWN,
    null, 0, false, false, true, null, false, null, false));
fieldConfigs.add(new DatabaseFieldConfig("password", null,
    DataType.UNKNOWN, null, 0, false, false, false, null, false, null,
    false));
DatabaseTableConfig<Account> accountTableConfig
    = new DatabaseTableConfig<Account>(Account.class, fieldConfigs);

AccountDaoImpl accountDao = new AccountDaoImpl();
// set our table config on the dao
accountDao.setTableConfig(accountTableConfig);
accountDao.setDatabaseType(databaseType);
accountDao.setConnectionSource(connectionSource);
accountDao.initialize();
@end example

@cindex spring wire a class
See the Javadocs for the @code{DatabaseFieldConfig} class for the fields to pass to the constructor.  You can also
use the no-argument constructor and call the setters for each field.  You use the setters as well when you are
configuring a class using Spring wiring.  Here is the above example in Spring:

@example
<bean id="accountTableConfig"
  class="com.j256.ormlite.table.DatabaseTableConfig">
    <property name="dataClass"
        value="com.j256.ormlite.examples.common.Account" />
    <property name="tableName" value="account" />
    <property name="fieldConfigs">
        <list>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="name" />
                <property name="id" value="true" />
            </bean>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="password" />
                <property name="canBeNull" value="false" />
            </bean>
        </list>
    </property>
</bean>
@end example

@c ----------------------------------------------------------------
@node Database Type Details, Logging, Class Configuration, Advanced
@section Database Specific Code

@cindex database type
@cindex database specific code
@value{package} isolates the database-specific code in the @code{DatabaseType} classes found in
@code{com.j256.ormlite.db}.  Each of the supported databases has a class there which implements the code needed to
handle the unique features of the database (H2DatabaseType, MySqlDatabaseType, etc.).   If you want to help develop
and test against other SQL databases, a externally available server that the author could connect to and test
against would be appreciated.  Please contact the author if your database is not supported or if you want to help.

The following methods are currently used by the system to isolate the database specific behavior in one place.
See the javadocs for the @code{DatabaseType} class for more information.

@table @code

@item getDriverUrlPart

Return the part in the database URI which identifies the particular database.  Usually the
URI is in the form jdbc:XXX:@dots{} where XXX is the driver url part.

@item getDriverClassName

Returns the class name of the driver that may or may not be in the ClassPath depending on what database is
being used.

@item loadDriver

Load the driver class associated with this database so it can wire itself into JDBC.

@item appendColumnArg

Takes a field type and appends the SQL necessary to create the field.  It may also generate arguments
for the end of the table create statement or commands that must run before or after the table create.

@item convertColumnName

Convert and return the column name for table and sequence creation. Often this is necessary to fix case issues.

@item dropColumnArg

Takes a field type and adds all of the commands necessary to drop the column from the database.

@item appendEscapedEntityName

Add a entity-name (table or column name) word to the SQL wrapped in the proper characters to escape it.
This avoids problems with table, column, and sequence-names being reserved words.

@item appendEscapedWord

Add the word to the string builder wrapped in the proper characters to escape it. This avoids problems with
data values being reserved words.

@item generateIdSequenceName

Return the name of an ID sequence based on the tableName and the fieldType of the id.  This is required
by some database types when we have generated ids.

@item getCommentLinePrefix

Return the prefix to put at the front of a SQL line to mark it as a comment.

@item isIdSequenceNeeded

Return true if the database needs a sequence when you insert for generated IDs.  Some databases handle
generated ids internally.

@item getFieldConverter

Return the field converter associated with a particular field type.  This allows the database instance to
convert a field as necessary before it goes to the database.

@item isVarcharFieldWidthSupported

Return true if the database supports the width parameter on VARCHAR fields.

@item isLimitSupported

Return true if the database supports the LIMIT sql command.

@item isLimitAfterSelect

Return true if the LIMIT should be called after SELECT otherwise at the end of the WHERE (the default).

@item appendLimitValue

Add the necessary SQL to limit the results to a certain number.

@item appendSelectNextValFromSequence

Add the SQL necessary to get the next-value from a sequence. This is only necessary if
isIdSequenceNeeded returns true.

@item appendCreateTableSuffix

Append the SQL necessary to properly finish a CREATE TABLE line.

@item isCreateTableReturnsZero

Returns true if a 'CREATE TABLE' statement should return 0. False if > 0.

@item isEntityNamesMustBeUpCase

Returns true if table and field names should be made uppercase.  This is an unfortunate "feature" of Derby and Hsqldb.
See the Javadocs for the class for more information.

@end table

@c ----------------------------------------------------------------
@node Logging, Use With Android, Database Type Details, Advanced
@section @value{package} Logging

@cindex logging information
@value{package} uses a log system which can plug into Apache commons logging, Log4j, or use its own internal log
implementations.  The logger code in @code{com.j256.ormlite.logger} first looks for the
@code{org.apache.commons.logging.LogFactory} class in the classpath -- if found it will use Apache commons logging.
If that class is not found it then looks for @code{org.apache.log4j.Logger} and if found will use Log4j.  Next it
looks for @code{android.util.Log} and if found will use the Android internal logger.  If none of these classes are
available it will use an internal logger -- see @code{LocalLog}.  The logger code also provides simple @{@}
argument expansion like slf4j which means that you can save on toString() calls and @code{StringBuilder} operations
if the log level is not high enough.  This allows me to do something like the following:

@example
private static Logger logger =
  LoggerFactory.getLogger(StatementBuilder.class);
@dots{}
logger.debug("built statement @{@}", statement);
@end example

If you are using log4j (through Apache commons logging or directly), you can use something
like the following as your log4j.properties file to see details about the SQL calls.

@cindex log4j properties file
@example
log4j.rootLogger=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout

# print the date in ISO 8601 format
log4j.appender.stdout.layout.ConversionPattern=%d@{ISO8601@} [%p] %c@{1@} %m%n

# be more verbose with our code
log4j.logger.com.j256.ormlite=DEBUG

# to enable logging of arguments to all of the SQL calls
# uncomment the following line
#log4j.logger.com.j256.ormlite.stmt.mapped.BaseMappedStatement=TRACE
@end example

@cindex logging sql arguments
@cindex sql argument logging
@emph{Notice} that you can uncomment the last line in the above log4j.properties file to log the arguments to the
various SQL calls.  This may expose passwords or other sensitive information in the database so probably should
only be used during debugging and should not be the default.

@c ----------------------------------------------------------------
@node Use With Android, Contributions, Logging, Advanced
@section Using With Android

@cindex use with Android OS
@cindex Android OS support
@cindex droid support

Because of the lack of support for JDBC in Android OS, @value{package} makes direct calls to the Android API if the
@code{SqliteAndroidDatabaseType} is used.  The part of the code is the newest an although tested and used in some
projects, the proper patterns on @emph{how} to use it have not been completely fleshed out.  The hardest part of
writing this documentation is what to say about @emph{how} to use @value{package} on Android OS.  I am not an
Android developer and it seems that we have yet to find the optimal way to use the package in terms of when to
open the database, how to (or if we should) cache conncections, cacheing the DAO objects (which can be expensive to
construct and destroy), etc..  Feedback on this section would be most welcome.

@example
DatabaseType databaseType =
  new SqliteAndroidDatabaseType();
SQLiteOpenHelper openHelper =
  new OrmliteOpenHelper();
ConnectionSource connectionSource =
  new AndroidConnectionSource(openHelper);

// instantiate the dao
AccountDaoImpl accountDao = new AccountDaoImpl();
accountDao.setDatabaseType(databaseType);
accountDao.setConnectionSource(connectionSource);
// _must_ make this call after the setters
accountDao.initialize();

// ...
connectionSource.close();
@end example

Also, there is an @code{AndroidLog} logger which should detect and delegate log calls to the internal Android log
classes.  It should be detected and automatically used to log messages on Android OS.

@c ----------------------------------------------------------------
@node Contributions, Index of Concepts, Use With Android, Top
@chapter Contributions

There are a couple of people that I'd like to thank who helped with the project.

@table @asis

@item Kevin Galligan

Kevin was the impetus and the author of a good bit of the Android compatible code.  He wrote the Android level support classes
and did a ton of beta-testing of it.  Thanks much Kevin.  See @uref{http://www.kagii.com/}.

@item Jim Gloor

Jim was my JDBC Java guru at my current company.  Thanks much for his code samples that started this effort.

@item Robert Adamsky

Robert was one of the early developers at my current company who laid out the entire DAO and hibernate class hierarchy.  The
@code{DAO} interface and the @code{BaseDaoImpl} where in some part modeled after his code.  Thanks dude.  

@end table

Thanks much to them all.
@c ----------------------------------------------------------------
@node Index of Concepts,, Contributions, Top
@unnumbered Index of Concepts

@printindex cp
@contents

@bye
