\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename ormlite.info
@settitle ORM Lite Documentation
@setchapternewpage odd
@headings double
@c %**end of header

@dircategory Libraries
@direntry
* ORMLite: (orm lite).			Lightweight ORM package.
@end direntry

@c ----------------------------------------------------------------
@c This file has the new style title page commands.
@c Also, it uses `@@include' files instead of `@@input' files.

@c Run using special version of `texinfo.tex'.

@c Also, run `makeinfo' rather than `texinfo-format-buffer'.
@c ----------------------------------------------------------------

@c ----------------------------------------------------------------
@set ormlite_version 4.12
@set ormlite_year 2011
@set ormlite_date February @value{ormlite_year}
@set package ORMLite
@c ----------------------------------------------------------------

@ifinfo
This file is an introduction to the ORM Lite package which is a simple Object Relationship Mapping package.

Copyright @value{ormlite_year} by Gray Watson.

Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice
and this permission notice are preserved on all copies.
@end ifinfo

@titlepage
@title ORM Lite Package
@subtitle Version @value{ormlite_version}
@subtitle @value{ormlite_date}
@author Gray Watson

@page
Copyright 2010 to @value{ormlite_year} by Gray Watson.

Published by Gray Watson

Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice
and this permission notice are preserved on all copies.

@end titlepage

@c ----------------------------------------------------------------
@node Top, Getting Started, (dir), (dir)
@top @value{package}

Version @value{ormlite_version} -- @value{ormlite_date}

@cindex introduction
@cindex author
@cindex object relational mapping
@cindex hibernate
@cindex ibatis
@value{package} provides a lightweight Object Relational Mapping between Java classes and SQL databases -- see
@uref{http://en.wikipedia.org/wiki/Object-relational_mapping}.  There are certainly more mature ORMs which
provide this functionality including Hibernate and iBatis.  However, the author wanted a simple yet powerful
wrapper around the JDBC functions and Hibernate and iBatis are significantly more complicated with many
dependencies.

@cindex databases supported
@cindex supported databases
@value{package} supports JDBC connections to MySQL, Postgres, Microsoft SQL Server, H2, Derby, HSQLDB, and
Sqlite and can be extended to additional ones relatively easily.  @value{package} also supports native database
calls on Android OS.  There are also initial implementations for DB2 and Oracle although the author needs
access to each of these database types to tune the support.  Contact the author if your database is not supported.

To get started quickly with @value{package}, see the examples section of the document which has various
working code packages and Android applications.  @xref{Examples}.
@ifhtml
There is also a PDF version of this documentation -- see @uref{http://ormlite.com/docs/ormlite.pdf}.
@end ifhtml
@iftex
There is also a HTML version of this documentation -- see @uref{http://ormlite.com/docs/ormlite.html}.
@end iftex

Gray Watson @uref{http://256.com/gray/}

@menu
* Getting Started::             Getting started with @value{package}.
* Using::                       More details on how to use the system.
* Statement Builder::           How to use the custom statement builder.
* Use With Android::            Using with the Android OS.
* Advanced::                    Advanced concepts with @value{package}.
* How to Upgrade::              Upgrading from a previous version.
* Examples::                    Usage examples to help you get started.
* Contributions::               Contributions from others who helped.
* License::                     License for the project.
* Index of Concepts::           Index of concepts in the manual.
@end menu

@c ----------------------------------------------------------------
@node Getting Started, Downloading, Top, Top
@chapter Getting Started

@menu
* Downloading ::                Downloading the @value{package} jar.
* Starting Class::              Configuring a class to persist.
* Starting DAO::                Configuring a Data Access Object.
* Starting Code::               Code example on how its works.
@end menu

@c ----------------------------------------------------------------
@node Downloading, Starting Class, Getting Started, Getting Started
@section Downloading @value{package} Jar

To get started with @value{package}, you will need to download the jar files.  They are available on the central maven repository
(@uref{http://repo1.maven.org/maven2/com/j256/ormlite/}) or from Sourceforge (@uref{http://sourceforge.net/projects/ormlite/files/}).
See the @uref{http://ormlite.com/} home page for the most up-to-date repositories. 

Users that are connecting to SQL databases via JDBC connections will need to download the @code{ormlite-jdbc-@value{ormlite_version}.jar}
and @code{ormlite-core-@value{ormlite_version}.jar} files.  For use with Android applications, you should download the
@code{ormlite-android-@value{ormlite_version}.jar} and @code{ormlite-core-@value{ormlite_version}.jar} files instead.  For either JDBC or
Android you will also need the ormlite-core release which has the @value{package} backend implementations.  @value{package} does not have
any required external dependencies although there are some other packages that you may want to use.  @xref{Dependencies}.  The code
works with Java 5 or later.

@c ----------------------------------------------------------------
@node Starting Class, Starting DAO, Downloading, Getting Started
@section Configuring a Class

The following is an example class that is configured to be persisted to a database using @value{package} annotations.  The @code{@@DatabaseTable}
annotation configures the Account class to be persisted to the database table named @code{accounts}. The @code{@@DatabaseField} annotations map
the fields on the Account to the database columns with the same names.

The name field is configured as the primary key for the database table by using the @code{id = true} annotation field.  Also, notice that a
no-argument constructor is needed so the object can be returned by a query. For more information (JPA annotations and other ways to configure
classes) see the class setup information later in the manual.  @xref{Class Setup}.

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
    
    @@DatabaseField(id = true)
    private String name;
    @@DatabaseField
    private String password;
    
    public Account() @{
        // @value{package} needs a no-arg constructor 
    @}
    public Account(String name, String password) @{
        this.name = name;
        this.password = password;
    @}
    public String getName() @{
        return name;
    @}
    public String getPassword() @{
        return password;
    @}
@}
@end example

@c ----------------------------------------------------------------
@node Starting DAO, Starting Code, Starting Class, Getting Started
@section Configuring a DAO

A typical Java pattern is to isolate the database operations in Data Access Objects (DAO) classes. Each DAO provides create, delete,
update, etc. type of functionality and specializes in the handling a particular persisted class.  To set up a DAO, you will need a DAO
interface and an implementation class.  @value{package} provides a base DAO interface and a base implementation class. The following is
an example DAO interface corresponding to the Account class from the previous section of the manual:

@example
/** Account DAO which has a String id (Account.name) */
public interface AccountDao extends Dao<Account,String> @{
    // empty wrapper, you can add additional DAO methods here
@}
@end example

The following is the example implementation class:

@example
/** JDBC implementation of the AccountDao interface. */
public class AccountDaoImpl extends BaseDaoImpl<Account,String>
 implements AccountDao @{
    public AccountDaoImpl(ConnectionSource connectionSource)
      throws SQLException @{
        super(connectionSource, Account.class);
    @}
@}
@end example

You are not @emph{required} to create a DAO class for every one of your persisted objects.  You can use the
@code{createDao} static method on the @code{BaseDaoImpl} class to create a DAO class without having to define
one.  For example:

@example
Dao<Account, String> accountDao =
  BaseDaoImpl.createDao(connectionSource, Account.class);
Dao<Order, Integer> orderDao =
  BaseDaoImpl.createDao(connectionSource, Order.class);
@end example

More information about setting up the DAOs is available later in the manual. @xref{DAO Setup}.

@c ----------------------------------------------------------------
@node Starting Code, Using, Starting DAO, Getting Started
@section Code Example

The code in this section demonstrates how to use the classes presented in the previous two sections. The code uses the native Java H2 database to
create the in-memory test databases. You will need to download and add the H2 jar file to your classpath if you want to run the example as-is.  See
the H2 home page: @uref{http://www.h2database.com/html/download.html}.  @emph{NOTE:} Android users should see the Android specific documentation
later in the manual. @xref{Use With Android}.

The code performs the following steps.

@itemize @bullet
@item It creates a connection source which handles connections to the database.
@item It instantiates a dao for the Account object.
@item The @code{accounts} database table is created. This step is not needed if the table already exists.
@end itemize

@example
public class AccountApp @{

    public static void main(String[] args) throws Exception @{

        // this uses h2 by default but change to match your database
        String databaseUrl = "jdbc:h2:mem:account";
        // create a connection source to our database
        ConnectionSource connectionSource =
            new JdbcConnectionSource(databaseUrl);

        // instantiate the dao
        Dao<Account, String> accountDao =
            BaseDaoImpl.createDao(connectionSource, Account.class);

        // if you need to create the 'accounts' table make this call
        TableUtils.createTable(connectionSource, Account.class);
 @end example

Once we have configured our database objects, we can use them to create an Account, persist it to the database, and query for it from
the database by its ID:

@example
        // create an instance of Account
        Account account = new Account();
        account.setName("Jim Coakley");

        // persist the account object to the database
        // it should return 1 for the 1 row inserted
        if (accountDao.create(account) != 1) @{
            throw new Exception("Failure adding account");
        @}
		
        // retrieve the account from the database by its id field (name)
        Account account2 = accountDao.queryForId("Jim Coakley");
        System.out.println("Account: " + account2.getName());

        // close the connection source
        connectionSource.close();
    @}
@}
@end example

For more examples including working code and Android application projects see @pxref{Examples}.

You should be able to get started using @value{package} by this point. To understand more of the functionality available with @value{package},
continue on with the next section.  @xref{Using}.

@c ----------------------------------------------------------------
@node Using, Class Setup, Starting Code, Top
@chapter How to Use

This chapter goes into more detail about how to use @value{package}.

@menu
* Class Setup::                 How to setup your classes to be persisted.
* Persisted Types::             Data types that can be persisted.
* Connection Source::           Setting up connections to databases.
* DAO Setup::                   How to configure the Data Access Objects.
* Database Notes::              Support databases and associated notes.
* Complete Wiring::             Tying all of the wiring together.
* DAO Usage::                   Using the Data Access Objects.
* Identity Columns::            How identity fields and columns work.
* Creating Indexes::            How to create indexes on fields.
* Raw Statements::              Issuing raw database statements.
* Foreign Objects::             Fields that represent foreign objects.
@end menu

@c ----------------------------------------------------------------
@node Class Setup, Local Annotations, Using, Using
@section Setting Up Your Classes

To setup your classes to be persisted you need to do the following things:

@enumerate
@item Add the @@DatabaseTable annotation to the top of each class.  You can also use @@Entity.
@item Add the @@DatabaseField annotation right before each field to be persisted.  You can also use @@Column and others.
@item Add a no-argument constructor to each class with at least package visibility.
@end enumerate

@menu
* Local Annotations::                Adding the annotations to your classes.
* Javax Persistence Annotations::    Using javax.persistence annotations instead.
* No Arg Constructor::               A no-argument-constructor is also required.
@end menu

@c ----------------------------------------------------------------
@node Local Annotations, Javax Persistence Annotations, Class Setup, Class Setup
@subsection Adding @value{package} Annotations

@cindex annotations
@cindex java annotations
@cindex @@DatabaseTable
@cindex DatabaseTable annotation
Annotations are special code markers have have been available in Java since version 5 that provide meta information
about classes, methods, or fields.  To specify what classes and fields to store in the database, @value{package}
supports either its own annotations (@code{@@DatabaseTable} and @code{@@DatabaseField}) or the more standard
annotations from the @code{javax.persistence} package.  @xref{Javax Persistence Annotations}.   Annotations are the
easiest way to configure your classes but you can also configure the class using Java code or Spring XML.
@xref{Class Configuration}.

With @value{package} annotations, for each of the Java classes that you would like to persist to your SQL database, you
will need to add the @code{@@DatabaseTable} annotation right above the @code{public class} line.  Each class marked with
one of these annotations will be persisted into its own database table.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@DatabaseTable} annotations can have an optional @code{tableName} argument which specifies the name of the table
that corresponds to the class.   If not specified, the class name, with normalized case, is used by default.  With the above example
each @code{Account} object will be persisted as a row in the @code{accounts} table in the database.  If the @code{tableName}
was not specified, the @code{account} table would be used instead.

@cindex @@DatabaseField
@cindex DatabaseField annotation
Additionally, for each of the classes, you will need to add a @code{@@DatabaseField} annotation to each of the @emph{fields}
in the class that are to be persisted to the database.  Each field is persisted as a column of a database row.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{

    @@DatabaseField(id = true)
    private String name;

    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}
@end example

In the above example, each row in the @code{accounts} table has 2 columns:

@itemize @bullet
@item the @code{name} column which is a string and also is the database identity (id) of the row
@item the @code{password} column, also a string which can not be null
@end itemize 

The @@DatabaseField annotation can have the following fields:

@table @code

@cindex column name
@cindex name of database column
@anchor{columnName}
@item columnName

String name of the column in the database that will hold this field. If not set then the field name, with normalized case,
is used instead.

@cindex field type
@cindex jdbc type
@cindex SQL type
@item dataType

The type of the field as the DataType class.  Usually the type is taken from Java class of the field and does not need
to be specified.  This corresponds to the SQL type.  @xref{Persisted Types}.

@cindex default value
@item defaultValue

String default value of the field when we are creating a new row in the table.  Default is none.

@cindex field width
@cindex width of field
@cindex length of field
@item width

Integer width of string fields.  Some databases do not support this unfortunately.  Default for those that do is 255.

@cindex can be null
@cindex null value allowed
@item canBeNull

Boolean whether the field can be assigned to null value. Default is true.  If set to false then you must provide a value
for this field on every object inserted into the database.

@cindex id field
@cindex key field
@cindex primary key field
@item id

Boolean whether the field is the id field or not. Default is false. Only one field can have this set in a class. Id fields
uniquely identity a row and are required if you want to use the query, update, refresh, and delete by ID methods. Only one
of this, @code{generatedId}, and @code{generatedIdSequence} can be specified.  @xref{Id Column}.

@cindex generated id
@cindex auto-generated id
@item generatedId

Boolean whether the field is an auto-generated id field. Default is false.  Only one field can have this set in a class.
This tells the database to auto-generate a corresponding id for every row inserted.  When an object with a generated-id
is created using the @code{Dao.create()} method, the database will generate an id for the row which will be returned and
set in the object by the create method.  Some databases require sequences for generated ids in which case the sequence
name will be auto-generated. To specify the name of the sequence use @code{generatedIdSequence}. Only one of this,
@code{id}, and @code{generatedIdSequence} can be specified.  @xref{GeneratedId Column}.

@cindex generated id sequence
@cindex database sequences
@cindex sequences
@item generatedIdSequence

String name of the sequence number to be used to generate this value.  Same as @code{generatedId} but you can specify the
sequence name to use.  Default is none. Only one field can have this set in a class. This is only necessary for databases
which require sequences for generated ids.  If you use generatedId instead then the code will auto-generate a sequence name.
Only one of this, @code{id}, and @code{generatedId} can be specified.  @xref{GeneratedIdSequence Column}.

@cindex foreign objects
@cindex remote objects
@item foreign

@cindex refreshing foreign objects
Boolean setting which identifies this field as corresponding to another class that is also stored in the database.
Default is false.  The field must not be a primitive type.  The other class must have an id field (either @code{id},
@code{generatedId}, or @code{generatedIdSequence}) which will be stored in this table. When an object is returned
from a query call, any foreign objects will @emph{just} have the id field set.  @xref{Foreign Objects}.

@cindex useGetSet
@cindex get and set method usage
@cindex using get and set methods
@cindex field access using getters and setters 
@item useGetSet

Boolean that says that the field should be accessed with get and set methods.  Default is false which instead uses
direct field access via Java reflection.  This may be necessary if the object you are storing has
protections around it.

@emph{NOTE:} The name of the get method @emph{must} match getXxx() where Xxx is the name of the field with the first
letter capitalized. The get @emph{must} return a class which matches the field's exactly. The set method @emph{must}
match setXxx(), have a single argument whose class matches the field's exactly, and return void.  For example:

@example
@@DatabaseField(useGetSet = true)
private Integer orderCount;

public Integer getOrderCount() @{
  return orderCount;
@}

public void setOrderCount(Integer orderCount) @{
  this.orderCount = orderCount;
@}
@end example

@cindex unknownEnumName
@cindex enumerated name unknown
@anchor{unknownEnumName}
@item unknownEnumName

If the field is a Java enumerated type then you can specify the name of a enumerated value which will be used if the
value of a database row is not found in the enumerated type.  If this is not specified and a database row @emph{does}
contain an unknown name or ordinal value then a @code{SQLException} is thrown when the row is being read from the database.
This is useful to handle backwards compatibility when handling out-of-date database values as well as forwards
compatibility if old software is accessing up-to-date data or if you have to roll a release back.

@cindex throwIfNull
@cindex primitive null values
@cindex null values and primitives
@item throwIfNull

Boolean that tells @value{package} to throw an exception if it sees a null value in a database row and is trying to store
it in a primitive field.  By default it is false.  If it is false and the database field is null, then the value of the
primitive will be set to 0 (false, null, etc.).  This can only be used on a primitive field.

@item persisted

Set this to be false (default true) to not store this field in the database. This is useful if you want to have
the annotation on all of your fields but turn off the writing of some of them to the database.

@cindex parse format
@cindex format, field
@item format

This allows you to specify format information of a particular field.  Right now only the Date fields support it when
a default value is being converted or if you are using the @code{DATE_STRING} type.

@cindex unique constraint
@cindex constraint, unique
@item unique

Adds a constraint to the field that it has to be unique across all rows in the table.  This allows you to have a
unique field in the table even though it is not the id field.  For example, you might have an Account class which
has a generated account-id but you also want the email address to be unique across all Accounts.  You can also
use the uniqueIndexName to create an index for this field.  For unique constraints across multiple fields, see the
@code{uniqueIndex} below. 

@cindex index creation
@cindex creating an index
@cindex field indexes
@anchor{index}
@item index

Boolean value (default false) to have the database add an index for this field. This will create an index with the name columnName with
a "_idx" suffix. To specify a specific name of the index or to index multiple fields, use the indexName field.

@cindex unique index creation
@item uniqueIndex

Boolean value (default false) to have the database add a unique index for this field. Same as index but this will ensure that all of
the values in the index are unique.  If you just want to make sure of unique-ness then you can use the @code{unique} field instead.

@cindex naming an index
@item indexName

String value (default none) to have the database add an index for this field with this name. You do not need to specify the index boolean
as well. To index multiple fields together in one index, each of the fields should have the same indexName value.

@cindex naming a unique index
@item uniqueIndexName

String value (default none) to have the database add a unique index for this field with this name. Same as index but this will ensure that all of
the values in the index are unique.  For example, this means that you can insert @code{("pittsburgh", "pa")} and @code{("harrisburg", "pa")} and
@code{("pittsburgh", "tx")} but not another @code{("pittsburgh", "pa")}.

@cindex foreign object, auto refresh
@cindex auto refresh foreign objects
@anchor{foreignAutoRefresh}
@item foreignAutoRefresh

Set this to be true (default false) to have a foreign field automagically refreshed when an object is queried.	This will @emph{not} automagically
create the foreign object but when the object is queried, a separate database call will be made to load of the fields of the foreign object via an
internal DAO. The default is to just have the ID field in the object retrieved and for the caller to call refresh on the correct DAO.

@emph{NOTE:} This will create another DAO object internally so low memory devices may want to call refresh by hand.

@end table

@c ----------------------------------------------------------------
@node Javax Persistence Annotations, No Arg Constructor, Local Annotations, Class Setup
@subsection Using javax.persistence Annotations

@cindex JPA
@cindex javax.persistence
@cindex @@Entity
@cindex Entity annotation
Instead of using the @value{package} annotations (@pxref{Local Annotations}), you can use the more standard
JPA annotations from the @code{javax.persistence} package.  In place of the @code{@@DatabaseTable} annotation, you can
use the @code{javax.persistence} @code{@@Entity} annotation.  For example:

@example
@@Entity(name = "accounts")
public class Account @{
@dots{}
@end example

The @code{@@Entity} annotations can have an optional @code{name} argument which specifies the table name.   If not
specified, the class name with normalized case is used by default.

@cindex @@Column
@cindex @@Id
@cindex @@GeneratedValue
@cindex Column annotation
@cindex Id annotation
@cindex GeneratedValue annotation
@cindex @@OneToOne
@cindex OneToOne annotation
@cindex @@ManyToOne
@cindex ManyToOne annotation
Instead of using the @code{@@DatabaseField} annotation on each of the fields, you can use the @code{javax.persistence}
annotations: @code{@@Column}, @code{@@Id}, @code{@@GeneratedValue}, @code{@@OneToOne}, and @code{@@ManyToOne}. For example:

@example
@@Entity(name = "accounts")
public class Account @{

    @@Id
    private String name;

    @@Column(nullable = false)
    private String password;
    @dots{}
@end example

The following @code{javax.persistence} annotations and fields are supported:

@table @code

@item @@Column

Specifies the field to be persisted to the database.  You can also just specify the @code{@@Id} annotation.  The
following annotation fields are supported, the rest are ignored.

@table @code

@item name

Used to specify the name of the associated database column.  If not provided then the field name is taken.

@cindex field width
@cindex width of field
@cindex length of field
@item length

Specifies the length (or width) of the database field.  Maybe only applicable for Strings and only supported by
certain database types.  Default for those that do is 255.   Same as the @code{width} field in the
@code{@@DatabaseField} annotation.

@cindex can be null
@cindex null value allowed
@item nullable

Set to true to have a field not be able to be inserted into the database with a null value.  Same as the
@code{canBeNull} field in the @code{@@DatabaseField} annotation.

@cindex unique constraint
@cindex constraint, unique
@item unique

Adds a constraint to the field that it has to be unique across all rows in the table.  Same as the
@code{unique} field in the @code{@@DatabaseField} annotation.

@end table

@cindex id field
@cindex key field
@cindex primary key field
@item @@Id

Used to specify a field to be persisted to the database as a primary row-id.  If you want to have the id be
auto-generated, you will need to also specify the @code{@@GeneratedValue} annotation.

@item @@GeneratedValue

Used to define an id field as having a auto-generated value.  This is only used in addition to the @code{@@Id}
annotation.  See the @code{generatedId} field in the @code{@@DatabaseField} annotation for more details.

@item @@OneToOne or @@ManyToOne

Fields with these annotations are assumed to be foreign fields.  @xref{Foreign Objects}.  @value{package} does
@emph{not} enforce the many or one relationship nor does it use any of the annotation fields.  It just uses the
existence of either of these annotations to indicate that it is a foreign object.

@end table

If the @code{@@Column} annotation is used on a field that has a unknown type then it is assumed to be a
Serializable field and the object should implement @code{java.io.Serializable}.  @xref{datatype serializable}.

@c ----------------------------------------------------------------
@node No Arg Constructor, Persisted Types, Javax Persistence Annotations, Class Setup
@subsection Adding a No-Argument-Constructor

@cindex no argument constructor
@cindex constructor with no args
After you have added the class and field annotations, you will also need to add a no-argument constructor with
@emph{at least} package visibility.  When an object is returned from a query, @value{package} constructs the object
using Java reflection and a constructor needs to be called.

@example
Account() @{
  	// all persisted classes must define a no-arg constructor
  	// with at least package visibility
@}
@end example

So your final example Account class with annotations and constructor would look like:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
	
    @@DatabaseField(id = true)
    private String name;
    
    @@DatabaseField(canBeNull = false)
    private String password;
    @dots{}

    Account() @{
        // all persisted classes must define a no-arg constructor
        // with at least package visibility
    @}
    @dots{}
@}
@end example

@c ----------------------------------------------------------------
@node Persisted Types, Connection Source, No Arg Constructor, Using
@section Persisted Data Types

@cindex persisted types
@cindex types that are persisted
The following Java types can be persisted to the database by @value{package}.  Database specific code
helps to translate between the SQL types and the database specific handling of those types.
@xref{Database Type Details}.

@table @code

@cindex String
@cindex VARCHAR string
@anchor{datatype string}
@item String (DataType.STRING)

Persisted as SQL type VARCHAR.  

@cindex boolean
@anchor{datatype boolean}
@item boolean or Boolean (DataType.BOOLEAN or DataType.BOOLEAN_OBJ)

Persisted as SQL type BOOLEAN.

@cindex Date
@cindex java date
@anchor{datatype date}
@item java.util.Date (DataType.DATE)

Persisted as SQL type TIMESTAMP.  This type automatically uses an internal @code{?} argument because the string format of it
is unreliable to match the database format.  @xref{Select Arguments}.  See also @code{DATE_LONG} and @code{DATE_STRING}.

@emph{NOTE:} This is a different class from @code{java.sql.Date}.

@emph{NOTE:} Certain databases only provide seconds resolution so the milliseconds will be 0.

@cindex java long date
@anchor{datatype date long}
@item java.util.Date (DataType.DATE_LONG)

You can also specify the @code{dataType} field to the @code{@@DatabaseField} annotation as a @code{DataType.DATE_LONG}
in which case the milliseconds value of the @code{Date} will be stored as an LONG.  See also @code{DATE} and @code{DATE_STRING}.

@emph{NOTE:} This is a different class from @code{java.sql.Date}.

@emph{NOTE:} Certain databases only provide seconds resolution so the milliseconds will be 0.

@cindex java string date
@cindex date formats
@anchor{datatype date string}
@item java.util.Date (DATE_STRING)

You can also specify the @code{dataType} field to the @code{@@DatabaseField} annotation as a @code{DataType.DATE_STRING}
in which case the date will be stored as a string in @code{yyyy-MM-dd HH:mm:ss.SSSSSS} format.  You can use the
@code{format} field in @code{DatabaseField} to set the date to another format.  See also @code{DATE} and @code{DATE_LONG}.

@emph{NOTE:} This is a different class from @code{java.sql.Date}.

@emph{NOTE:} Certain databases only provide seconds resolution so the milliseconds will be 0.

@emph{NOTE:} Because of reentrant issues with @code{SimpleDateFormat}, synchronization is done
every time a DATE_STRING date is converted to/from the database.

@cindex byte
@anchor{datatype byte}
@item byte or Byte (DataType.BYTE or DataType.BYTE_OBJ)

Persisted as SQL type TINYINT.

@cindex short
@anchor{datatype short}
@item short or Short (DataType.SHORT or DataType.SHORT_OBJ)

Persisted as SQL type SMALLINT.

@cindex int
@anchor{datatype int}
@item int or Integer (DataType.INTEGER or DataType.INTEGER_OBJ)

Persisted as SQL type INTEGER.

@cindex long
@anchor{datatype long}
@item long or Long (DataType.LONG or DataType.LONG_OBJ)

Persisted as SQL type BIGINT.

@cindex float
@anchor{datatype float}
@item float or Float (DataType.FLOAT or DataType.FLOAT_OBJ)

Persisted as SQL type FLOAT.

@cindex double
@anchor{datatype double}
@item double or Double (DataType.DOUBLE or DataType.DOUBLE_OBJ)

Persisted as SQL type DOUBLE.

@cindex Serializable
@cindex persist objects
@anchor{datatype serializable}
@item Serializable (DataType.SERIALIZABLE)

Persisted as SQL type VARBINARY.  This is a special type that serializes an object as a sequence of bytes
and then deserializes it on the way back.  The field must be an object that implements the @code{java.io.Serializable}
interface.  Depending on the database type, there will be limits to the size of the object that can be stored.

Some databases place restrictions on this field type that it cannot be the id column in a class.  Other databases do
not allow you to query on this type of field at all.  If your database does support it, you may also have to use a
Select Argument to query for this type.  @xref{Select Arguments}.  

@cindex Enum string
@cindex enumerated types
@anchor{datatype enum string}
@item enum or Enum (DataType.ENUM_STRING)

Persisted by default as the enumerated value's string @emph{name} as a VARCHAR type.  The string name is the
default (and recommended over ENUM_INTEGER) because it allows you to add additional enums anywhere in the list
without worrying about having to convert data later.

@cindex unknownEnumName
You can also also specify an @emph{unknownEnumName} name with the @code{@@DatabaseField} annotation which will be
used if an unknown value is found in the database. @xref{unknownEnumName}. 

@cindex Enum integer
@cindex enumerated types
@anchor{datatype enum integer}
@item enum or Enum (DataType.ENUM_INTEGER)

You specify the @code{dataType} field (from the @code{@@DatabaseField} annotation) as a @code{DataType.ENUM_INTEGER} in
which case the @code{ordinal} of the enum value will be stored as an INTEGER.  The name (ENUM_STRING) is the default (and
recommended) because it allows you to add additional enums anywhere in the list without worrying about having to convert
data later.  If you insert (or remove) an enum from the list that is being stored as a number, then old data will be
un-persisted incorrectly.

@cindex unknownEnumName
You can also also specify an @emph{unknownEnumName} name with the @code{@@DatabaseField} annotation which will be
used if an unknown value is found in the database. @xref{unknownEnumName}. 

@end table

@emph{NOTE:} @value{package} also supports the concept of foreign objects where the id of another object is
stored in the database.  @xref{Foreign Objects}.

@c ----------------------------------------------------------------
@node Connection Source, DAO Setup, Persisted Types, Using
@section Connection Sources

@emph{NOTE:} With regards to connection sources, Android users should see the Android specific documentation later in the manual.
@xref{Use With Android}.

@cindex data source
@cindex connection source
@cindex database connection
@cindex simple connection source
To use the database and the DAO objects, you will need to configure what JDBC calls a @code{DataSource} (see the
@code{javax.sql.DataSource} class) and what @value{package} calls a @code{ConnectionSource}.  A @code{ConnectionSource} is
a factory for connections to the physical SQL database.  Here is a code example that creates a simple, single-connection
source.

@cindex JdbcConnectionSource
@cindex connection source, simple
@example
// single connection source example for a database URI
ConnectionSource connectionSource =
  new JdbcConnectionSource("jdbc:h2:mem:account");
@end example

@cindex pooled connection source
@cindex connection pooling
The package also includes the class @code{JdbcPooledConnectionSource} which is a relatively simple implementation of a
pooled connection source.  As database connections are released, instead of being closed they are added to an internal
list so they can be reallocated at a later time.  New connections are created on demand only if there are no dormant
connections that can be reused.  @code{JdbcPooledConnectionSource} is also synchronized and can be used my multiple
threads.  It has settings for the maximum number of free connections before they are closed as well as a maximum age
before a connection is closed.

@example
// single connection source example
JdbcPooledConnectionSource connectionSource =
  new JdbcPooledConnectionSource("jdbc:h2:mem:account");
// only keep the connections open for 5 minutes
connectionSource.setMaxConnectionAgeMillis(5 * 60 * 1000);
@end example

@cindex other data sources
@cindex external data sources
@cindex use with external data source
@cindex DataSourceConnectionSource
There are many other, external data sources that can be used instead, including more robust and probably higher-performance
pooled connection managers. You can instantiate your own directly and wrap it in the @code{DataSourceConnectionSource} class
which delegates to it.

@cindex BasicDataSource
@example
// basic Apache data source
BasicDataSource dataSource = new BasicDataSource();
dataSource.setUrl("jdbc:h2:mem:account");
// we wrap it in the DataSourceConnectionSource
ConnectionSource connectionSource = 
  new DataSourceConnectionSource(dataSource);
@end example

@cindex close data source
@cindex destroy data source
When you are done with your @code{ConnectionSource}, you will want to call a @code{close()} method to close any
underlying connections.  Something like the following pattern is recommended.

@example
JdbcConnectionSource connectionSource =
    new JdbcPooledConnectionSource("jdbc:h2:mem:account");
try @{
    // work with the data-source and DAOs
    @dots{}
@} finally @{
    connectionSource.close();
@}
@end example

Unfortunately, the @code{DataSource} interface does not have a close method so if you are using the @code{DataSourceConnectionSource}
you will have to close the underlying @code{DataSource} by hand -- the @code{close()} method on the @code{DataSourceConnectionSource}
does @emph{nothing}.

@c ----------------------------------------------------------------
@node DAO Setup, Database Notes, Connection Source, Using
@section Setting Up the DAOs

@cindex DAO
@cindex data access object
@cindex id column
@cindex Dao interface
Once you have annotated your classes and defined your @code{ConnectionSource} you will need to create the Data Access Object
(DAO) class(es).  The pattern that we recommend is to define an interface which extends the @code{Dao} interface and will be
used in the code.  The interface isn't required but it is a good pattern so your code is less tied to JDBC for persistence.
Each DAO has two generic parameters: the class we are persisting with the DAO, and the class of the ID-column that will be
used to identify a specific database row.  If you class does not have an ID field, you can put @code{Object} or @code{Void}
as the 2nd argument.  For example, in the above @code{Account} class, the "name" field is the ID column (id = true)
so the ID class is @code{String}.  Example:

@example
/** Account DAO which has a String id (Account.name) */
public interface AccountDao extends Dao<Account, String> @{
    // empty wrapper, you can add additional DAO methods here
@}
@end example

Here's the example implementation of this interface.

@cindex jdbc dao implementation
@example
/** JDBC implementation of the AccountDao interface. */
public class AccountDaoImpl extends BaseDaoImpl<Account, String>
  implements AccountDao @{
    public AccountDaoImpl(ConnectionSource connectionSource)
      throws SQLException @{
        super(connectionSource, Account.class);
    @}
@}
@end example

That's all you need to define your DAO classes.  You are free to add more methods to your DAO interfaces and
implementations if there are specific operations that are needed and not provided by the Dao base classes.
More on how to use these DAOs later. @xref{DAO Usage}.

@cindex createDao method
You are not @emph{required} to create a DAO class for every one of your persisted objects. You can use the @code{createDao}
static method on the @code{BaseDaoImpl} class to create a DAO class without having to define one.  For example:

@example
Dao<Account, String> accountDao =
  BaseDaoImpl.createDao(connectionSource, Account.class);
Dao<Order, Integer> orderDao =
  BaseDaoImpl.createDao(connectionSource, Order.class);
@end example

@c ----------------------------------------------------------------
@node Database Notes, Complete Wiring, DAO Setup, Using
@section Supported Databases

@value{package} supports the following database flavors.  Some of them have some specific documentation that needs to be obeyed.

@table @asis

@cindex MySQL database
@item MySQL

Tables are created in MySQL with the InnoDB engine by default using @code{CREATE TABLE ... ENGINE=InnoDB}.  If you want to use
another engine, you can instantiate the @code{MysqlDatabaseType} directly and use the @code{setCreateTableSuffix()} method to use
the default or another engine.  Also, MySQL does some funky stuff with the last-modification time if a @code{Date} is defined as a
@code{TIMESTAMP} so @code{DATETIME} was used instead.

@cindex Postgres database
@item Postgres

No special instructions.

@cindex Microsoft SQL Server database
@cindex SQL Server database
@item Microsoft SQL Server

No special instructions.

@cindex H2 database
@item H2

No special instructions.  I use this database for all of my internal testing with in-memory and small on-disk databases.

@cindex Derby database
@item Derby

There are two drivers for Derby: one embedded and one client/server.  @value{package} makes an attempt to detect the right driver but you
may have to set the right database type on your ConnectionSource directly if it doesn't.  @xref{Database Type Details}.

@cindex HSQLDB database
@item HSQLDB

No special instructions.

@cindex Xerial SQLite driver
@cindex Zentus SQLite driver
@cindex SQLite database
@item SQLite

There are multiple SQLite drivers out there.  Make sure you use the Xerial one (@uref{http://www.xerial.org/trac/Xerial/wiki/SQLiteJDBC})
and not the Zentus one (@uref{http://www.zentus.com/sqlitejdbc/}) which does not support generated ids.

@cindex Android SQLite database
@item Android SQLite

Android's SQLite database is accessed through direct calls to the Android database API methods.

@cindex DB2 database
@item DB2

I do not have access to an DB2 database so I cannot run any tests to make sure that my support for it works well.  Please contact me
if you have an DB2 database that I can develop against.

@cindex Oracle database
@item Oracle

I do not have access to an Oracle database so I cannot run any tests to make sure that my support for it works well.  Please contact me
if you have an Oracle database that I can develop against.

@end table

@cindex database not supported
Please contact the author if your database is not supported.

@c ----------------------------------------------------------------
@node Complete Wiring, DAO Usage, Database Notes, Using
@section Tying It All Together

@cindex usage example
So you have annotated the objects to be persisted, added the no-arg constructor, created your @code{ConnectionSource}, and defined
your DAO classes.  You are ready to start persisting and querying your database objects.  The following code ties it all together:

@example
// h2 by default but change to match your database
String databaseUrl = "jdbc:h2:mem:account";
JdbcConnectionSource connectionSource =
  new JdbcConnectionSource(databaseUrl);

// instantiate the dao with the connection source
AccountDaoImpl accountDao = new AccountDaoImpl(connectionSource);

// if you need to create the 'accounts' table make this call
TableUtils.createTable(connectionSource, Account.class);

// create an instance of Account
Account account = new Account("Jim Coakley");

// persist the account object to the database
// it should return 1 for the 1 row inserted
if (accountDao.create(account) != 1) @{
  // error handling @dots{} 
@}
// other code @dots{}

// destroy the data source which should close underlying connections
connectionSource.destroy();
@end example

For more examples, see the code later in the manual.  @xref{Examples}.

@c ----------------------------------------------------------------
@node DAO Usage, Identity Columns, Complete Wiring, Using
@section DAO Usage

@cindex DAO usage
@cindex using the DAOs

The following database operations are easily accomplished by using the DAO methods:

@table @asis

@cindex creating a database row
@cindex saving an object
@cindex persisting an object
@cindex writing an object
@item create and persist an object to the database

This inserts a new row to the database table associated with the object.

@example
Account account = new Account();
account.name = "Jim Coakley";
// only 1 row should have been affected
if (accountDao.create(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex query for id
@item query for it's id column 

If the object has an id field defined by the annotations, then we can lookup an object in the database using its id.

@example
Account account = accountDao.queryForId(name);
if (account == null) @{
  account not found handling @dots{} 
@}
@end example

@cindex updating an object
@item update the database row associated with the object

If you change fields in an object in memory, you must call update to persist those changes to the database.  This
requires an id field. 

@example
account.password = "_secret";
// 1 row should be updated
if (accountDao.update(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex refreshing an object
@item refreshing our object if the database has changed

If some other entity has changed a row the database corresponding to an object in memory, you will need to refresh that
object to get the memory object up-to-date.  This requires an id field. 

@example
// 1 row should be found
if (accountDao.refresh(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex deleting an object
@item delete the account from the database

Removes the row that corresponds to the object from the database.  Once the object has been deleted from the database,
you can continue to use the object in memory but any update or refresh calls will fail.  This requires an id field.

@example
// 1 row should be affected
if (accountDao.delete(account) != 1) @{
  // error handling @dots{} 
@}
@end example

@cindex iterator
@cindex iterating through all rows
@item iterate through all of the rows in a table:

The DAO is also an iterator so you can easily run through all of the rows in the database:

@example
// page through all of the accounts in the database
for (Account account : accountDao) @{
    System.out.println(account.getName());
@}
@end example

@cindex closing an iterator 
@emph{NOTE:} you must page through @emph{all} items for the iterator to close the underlying SQL object.   If you don't
go all of the way, the garbage collector will close the SQL statement some time later which is considered bad form.

@end table

For a detailed list of the methods in the DAO see @pxref{DAO Methods}.

@c ----------------------------------------------------------------
@node Identity Columns, Id Column, DAO Usage, Using
@section Identity Columns

Database rows are identified by a particular column which is defined as the @emph{identity} column.  This can either be
supplied by the user or auto-generated by the database.  Identity columns have unique values for every row in the table
and they are required if you want to query-by-id, delete, refresh, or update a particular row using the DAO.  To configure
a field as an identity field, you should use one (and only one) of the following three settings from @code{@@DatabaseField}:
@code{id}, @code{generatedId}, or @code{generatedIdSequence}.

@menu
* Id Column::                        Using fields with id = true.
* GeneratedId Column::               Using fields with generatedId = true.
* GeneratedIdSequence Column::       Using fields with generatedIdSequence = ...
@end menu

@c ----------------------------------------------------------------
@node Id Column, GeneratedId Column, Identity Columns, Identity Columns
@subsection Fields With id

@cindex identity field
@cindex id column
With our @code{Account} example class, the string @code{name} field has been marked with @code{id = true}.  This means
that the @code{name} is the identity column for the object.  Each account stored in the database must have a unique
value for the @code{name} field -- you cannot have two rows with the name "John Smith".

@example
public class Account @{
    @@DatabaseField(id = true)
    private String name;
    @dots{}
@}
@end example

When you use the DAO to lookup an account with a particular name, you will use the identity field to locate the
@code{Account} object in the database:

@example
Account account = accountDao.queryForId("John Smith");
if (account == null) @{
    // the name "John Smith" does not match any rows
@}
@end example

@cindex updateId
@cindex change id value
@cindex update identity of object
@emph{NOTE:} If you need to change the value of an object's id field, you must use the @code{Dao.updateId()} method which
takes the current object still with its @emph{old} id value and the new value.  @value{package} has to first locate the object
by its old id and then update it with the new id.  @xref{updateId}.

@c ----------------------------------------------------------------
@node GeneratedId Column, GeneratedIdSequence Column, Id Column, Identity Columns
@subsection Fields With generatedId

@cindex generated identity field
@cindex generatedId column
You can configure a long or integer field to be a @emph{generated} identity column.  The id number column for each row
will then be automatically generated by the database.  

@example
public class Order @{
    @@DatabaseField(generatedId = true)
    private int id;
    @dots{}
@}
@end example

When an @code{Order} object is passed to @code{create} and stored to the database, the generated identity value is returned
by the database and set on the object by @value{package}.  In the majority of database types, the generated value starts at
1 and increases by 1 every time a new row is inserted into the table.

@example
// build our order object without and id
Order order = new Order("Jim Sanders", 12.34);
@dots{}
if (orderDao.create(order) != 1) @{
   // error handling unless 1 row was inserted
@}
System.out.println("Order id " + order.getId() +
   " was persisted to the database");
// query for the order with an id of 1372
order = orderDao.queryForId(1372);
if (order == null) @{
   // none of the order rows have an id of 1372
@}
@end example

In the above code example, an order is constructed with name and amount (for example).  When it is passed to the DAO's
@code{create} method, the id field has not been set.  After it has been saved to the database, the generated-id will
be set on the id field by @value{package} and will be available when @code{getId()} is called on the order after the
@code{create} method returns.

@emph{NOTE:} Depending on the database type, you may not be able to change the value of an auto-generated id field.

@c ----------------------------------------------------------------
@node GeneratedIdSequence Column, Creating Indexes, GeneratedId Column, Identity Columns
@subsection Fields With generatedIdSequence

@cindex generated identity sequence name
@cindex generatedIdSequence column

Some databases use what's called a sequence number generator to provide the generated id value.  If you use
@code{generatedId = true} with those databases, a sequence name will be auto-generated by @value{package}.
If, however, you need to set the name of the sequence to match existing schema, you can used the
@code{generatedIdSequence} value which takes a string name for the sequence.

@example
public class Order @{
    @@DatabaseField(generatedIdSequence = "order_id_seq")
    private int id;
    @dots{}
@}
@end example

In the above example, the @code{id} value is again automatically generated but using a sequence with the name
@code{order_id_seq}.  This will throw an exception if you are working with a database which does not support
sequences.

@emph{NOTE:} Depending on the database type, you may not be able to change the value of an auto-generated id field.

@c ----------------------------------------------------------------
@node Creating Indexes, Raw Statements, GeneratedIdSequence Column, Using
@section Indexing Fields

@value{package} provides some limited support for indexing of various fields in your data classes.  First off, it
is important to point out that any field marked as an @code{id} field is already indexed.  Fields that are id fields
do not need to have additional indexes built and if they are specified, errors may result with certain database.

To add an index on a non-id field, all you need to do is add the @code{index = true} boolean field to the
@code{@@DatabaseField} annotation.  @xref{index}.  This will create a non-unique index after the table is created 
for the field and will drop the index if the table is then dropped.  Indexes help optimize queries and can
significantly improve times on queries to medium to large sized tables.

@example
public class Account @{
    @@DatabaseField(id = true)
    private String name;
    // this indexes the city field so queries on city
    // will go faster for large tables
    @@DatabaseField(index = true)
    private String city;
    @dots{}
@}
@end example 

This example creates the index @code{account_city_idx} on the Account table.  If you want to use a different name, you
can use the @code{indexName = "othername"} field instead which allows you to specify the name of the index.

If you often query on (for example) city @emph{and} state fields together, you might want to create an index
on both fields.  @value{package} supports creating indexes on multiple fields by specifying the same @code{indexName}
value for each of the fields you want to be included in the index.

@example
@@DatabaseField(indexName = "account_citystate_idx")
private String city;
@@DatabaseField(indexName = "account_citystate_idx")
private String state;
@end example

This example will create one index for both the city and state fields.  Note that queries on the city by itself will
@emph{not} be optimized -- only queries on @emph{both} city and state will be.  With some databases, it may be better to
create a single field index on each field and let the database use both indexes if you are querying on city and state.
For other databases, creating an index on multiple fields is recommended. You may need to experiment and use the SQL
@code{EXPLAIN} command to pinpoint how your database is utilizing your indicies.

To create @emph{unique} indexes, there is a @code{uniqueIndex = true} and @code{uniqueIndexName = "othername"} fields
also available on the @code{@@DatabaseField} annotation.  These work the same as the above settings but will instead
create unique indexes that ensure that no two row has the same value(s) for the indexed field(s).

@c ----------------------------------------------------------------
@node Raw Statements, Raw Queries, Creating Indexes, Using
@section Issuing Raw SQL Statements

In a number of instances, using the defined DAO functionality may not be enough to change your database.  For this
reason, @value{package} has calls which allow you to issue raw query, update, and execute statments to the database.

@menu
* Raw Queries::                Running raw queries against the database.
* Raw Updates::                Updating the database with raw SQL statements.
* Raw Executes::               Executing other raw SQL statments.
@end menu

@c ----------------------------------------------------------------
@node Raw Queries, Raw Updates, Raw Statements, Raw Statements
@subsection Issuing Raw Queries

@cindex aggregation queries
@cindex SUM, using
@cindex COUNT, using
@cindex AVG, using
@cindex queryForAllRaw
@cindex iteratorRaw
@cindex RawResults
@cindex GenericRawResults
The built-in methods available in the @code{Dao} interface and the @code{QueryBuilder} classes don't provide
the ability to handle all types of queries.  For example, aggregation queries (sum, count, avg, etc.) cannot be handled
as an object since every query has a different result list.  To handle these queries, you can issue raw database queries
using the @code{queryRaw} methods on DAO.  These methods return a @code{GenericRawResults} object which represents a
result as an array of strings, array of objects, or user objects.  See the documentation on the @code{GenericRawResults}
object for more details on how to use it, or take a look at the following examples.

@example
// find out how many orders account-id #10 has
GenericRawResults<String[]> rawResults =
  orderDao.queryRaw(
    "select count(*) from orders where account_id = 10");
// there should be 1 result
List<String[]> results = rawResults.getResults();
// the results array should have 1 value
String[] resultArray = results.get(0);
// this should print the number of orders that have this account-id
System.out.println("Account-id 10 has " + resultArray[0] + " orders");
@end example

For large numbers of results, you should consider using the @code{iterator()} method on the @code{GenericRawResults} object
which uses database paging.  For example:

@example
// return the orders with the sum of their amounts per account
GenericRawResults<String[]> rawResults =
  orderDao.queryRaw(
    "select account_id,sum(amount) from orders group by account_id");
// page through the results
for (String[] resultArray : rawResults) @{
  System.out.println("Account-id " + resultArray[0] + " has "
    + resultArray[1] + " total orders");
@}
rawResults.close();
@end example

If some of your fields cannot be appropriately mapped to strings, you can also return the fields as an @code{Object[]} if you
pass in the types of the resulting columns.  For example:

@example
// return the orders with the sum of their amounts per account
GenericRawResults<Object[]> rawResults =
  orderDao.queryRaw(
    "select account_id,sum(amount) from orders group by account_id",
    new DataType[] @{ DataType.LONG, DataType.INTEGER @});
// page through the results
for (Object[] resultArray : rawResults) @{
  System.out.println("Account-id " + resultArray[0] + " has "
    + resultArray[1] + " total orders");
@}
rawResults.close();
@end example

@emph{NOTE}: @code{select *} can return fields in different orders depending on the database type.  To make sure that the data-type
array matches the returned columns you must specify the fields specifically and @emph{not} with a SQL @code{*}.

You can also map the results into your own object by passing in a @code{RawRowMapper} object.  This will call the mapping object
with an array of strings and allow it to convert the strings into an object.  For example:

@example
// return the orders with the sum of their amounts per account
GenericRawResults<Foo> rawResults =
  orderDao.queryRaw(
    "select account_id,sum(amount) from orders group by account_id",
    new RawRowMapper<Foo>() @{
    		public Foo mapRow(String[] columnNames, String[] resultColumns) @{
    			return new Foo(Long.parseLong(resultColumns[0]),
    			    Integer.parseInt(resultColumns[1]));
    		@}
    @});
// page through the results
for (Foo foo : rawResults) @{
  System.out.println("Account-id " + foo.accountId + " has "
    + foo.totalOrders + " total orders");
@}
rawResults.close();
@end example

@emph{NOTE}: The query and the resulting strings can be @emph{very} database-type specific.  For example:
@enumerate
@item Certain databases need any column names specified in uppercase -- others need lowercase.
@item You may have to quote your column or table names if they are reserved words.
@item The resulting column names also could be uppercase or lowercase.
@item @code{select *} can return fields in different orders depending on the database type.
@end enumerate

@emph{NOTE}: Like other @value{package} iterators, you will need to make sure you iterate through all of the results
to have the statement closed automatically.  You can also call the @code{GenericRawResults.close()} method to make sure the
iterator, and any associated database connections, is closed.

@c ----------------------------------------------------------------
@node Raw Updates, Raw Executes, Raw Queries, Raw Statements
@subsection Issuing Raw Update Statements

@cindex raw update statments
@cindex update with raw sql
You can also issue raw update statements against the database if the DAO functionality does not give you
enough flexibility.  Update SQL statements must contain the reserved words @code{INSERT}, @code{DELETE}, or
@code{UPDATE}.  For example:

@example
fooDao.updateRaw("INSERT INTO accountlog (account_id, total) "
   + "VALUES ((SELECT account_id,sum(amount) FROM accounts))
@end example

@c ----------------------------------------------------------------
@node Raw Executes, Foreign Objects, Raw Updates, Raw Statements
@subsection Issuing Raw Execute Statements

@cindex raw execute statments
@cindex execute raw sql statments
@cindex truncate table
@cindex clear table
You can also issue raw update statements against the database if the DAO functionality does not give you
enough flexibility.  For example:

@example
fooDao.executeRaw("TRUNCATE TABLE accountlog");
@end example

Certain database types allow table truncation which you can call through the raw execute method.  If truncate
is not supported by the database then you can instead do:

@example
fooDao.executeRaw("DELETE FROM accountlog");
@end example

@c ----------------------------------------------------------------
@node Foreign Objects, Statement Builder, Raw Executes, Using
@section Foreign Object Fields

@cindex foreign objects
@value{package} supports the concept of "foreign" objects where one or more of the fields correspond to an object
are persisted in another table in the same database.  For example, if you had an @code{Order} objects in your database
and each @code{Order} had a corresponding @code{Account} object, then the @code{Order} object would have foreign
@code{Account} field.  With foreign objects, @emph{just} the id field from the @code{Account} is persisted
to the @code{Order} table as the column "@code{account_id}".  For example, the @code{Order} class might look
something like:

@example
@@DatabaseTable(tableName = "orders")
public class Order @{

    @@DatabaseField(generatedId = true)
    private int id;
    
    @@DatabaseField(canBeNull = false, foreign = true)
    private Account account;
    @dots{}
@}
@end example

When the @code{Order} table was created, something like the following SQL would be generated:

@example
CREATE TABLE `orders`
   (`id` INTEGER AUTO_INCREMENT , `account_id` INTEGER,
    PRIMARY KEY (`id`)); 
@end example

@emph{Notice} that the name of the field is @emph{not} @code{account} but is instead @code{account_id}.  You will need to
use this field name if you are querying for it.  You can set the column name using the @code{columnName} field in the
@code{DatabaseField} annotation. @xref{columnName}.

@cindex creating objects with foreign fields
@cindex foreign objects, creating
When you are creating a field with a foreign object, please note that the foreign object will @emph{not} automatically be
created for you.  If your foreign object has a generated-id which is provided by the database then you need to create it
@emph{before} you create any objects that reference it.  For example:

@example
Account account = new Account("Jim Coakley");
if (accountDao.create(account) != 1) @{
  // error handling @dots{} 
@}
// this will create the account object and set any generated ids

// now we can set the account on the order and create it
Order order = new Order("Jim Sanders", 12.34);
order.setAccount(account);
@dots{}
if (orderDao.create(order) != 1) @{
   // error handling unless 1 row was inserted
@}
@end example

@cindex refreshing foreign objects
@cindex foreign object refreshing
When you query for an order, you will get an @code{Order} object with an account field object that @emph{only} has its id
field set.  The rest of the fields in the foreign @code{Account} object will have default values (null, 0, false, etc.).  If
you want to use other fields in the @code{Account}, you must call @code{refresh} on the @code{accountDao} class to get the
@code{Account} object filled in.  For example:

@example
Order order = orderDao.queryForId(orderId);
System.out.println("Account-id on the order should be set: " +
   order.account.id);
// this should print null for order.account.name
System.out.println("But other fields on the account should not be set: "
   + order.account.name);

// so we refresh the account using the AccountDao
if (accountDao.refresh(order.getAccount()) != 1) @{
   // error handling @dots{} 
@}
System.out.println("Now the account fields will be set: " +
   order.account.name);
@end example

You can have the foreign objects automagically refreshed by using the @code{foreignAutoRefresh} setting. @xref{foreignAutoRefresh}.

@emph{NOTE:} Because we use refresh, foreign objects are therefor @emph{required} to have an id field.

The @code{Where()} object has some method calls to help with using foreign objects.  @pxref{foreignIdEq} and @pxref{foreignIdIn}.
There is also example code to show how to use foreign objects.  @xref{foreign objects example}.

@c ----------------------------------------------------------------
@node Statement Builder, QueryBuilder Basics, Foreign Objects, Top
@chapter Custom Statement Builder

@cindex query builder
@cindex custom query builder
@cindex custom statement builder
The DAOs have methods to query for an object that matches an id field (@code{queryForId}) as well as query for all
objects (@code{queryForAll}) and iterating through all of the objects in a table (@code{iterator}).  However, for more
specified queries, there is the @code{queryBuilder()} method which returns a @code{QueryBuilder} object for the DAO
with which you can construct custom queries to return a sub-set of the table.

@menu
* QueryBuilder Basics::         How to start using the query builder.
* Building Queries::            How to build simple and complex queries.
* Building Statements::         How to build update and delete statements.
* Where Capabilities::          Description of the various WHERE statements.
* Select Arguments::            Using arguments to queries.
@end menu

@c ----------------------------------------------------------------
@node QueryBuilder Basics, Building Queries, Statement Builder, Statement Builder
@section Query Builder Basics

Here's how you use the query builder to construct custom queries.  First, it is a good pattern to
set the column names of the fields with Java constants so you can use them in queries.  For example:

@example
@@DatabaseTable(tableName = "accounts")
public class Account @{
    public static final String PASSWORD_FIELD_NAME = "password"; 
	
	@dots{}
    @@DatabaseField(canBeNull = false, columnName = PASSWORD_FIELD_NAME)
    private String password;
	@dots{}
@end example

This allows us to construct queries using the password field name without having the renaming of a field in the future break
our queries.  This should be done @emph{even} if the name of the field and the column name are the same.

@cindex where
@example
// get our query builder from the DAO
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
// the 'password' field must be equal to "qwerty"
queryBuilder.where().eq(Account.PASSWORD_FIELD_NAME, "qwerty");
// prepare our sql statement
PreparedQuery<Account, String> preparedQuery =
  queryBuilder.prepare();
// query for all accounts that have that password
List<Account> accountList = accountDao.query(preparedQuery);
@end example

@cindex prepared statement
You get a @code{QueryBuilder} object from the @code{Dao.queryBuilder} method, call methods on it to build your custom
query, call @code{queryBuilder.prepare()} which returns a @code{PreparedQuery} object, and then pass the @code{PreparedQuery}
to the DAO's @code{query} or @code{iterator} methods.

As a short cut, you can also call the @code{prepare()} method on the @code{Where} object to do something like the
following: 

@example
// query for all accounts that have that password
List<Account> accountList =
   accountDao.query(
      accountDao.queryBuilder().where()
         .eq(Account.PASSWORD_FIELD_NAME, "qwerty")
         .prepare());
@end example

@c ----------------------------------------------------------------
@node Building Queries, Building Statements, QueryBuilder Basics, Statement Builder
@section Building Queries

@cindex building queries
There are a couple of different ways that you can build queries.  The @code{QueryBuilder} has been written for ease of use
as well for power users.  Simple queries can be done linearly:

@example
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
// get the WHERE object to build our query
Where<Account, String> where = queryBuilder.where();
// the name field must be equal to "foo"
where.eq(Account.NAME_FIELD_NAME, "foo");
// and
where.and();
// the password field must be equal to "_secret"
where.eq(Account.PASSWORD_FIELD_NAME, "_secret");
PreparedQuery<Account, String> preparedQuery =
  queryBuilder.prepare();
@end example

The SQL query that will be generated from the above example will be approximately:

@example
SELECT * FROM account
  WHERE (name = 'foo' AND password = '_secret')
@end example

@cindex chain query methods
If you'd rather chain the methods onto one line (like StringBuilder), this can also be written as:

@example
queryBuilder.where()
  .eq(Account.NAME_FIELD_NAME, "foo")
  .and()
  .eq(Account.PASSWORD_FIELD_NAME, "_secret");
@end example

If you'd rather use parenthesis to group the comparisons properly then you can call:

@example
Where<Account, String> where = queryBuilder.where();
where.and(where.eq(Account.NAME_FIELD_NAME, "foo"),
          where.eq(Account.PASSWORD_FIELD_NAME, "_secret"));
@end example

@cindex complex query
All three of the above call formats produce the same SQL.  For complex queries that mix ANDs and ORs, the last
format may be necessary to get the grouping correct.  For example, here's a complex query:

@example
Where<Account, String> where = queryBuilder.where();
where.or(
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "foo"),
    where.eq(Account.PASSWORD_FIELD_NAME, "_secret")),
  where.and(
    where.eq(Account.NAME_FIELD_NAME, "bar"),
    where.eq(Account.PASSWORD_FIELD_NAME, "qwerty")));
@end example

This produces the following approximate SQL:

@example
SELECT * FROM account
  WHERE ((name = 'foo' AND password = '_secret')
         OR (name = 'bar' AND password = 'qwerty'))
@end example

@cindex ORDER BY, SQL
@cindex GROUP BY, SQL
The @code{QueryBuilder} also allows you to set what specific select columns you want returned, specify the 'ORDER BY'
and 'GROUP BY' fields, and various other SQL features (LIKE, IN, >, >=, <, <=, <>, IS NULL, DISTINCT, @dots{}).
@xref{Where Capabilities}. You can also see the javadocs on @code{QueryBuilder} and @code{Where} classes for more
information.  A good SQL reference site can be found at @uref{http://www.w3schools.com/Sql/}.

@c ----------------------------------------------------------------
@node Building Statements, Where Capabilities, Building Queries, Statement Builder
@section Building Statements

@cindex deleteBuilder
@cindex updateBuilder
@cindex custom update statements
@cindex custom delete statements
@anchor{deleteBuilder}
@anchor{updateBuilder}
The DAO can also be used to construct custom @code{UPDATE} and @code{DELETE} statements.  Update statements
are used to change certain fields in rows from the table that match the @code{WHERE} pattern -- or update @emph{all}
rows if no @code{where()}. Delete statements are used to delete rows from the table that match the @code{WHERE}
pattern -- or delete @emph{all} rows if no @code{where()}.  

For example, if you want to update the passwords for all of the Accounts in your table that are currently null to
the string "none", then you might do something like the following:

@example
UpdateBuilder<Account, String> updateBuilder =
  accountDao.updateBuilder();
// update the password to be "none"
updateBuilder.updateColumnValue("password", "none");
// only update the rows where password is null
updateBuilder.where().isNull(Account.PASSWORD_FIELD_NAME);
accountDao.update(updateBuilder.prepare());
@end example

With update, you can also specify the update value to be an expression:

@example
// update hasDogs boolean to true if dogC > 0
updateBuilder.updateColumnExpression(
  "hasDogs", "dogC > 0");
@end example

To help you construct your expressions, you can use the UpdateBuilder's escape methods @code{escapeColumnName} and
@code{escapeValue} can take a string or a @code{StringBuilder}.  This will protect you if columns or values are reserved words. 

If, instead, you wanted to delete the rows in the Accounts table whose password is currently null, then you might do
something like the following:

@example
DeleteBuilder<Account, String> deleteBuilder =
  accountDao.deleteBuilder();
// only delete the rows where password is null
deleteBuilder.where().isNull(Account.PASSWORD_FIELD_NAME);
accountDao.delete(deleteBuilder.prepare());
@end example

@c ----------------------------------------------------------------
@node Where Capabilities, Select Arguments, Building Statements, Statement Builder
@section Where Capabilities

The following are some details about the various method calls for adding @code{WHERE} SQL statements to your custom
select, delete, and update statements.  See the Javadocs for the @code{Where} class for the most up-to-date information
about the available methods.  All of the methods return the @code{Where} object so you can chain them together.

For a good tutorial of SQL commands, here's a good site: @uref{http://www.w3schools.com/sql/sql_where.asp}.

@table @code

@cindex AND, SQL
@item and()

Binary @code{AND} operation which takes the previous clause and the next clause and AND's them together.  This is when
you are using inline query calls.

@item and(Where<T, ID> left, Where<T, ID> right)

Binary AND operation which takes 2 arguments and AND's them together.  This is when you are @emph{not} using inline
query calls but instead want to use standard arguments.

@cindex BETWEEN, SQL
@item between(String columnName, Object low, Object high)

Add a BETWEEN clause which makes sure the column is between the low and high parameters.

@cindex =, SQL
@cindex equals, SQL
@item eq(String columnName, Object value)

Add a '=' clause which makes sure the column is equal to the value.

@cindex EXISTS, SQL
@item exists(QueryBuilder<?, ?> subQueryBuilder)

Add a EXISTS clause with a sub-query inside of parenthesis.  This will return returns as long as the inner query returns
results.

@emph{NOTE:} The sub-query will be prepared at the same time that the outside query is.

@anchor{foreignIdEq}
@item foreignIdEq(Dao<OD, OID> dataDao, OD data)

Add a clause where the ID is the id from a foreign field in the data that is passed in.

@anchor{foreignIdIn}
@item foreignIdIn(Dao<OD, OID> dataDao, OD... datas)

Add a IN clause where the ID is the id from a foreign field in the data items that are passed in.

@item foreignIdIn(Dao<OD, OID> dataDao, Iterable<OD> datas)

Add a IN clause where the ID is the id from a foreign field in the data items iterable that is passed in.

@cindex >=, SQL
@cindex ge, SQL
@cindex greater than or equal, SQL
@item ge(String columnName, Object value)

Add a '>=' clause which makes sure the column is greater-than or equals-to the value.

@cindex >, SQL
@cindex gt, SQL
@cindex greater than, SQL
@item gt(String columnName, Object value)

Add a '>' clause which makes sure the column is greater-than the value.

@item idEq(ID id)

Add a clause where the ID is equals to the argument.

@item idEq(Dao<OD, ?> dataDao, OD data)

Add a clause where the ID is extracted from an existing object.

@cindex IN, SQL
@item in(String columnName, Iterable<?> objects)

Add a IN clause which makes sure the column is equal-to one of the objects from the Iterable (probably collection)
passed in.

@cindex IN, SQL
@item in(String columnName, Object... objects)

Add a IN clause which makes sure the column is equal-to one of the objects passed in.

@cindex IN sub-query, SQL
@cindex inner queries
@cindex sub-queries
@item in(String columnName, QueryBuilder<?, ?> subQueryBuilder)

Add a IN clause which makes sure the column is in one of the columns returned from a sub-query inside of parenthesis.
The @code{QueryBuilder} must return 1 and only one column which can be set with the @code{QueryBuilder.selectColumns(String...)}
method calls. That 1 argument must match the SQL type of the column-name passed to this method.

@emph{NOTE:} The sub-query will be prepared at the same time that the outside query is.

@cindex IS NULL, SQL
@cindex null comparison, SQL
@item isNull(String columnName)

Add a 'IS NULL' clause which makes sure the column's value is null. '=' NULL does not work.

@cindex IS NOT NULL, SQL
@cindex null comparison, SQL
@item isNotNull(String columnName)

Add a 'IS NOT NULL' clause so the column must not be null. '<>' NULL does not work.

@cindex <=, SQL
@cindex less than or equals, SQL
@cindex le
@item le(String columnName, Object value)

Add a '<=' clause which makes sure the column is less-than or equals-to the value.

@cindex <, SQL
@cindex less than, SQL
@cindex lt
@item lt(String columnName, Object value)

Add a '<' clause which makes sure the column is less-than the value.

@cindex LIKE, SQL
@item like(String columnName, Object value)

Add a LIKE clause which makes sure the column match the value using '%' patterns.

@cindex <>, SQL
@cindex not equal to, SQL
@cindex ne
@item ne(String columnName, Object value)

Add a '<>' clause which makes sure the column is not-equal-to the value.

@cindex NOT, SQL
@item not()

Used to NOT the next clause specified when using inline query calls.

@item not(Where<T, ID> comparison)

Used to NOT the argument clause specified.  This is when you are @emph{not} using inline
query calls but instead want to use standard arguments.

@cindex OR, SQL
@item or()

Binary @code{OR} operation which takes the previous clause and the next clause and OR's them together.  This is when
you are using inline query calls.

@item or(Where<T, ID> left, Where<T, ID> right)

Binary OR operation which takes 2 arguments and OR's them together.  This is when you are @emph{not} using inline
query calls but instead want to use standard arguments.

@item prepare()

A short-cut for calling @code{prepare()} on the original @code{QueryBuilder.prepare()}.  This method returns a
@code{PreparedQuery} object.

@end table

@c ----------------------------------------------------------------
@node Select Arguments, Use With Android, Where Capabilities, Statement Builder
@section Using Select Arguments

@cindex query arguments
@cindex select arguments
@cindex arguments to queries
@cindex sql ?
Select Arguments are arguments that are used in WHERE operations can be specified directly as value arguments (as in the
above examples) or as a @code{SelectArg} object.  SelectArgs are used to set the value of an argument at a later time --
they generate a SQL '@code{?}'.

For example:

@example
QueryBuilder<Account, String> queryBuilder =
  accountDao.queryBuilder();
Where<Account, String> where = queryBuilder.where();
SelectArg selectArg = new SelectArg();
// define our query as 'name = ?'
where.eq(Account.NAME_FIELD_NAME, selectArg);
// prepare it so it is ready for later query or iterator calls
PreparedQuery<Account, String> preparedQuery =
  queryBuilder.prepare();

// later we can set the select argument and issue the query
selectArg.setValue("foo");
List<Account> accounts = accountDao.query(preparedQuery);
// then we can set the select argument to another
// value and re-run the query
selectArg.setValue("bar");
accounts = accountDao.query(preparedQuery);
@end example

Certain data types use an internal @code{SelectArg} object because the string value of the object does not reliably match the
database form of the object.  @code{java.util.Date} is one example of such a type.

@emph{NOTE:} @code{SelectArg} objects have protection against being used in more than one column name.  You must instantiate a
new object if you want to use a @code{SelectArg} with another column.

@c ----------------------------------------------------------------
@node Use With Android, Advanced, Select Arguments, Top
@chapter Using With Android

@cindex use with Android OS
@cindex Android OS support
@cindex droid support

Because of the lack of support for JDBC in Android OS, @value{package} makes direct calls to the Android database APIs
to access SQLite databases.  You should make sure that you have downloaded and are depending on the
@code{ormlite-android.jar} file and @emph{not} the @code{ormlite-jdbc.jar} version.  Although a number of developers
are using the package in their projects, we continue to improve how @value{package} integrates with the Android classes.
Feedback on this would be welcome.

After you have read the getting started section (@pxref{Getting Started}), the following instructions should be
followed to help you get @value{package} working under Android OS.

@enumerate

@item You will need to create your own database helper class which should probably extend the @code{OrmLiteSqliteOpenHelper}  
class.  This class creates and upgrades the database when your app is installed and can also provide the DAO classes
used by your other classes.  Your helper class must implement the methods
@code{onCreate(SQLiteDatabase sqliteDatabase, ConnectionSource connectionSource)} and
@code{onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion)}.
@code{onCreate} creates the database when your app is first installed while @code{onUpgrade} handles the upgrading
of the database tables when you upgrade your app to a new version.  There is a sample @code{DatabaseHelper} class as well as
examples projects online: @uref{http://ormlite.com/android/examples/}. 

@item The helper can be kept open across all activities in your app with the same Sqlite database connection reused by
all threads.  If you open multiple connections to the same database, stale data and unexpected results may occur.
We recommend using the @code{OpenHelperManager} to monitor the usage of the helper -- it will create it on the first
access, track each time a part of your code is using it, and then it will close the last time the helper is released.

@item The @code{OpenHelperManager} will by default look for the full class name of your own database helper class
in the @code{open_helper_classname} value defined in @code{res/values/strings.xml}.  You can instead set a
@code{SqliteOpenHelperFactory} on the manager directly in a @code{static @{@}} block in your code.   

@item  Once you have defined your database helper and are managing it correctly, you will need to use it in your @code{Activity}
classes.  An easy way to use the @code{OpenHelperManager} is to extend @code{OrmLiteBaseActivity} for each of your
activity classes -- there is also @code{OrmLiteBaseService} and @code{OrmLiteBaseTabActivity}.  These classes provide a
@code{getHelper()} method to access the database helper whenever it is needed and will automatically release the helper
in the @code{onDestroy()} method.  There is a sample @code{HelloAndroid} activity class in the the sample section of the tests 
and on the web site along with a @code{SampleData} example class.  @xref{Android Examples}.

@item If you do not want to extend the base classes then you will need to duplicate their basic functionality of calling
@code{OpenHelperManager.getHelper(Context context)} at the start of your code, save the helper and use it as much as 
you want, and then calling @code{OpenHelperManager.release()} when you are done with it.

@item The Android native SQLite database type is @code{SqliteAndroidDatabaseType} and is used by the base classes internally.

@end enumerate

Please see the example code documention for more information.  @xref{Android Examples}.  Again, feedback on this is welcome.

@c ----------------------------------------------------------------
@node Advanced, Spring Configuration, Use With Android, Top
@chapter Advanced Concepts

@menu
* Spring Configuration::       How to wire @value{package} in Spring.
* Class Configuration::        Alternate ways to configure your classes.
* Database Type Details::      Description of the database specific code.
* DAO Methods::                What functionality is provided by the DAO.
* Logging::                    How to log messages with @value{package}.
* Dependencies::               External dependencies of @value{package}.
@end menu

@c ----------------------------------------------------------------
@node Spring Configuration, Class Configuration, Advanced, Advanced
@section Spring Configuration

@cindex spring framework
@cindex configuration with Spring
@value{package} contains some classes which make it easy to configure the various database classes using
the Spring framework.  For more information about the Spring Framework, see @uref{http://www.springsource.org/}.

@table @code

@cindex TableCreator
@cindex create schema
@cindex create tables
@cindex generation of the schema
@cindex schema generation
@cindex auto create tables
@cindex auto drop tables
@cindex drop tables
@item TableCreator

Spring bean that auto-creates any tables that it finds DAOs for if the system property @code{ormlite.auto.create.tables}
has been set to true. It will also auto-drop any tables that were auto-created if the property
@code{ormlite.auto.drop.tables} has been set to true.  This should be used carefully and probably only in tests.

@cindex dao factory
@item DaoFactory

Spring bean that can be used to create Dao's for certain classes without needing to define their own Dao class.

@end table

@cindex spring examples
Here's an example of a full Spring configuration.

@example
<!-- URL used for database, probably should be in properties file -->
<bean id="databaseUrl" class="java.lang.String">
    <!-- we are using the in-memory H2 database in this example -->
    <constructor-arg index="0" value="jdbc:h2:mem:account" />
</bean>

<!-- datasource used by @value{package} to connect to the database -->
<bean id="connectionSource"
    class="com.j256.ormlite.jdbc.JdbcConnectionSource"
    init-method="initialize">
    <property name="url" ref="databaseUrl" />
    <!-- probably should use system properties for these too -->
    <property name="username" value="foo" />
    <property name="password" value="bar" />
</bean>

<!-- abstract dao that is common to all defined daos -->
<bean id="baseDao" abstract="true" init-method="initialize">
    <property name="connectionSource" ref="connectionSource" />
</bean>

<!-- our daos -->
<bean id="accountDao"
    class="com.j256.ormlite.examples.common.AccountDaoImpl"
    parent="baseDao" />
<bean id="deliveryDao" class="com.j256.ormlite.spring.DaoFactory" factory-method="createDao">
	<constructor-arg index="0" ref="connectionSource" />
	<constructor-arg index="1" value="com.j256.ormlite.examples.spring.Delivery" />
</bean>
@end example

You can also take a look at the spring example code.  @xref{spring example}.

@c ----------------------------------------------------------------
@node Class Configuration, Database Type Details, Spring Configuration, Advanced
@section Class Configuration

The simplest mechanism for configuring a class to be persisted by @value{package} is to use the @code{@@DatabaseTable}
and @code{@@DatabaseField} annotations.  @xref{Local Annotations}.  However if you do not own the class you are
persisting or there are permission problems with the class, you may want to configure the class using Java code instead.

@cindex configure a class in code
To configure a class in code, you use the @code{DatabaseFieldConfig} and @code{DatabaseTableConfig} objects.
The field config object holds all of the details that are in the @code{@@DatabaseField} annotation as well as
the name of the corresponding field in the object.  The @code{DatabaseTableConfig} object holds the class and the
corresponding list of @code{DatabaseFieldConfig}s.  For example, to configure the @code{Account} object using Java code
you'd do something like the following:

@example
List<DatabaseFieldConfig> fieldConfigs =
    new ArrayList<DatabaseFieldConfig>();
fieldConfigs.add(new DatabaseFieldConfig("name", null, DataType.UNKNOWN,
    null, 0, false, false, true, null, false, null, false));
fieldConfigs.add(new DatabaseFieldConfig("password", null,
    DataType.UNKNOWN, null, 0, false, false, false, null, false, null,
    false));
DatabaseTableConfig<Account> accountTableConfig
    = new DatabaseTableConfig<Account>(Account.class, fieldConfigs);

AccountDaoImpl accountDao =
    new AccountDaoImpl(connectionSource, accountTableConfig);
@end example

@cindex spring wire a class
See the Javadocs for the @code{DatabaseFieldConfig} class for the fields to pass to the constructor.  You can also
use the no-argument constructor and call the setters for each field.  You use the setters as well when you are
configuring a class using Spring wiring.  Here is the above example in Spring:

@example
<bean id="accountTableConfig"
  class="com.j256.ormlite.table.DatabaseTableConfig">
    <property name="dataClass"
        value="com.j256.ormlite.examples.common.Account" />
    <property name="tableName" value="account" />
    <property name="fieldConfigs">
        <list>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="name" />
                <property name="id" value="true" />
            </bean>
            <bean class="com.j256.ormlite.field.DatabaseFieldConfig">
                <property name="fieldName" value="password" />
                <property name="canBeNull" value="false" />
            </bean>
        </list>
    </property>
</bean>
@end example

You can also look at the field configuration example code.  @xref{field config example}.

@c ----------------------------------------------------------------
@node Database Type Details, DAO Methods, Class Configuration, Advanced
@section Database Specific Code

@cindex database type
@cindex database specific code
@value{package} uses an internal @code{DatabaseType} object which defines all of the per-database information necessary
to support the various features on all of the different database types.  The @code{JdbcConnectionSource} uses the database
URL to pick the correct @code{DatabaseType}.  If it picks an incorrect one then you may need to set the @code{DatabaseType}
on the connection source @emph{directly}.  For example:

@example
String databaseUrl = "jdbc:derby://dbserver1:1527/";
DatabaseType databaseType = new DerbyClientServerDatabaseType();
ConnectionSource connectionSource =
   new JdbcConnectionSource(databaseUrl, databaseType);
@end example

Android users do not need to worry about this because the @code{AndroidConnectionSource} always uses the
@code{SqliteAndroidDatabaseType}.  @xref{Use With Android}.

The @code{DatabaseType} classes are found in @code{com.j256.ormlite.db}.  Each of the supported databases has a class there
which implements the code needed to handle the unique features of the database (H2DatabaseType, MySqlDatabaseType, etc.).
If you want to help develop and test against other SQL databases, a externally available server that the author could connect
to and test against would be appreciated.  Please contact the author if your database is not supported or if you want to help.

The following methods are currently used by the system to isolate the database specific behavior in one place.
See the javadocs for the @code{DatabaseType} class for the most up to date information.

@table @code

@item isDatabaseUrlThisType

Return true if the database URL corresponds to this database type. Usually the URL is in the form @code{jdbc:ddd:@dots{}}
where ddd is the driver url part.

@item loadDriver

Load the driver class associated with this database so it can wire itself into JDBC.

@item appendColumnArg

Takes a field type and appends the SQL necessary to create the field.  It may also generate arguments
for the end of the table create statement or commands that must run before or after the table create.

@item convertColumnName

Convert and return the column name for table and sequence creation. Often this is necessary to fix case issues.

@item dropColumnArg

Takes a field type and adds all of the commands necessary to drop the column from the database.

@item appendEscapedEntityName

Add a entity-name (table or column name) word to the SQL wrapped in the proper characters to escape it.
This avoids problems with table, column, and sequence-names being reserved words.

@item appendEscapedWord

Add the word to the string builder wrapped in the proper characters to escape it. This avoids problems with
data values being reserved words.

@item generateIdSequenceName

Return the name of an ID sequence based on the table-name and the field-type of the id.  This is required
by some database types when we have generated ids.

@item getCommentLinePrefix

Return the prefix to put at the front of a SQL line to mark it as a comment.

@item isIdSequenceNeeded

Return true if the database needs a sequence when you insert for generated IDs.  Some databases handle
generated ids internally.

@item getFieldConverter

Return the field converter associated with a particular field type.  This allows the database instance to
convert a field as necessary before it goes to the database.

@item isVarcharFieldWidthSupported

Return true if the database supports the width parameter on VARCHAR fields.

@item isLimitSupported

Return true if the database supports the LIMIT sql command.

@item isLimitAfterSelect

Return true if the LIMIT should be called after SELECT otherwise at the end of the WHERE (the default).

@item appendLimitValue

Add the necessary SQL to limit the results to a certain number.

@item appendSelectNextValFromSequence

Add the SQL necessary to get the next-value from a sequence. This is only necessary if
isIdSequenceNeeded returns true.

@item appendCreateTableSuffix

Append the SQL necessary to properly finish a CREATE TABLE line.

@item isCreateTableReturnsZero

Returns true if a 'CREATE TABLE' statement should return 0. False if > 0.

@item isEntityNamesMustBeUpCase

Returns true if table and field names should be made uppercase.  This is an unfortunate "feature" of Derby and Hsqldb.
See the Javadocs for the class for more information.

@item isNestedSavePointsSupported

Returns true if the database supports nested savepoints (transactions).

@item isSerializableIdAllowed

Returns true if the datatype Seriliable is allowed as an identity column. Mostly for testing purposes.

@end table

@c ----------------------------------------------------------------
@node DAO Methods, Logging, Database Type Details, Advanced
@section DAO Methods

@cindex dao methods
The DAO classes provide the following methods that you can use to store your objects to your database.
This list may be out of date.  See the @code{Dao} interface class for the latest methods.

@table @code

@cindex query for id
@item queryForId(ID id)

Looks up the id in the database and retrieves an object associated with it.

@cindex query for first
@item queryForFirst(PreparedQuery<T> preparedQuery)

Query for and return the first item in the object table which matches a prepared statement. This can be used to return
the object that matches a single unique column.  You should use queryForId if you want to query for the id column.

@cindex query for all
@item queryForAll()

Query for all of the items in the object table and return a list of them. For medium sized or large tables,
this may load a lot of objects into memory so you should consider using the @code{iterator} method instead.

@cindex query builder
@cindex statement builder
@item queryBuilder()

Create and return a new @code{QueryBuilder} object which allows you to build a custom query.  @xref{QueryBuilder Basics}.

@cindex update builder
@item updateBuilder()

Create and return a new @code{UpdateBuilder} object which allows you to build a custom update statement.  @xref{updateBuilder}.

@cindex delete builder
@item deleteBuilder()

Create and return a new @code{DeleteBuilder} object which allows you to build a custom delete statement.  @xref{deleteBuilder}.

@cindex query for objects
@item query(PreparedQuery<T> preparedQuery)

Query for the items in the object table which match a prepared statement.  @xref{Statement Builder}.  This returns a
list of matching objects. For medium sized or large tables, this may load a lot of objects into memory so you
should consider using the @code{iterator} method instead.  

@cindex creating an object
@item create(T data)

Create a new entry in the database from an object.  Should return 1 indicating 1 row was inserted.

@cindex updating an object
@item update(T data)

Save the fields from an object to the database. If you have made changes to an object, this is how you persist
those changes to the database. You cannot use this method to update the id field -- see updateId.  This should
return 1 since 1 row was updated.

@cindex update an object id
@anchor{updateId}
@item updateId(T data)

Update an object in the database to change its id to a new id. The data @emph{must} have its current id set and
the new-id is passed in as an argument.  After the id has been updated in the database, the id field of the data
object will also be changed.  This should return 1 since 1 row was updated.

@cindex update custom statement
@cindex custom update statement
@item update(PreparedUpdate<T> preparedUpdate)

Update objects that match a custom update statement.

@cindex refreshing an object
@item refresh(T data, ID newId)

Does a query for the object's id and copies in each of the field values from the database to refresh the data
parameter. Any local object changes to persisted fields will be overwritten.  If the database has been updated
this brings your local object up-to-date.  This should return 1 since 1 row was retrieved.

@cindex deleting an object
@item delete(T data)

Delete an object from the database.  This should return 1 since 1 row was removed.

@cindex delete multiple objects
@item delete (Collection<T> datas)

Delete a collection of objects from the database using an IN SQL clause.  This returns the number of rows that
were deleted.

@cindex delete objects by id
@item deleteIds(Collection<ID> ids)

Delete the objects that match the collection of ids from the database using an IN SQL clause.   This returns the
number of rows that were deleted.  

@cindex delete custom statement
@cindex custom delete statement
@item delete(PreparedDelete<T> preparedDelete)

Delete objects that match a custom delete statement.

@cindex iterator
@item iterator

This method satisfies the @code{Iterable} Java interface for the class and allows you to iterate through the objects
in the table using SQL.  This method allows you to do something like:

@example
for (Account account : accountDao) @{ @dots{} @}
@end example

@emph{WARNING:} See the @code{Dao} class for warnings about using this method.

@item iterator(PreparedQuery<T> preparedQuery)

Same is the @code{iterator} method but with a prepared statement parameter. @xref{Statement Builder}.

@item iteratorRaw(String query)

Same as the prepared statement iterator except it takes a raw SQL select statement argument.  This is the iterator version
of the @code{queryForAllRaw} method.  Although you should use the @code{iterator} method for most queries, this method
allows you to do special queries that aren't supported otherwise.  Like the above iterator methods, you must call close
on the @code{GenericRawResults} object returned by the method once you are done with it. 

@cindex query for all raw
@cindex raw select statements
@cindex executing raw select statements
@item queryRaw(String query)

Query for all of the items in the object table that match the SQL select query argument. This method allows you
to do special queries that aren't supported otherwise. For medium sized or large tables, this may load a lot of 
objects into memory so you should consider using the @code{iterator()} method on the @code{GenericRawResults}
instead of the @code{getResults} method.  @xref{Raw Queries}.

@item queryRaw(String query, RawRowMapper<UO> mapper)

Same as the above @code{queryRaw} method but with the addition of a row mapper.  Instead of each row being returned
as an array of strings, this will map the row using the mapper object passed in.  @xref{Raw Queries}.

@item queryRaw(String query, DataType[] columnTypes)

Same as the above @code{queryRaw} method but with the addition of a an array of column data types.  Instead of each
row being returned as an array of strings, they are returned as an array of objects.  @xref{Raw Queries}.

@item executeRaw(String statement)

Run a raw execute SQL statement against the database.  @xref{Raw Executes}.

@item updateRaw(String statement)

Run a raw update SQL statement (@code{INSERT}, @code{DELETE}, or @code{UPDATE} against the database.
@xref{Raw Updates}.

@item callBatchTasks(Callable callable)

Call the call-able that will perform a number of batch tasks. This is for performance when you want to run a
number of database operations at once -- maybe loading data from a file. This will turn off what databases call
"auto-commit" mode, run the call-able and then re-enable "auto-commit".

@emph{NOTE:} This is only supported by databases that support auto-commit. Android, for example, does not
support auto-commit although using the @code{TransactionManager} and performing actions within a transaction
seems to have the same batch performance implications.

@end table

@c ----------------------------------------------------------------
@node Logging, Dependencies, DAO Methods, Advanced
@section @value{package} Logging

@cindex logging information
@value{package} uses a log system which can plug into Apache commons logging, Log4j, Android Log, or its own internal
log implementations.  The logger code in @code{com.j256.ormlite.logger} first looks for the @code{android.util.Log} and
if found will use the Android internal logger.  Next it looks for@code{org.apache.commons.logging.LogFactory} class in the
classpath -- if found it will use Apache commons logging.  If that class is not found it then looks for
@code{org.apache.log4j.Logger} and if found will use Log4j.  If none of these classes are available it will use an internal
logger -- see @code{LocalLog}.  The logger code also provides simple @{@} argument expansion like @code{slf4j} which means
that you can save on @code{toString()} calls and @code{StringBuilder} operations if the log level is not high enough.  This
allows me to do something like the following:

@example
private static Logger logger =
  LoggerFactory.getLogger(QueryBuilder.class);
@dots{}
logger.debug("built statement @{@}", statement);
@end example

If you are using log4j (through Apache commons logging or directly), you can use something
like the following as your log4j.properties file to see details about the SQL calls.

@cindex log4j properties file
@example
log4j.rootLogger=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout

# print the date in ISO 8601 format
log4j.appender.stdout.layout.ConversionPattern=%d@{ISO8601@} [%p] %c@{1@} %m%n

# be more verbose with our code
log4j.logger.com.j256.ormlite=DEBUG

# to enable logging of arguments to all of the SQL calls
# uncomment the following line
#log4j.logger.com.j256.ormlite.stmt.mapped.BaseMappedStatement=TRACE
@end example

@cindex logging sql arguments
@cindex sql argument logging
@emph{Notice} that you can uncomment the last line in the above log4j.properties file to log the arguments to the
various SQL calls.  This may expose passwords or other sensitive information in the database so probably should
only be used during debugging and should not be the default.

@c ----------------------------------------------------------------
@node Dependencies, How to Upgrade, Logging, Advanced
@section External Dependencies

@value{package} does not have any direct dependencies.  It has logging classes that depend on Apache commons-logging
and Log4j but these classes will @emph{not} be referenced unless they exist in the classpath.
  
If you want to get the @value{package} Junit tests to run, there are test dependencies on the following packages:

@table @code

@cindex JPA
@item javax.persistence

For testing the compatibility annotations @code{@@Column} and the like.

@item org.junit

We use Junit for our unit tasks.

@item org.easymock.easymock

We use, and are in love with, EasyMock.  @uref{http://easymock.org/}.  It allows us to mock out dependencies so we can
concentrate on testing a particular class instead of the whole package. 

@item com.h2database

As a test database implementation, H2 is very fast and simple to use.  Not as recommended as a production level database.

@item org.apache.log4j

For logging to files using the @code{log4j.properties} config.  In the log4j package, you can exclude the following
dependencies: @code{com.sun.jmx.jmxri}, @code{com.sun.jdmk.jmxtools}, @code{javax.activation.activation},
@code{javax.jms.jms}, @code{javax.mail.mail}.

@end table

@c ----------------------------------------------------------------
@node How to Upgrade, 4.X to 4.10, Dependencies, Top
@chapter Upgrade From Old Versions

We strive to maintain backwards compatibility and to provide deprecated versions of old classes and methods.
However, sometimes when a new version is released, changes are made that require programmers to change their code
and rarely the on-disk database formats. 

@menu
* 4.X to 4.10::                Upgrade from version 4.X to 4.10
* 3.X to 4.0::                 Upgrade from version 3.X to 4.0
* 2.X to 3.2::                 Upgrade from version 2.X to 3.2
* 2.3 to 2.4::                 Upgrade from version 2.3 to 2.4
@end menu

@c ----------------------------------------------------------------
@node 4.X to 4.10, 3.X to 4.0, How to Upgrade, How to Upgrade
@section Upgrade from Version 4.X to 4.10

4.10 was a reasonably large release containing some feature upgrades and some bug fixes.  No data formats were changed, however
the following API code was altered:

@itemize @bullet

@item We significantly refactored the @code{RawResults} class which is now deprecated and replaced it with the @code{GenericRawResults}
class.  See the @code{GenericRawResults} for more information.  @xref{Raw Queries}.  

@item The @code{Dao} methods @code{queryForAllRaw()} and @code{iteratorRaw()} are now deprecated.  They are replaced with @code{queryRaw()}
methods.  See the @code{Dao} class javadocs for more information. 

@item Before this release the -jdbc and -android versions of @value{package} contained the -core functionality.  In this release we split
out the -core from the other packages so you will now need to install @emph{both} the core and android (or jdbc) packages to get the package
to work.

@end itemize

@c ----------------------------------------------------------------
@node 3.X to 4.0, 2.X to 3.2, 4.X to 4.10, How to Upgrade
@section Upgrade from Version 3.X to 4.0

No data formats were changed, however the following API code was altered.  Removed any outside usage of the @code{DatabaseType} since the
@code{ConnectionSource} now provides it.  Also added features to be able to prepare update and delete statements.  To provide type safety,
we've moved back to using @code{QueryBuilder} so we can have @code{UpdateBuilder} and @code{DeleteBuilder}.  And instead of a
@code{PreparedStmt} there is @code{PreparedQuery}, @code{PreparedUpdate}, and @code{PreparedDelete}.  Here are the details:

@itemize @bullet

@item We have removed most of the cases where the user has to deal with the @code{DatabaseType}.
All you need to set on the DAOs is the @code{ConnectionSource} which provides the database type 
internally.  To create and drop the tables, also, you only need the @code{ConnectionSource}.

@item Constructing a @code{BaseDaoImpl} now self-initializes if it is constructed with a
@code{ConnectionSource}.  This validates the class configurations meaning that it now throws a
@code{SQLException}.

@item Constructing a @code{JdbcConnectionSource} or @code{DataSourceConnectionSource} also now
throws a @code{SQLException} since they also now self-initialize if they are constructed with the URL.
This creates the internal database type and loads the driver class for it.  

@item Deprecated the @code{createJdbcConnectionSource} method in the @code{DatabaseTypeUtils} and
turned the @code{loadDriver} method into a no-op.  You now just instantiate the @code{JdbcConnectionSource}
directly and there is no need for referencing the @code{DatabaseTypeUtils} anymore.

@item @code{Dao.statementBuilder()} method changed (back) to @code{Dao.queryBuilder()}.

@item @code{Dao.queryBuilder()} returns a @code{QueryBuilder} instead of a @code{StatementBuilder}.

@item You now call @code{distinct()} and @code{limit()} on the @code{QueryBuilder}.  Unfortunately,
there are no deprecated methods for them on the @code{StatementBuilder}.

@item You now call @code{selectColumns()} on the @code{QueryBuilder} instead of @code{columns()}
since now we have columns also in the @code{UpdateBuilder}.  Unfortunately, there are no deprecated
methods for them on the @code{StatementBuilder}.

@item You call @code{QueryBuilder.prepare()} instead of @code{StatementBuilder.prepareStatement()}.
It returns a @code{PreparedQuery} instead of a @code{PreparedStmt}.  You pass a @code{PreparedQuery}
into the @code{Dao.query()} and @code{Dao.iterator()} methods instead of a @code{PreparedStmt}.

@item We removed the @code{DatabaseTypeFactory} class since it was no longer needed for Spring
configurations.

@item Removed @code{BaseJdbcDao} since it had been deprecated in 3.X.

@end itemize

@c ----------------------------------------------------------------
@node 2.X to 3.2, 2.3 to 2.4, 3.X to 4.0, How to Upgrade
@section Upgrade from Version 2.X to 3.2

The 3.2 release involved a @emph{very} large code reorganization and migration.  There were no on-disk changes unless you somehow
managed to get ORMLite working previously on Android.  The project was basically split into 3 pieces: core functionality, JDBC
database handlers, and the new Android handler.  With significant help from Kevin G, we abstracted all of the database calls into
3 interfaces: @code{ConnectionSource} (like a @code{DataSource}), @code{DatabaseConnection} (like a @code{Connection}) and
@code{DatabaseResults} (like a @code{ResultSet}).  Once we had the interfaces in place, we wrote delegation classes for JDBC and
Android handlers.  This means that as of 3.X we release 3 packages: ormlite-core (for developers), ormlite-jdbc (for people
connecting to JDBC databases), and ormlite-android (for Android users).  Both the JDBC and Android packages include all of the
core code as well.

Along the way a number of specific changes were made to the methods and classes:

@itemize @bullet

@item Since we split off the JDBC, we renamed the @code{BaseJdbcDao} to be @code{BaseDaoImpl} in the core package. You will
need to adjust any DAOs that you have.

@item We are in the process of allowing custom delete and update methods so we took the major upgrade opportunity to
rename the @code{QueryBuilder} object to be @code{StatementBuilder}.  @emph{NOTE:} this was reverted later.

@item Because of the above, we also renamed @code{Dao.queryBuilder()} method to be @code{statementBuilder()}.  @emph{NOTE:} this
was reverted later.

@item Also renamed the @code{PreparedQuery} object to be @code{PreparedStmt}.

@item One of the big changes for those of you using an external JDBC @code{DataSource} is that you no longer set it on the
DAO directly.  You need to wrap your @code{DataSource} in a @code{DataSourceDatabaseConnection} wrapper class which gets
set on the DAO instead.

@end itemize

Again, there were no on-disk changes unless you somehow managed to get ORMLite working previously on Android.  Since we were using
JDBC before to do the data marshalling and now are doing it by hand, some of the data representations may have changed.  Sorry for
the lack of detail here.

@c ----------------------------------------------------------------
@node 2.3 to 2.4, Examples, 2.X to 3.2, How to Upgrade
@section Upgrade from Version 2.3 to 2.4

A bug was fixed in 2.4 with how we were handling Derby and Hsqldb.  Both of these databases seem to be capitalizing table and field
names in certain situations which meant that customized queries of @value{package} generated tables were affected.  In version 2.4,
all tables and field names are capitalized in the SQL generated for Derby and Hsqldb databases. This means that if you have data
in these databases from a pre 2.4 version, the 2.4 version will not be able to find the tables and fields without renaming to be
uppercase.

@c ----------------------------------------------------------------
@node Examples, JDBC Examples, 2.3 to 2.4, Top
@chapter Example Code

@cindex examples of code
@cindex code examples
Here is some example code to help you get going with @value{package}.  I often find that code is the best documentation of how
to get something working.  Please feel free to suggest additional example packages for inclusion here.  Source code submissions
are welcome as long as you don't get piqued if we don't chose your's.

@menu
* JDBC Examples::           Example code using JDBC calls. 
* Android Examples::        Example code for the Android OS.
@end menu

@c ----------------------------------------------------------------
@node JDBC Examples, Android Examples, Examples, Examples
@section JDBC Examples

@cindex JDBC examples
@cindex H2 examples
All of the JDBC examples below depend on the H2 database which is a native Java SQL implementation.  You can download
the latest jar from the website: @uref{http://www.h2database.com/html/download.html}.

@table @asis

@cindex simple example
@item Simple, basic

This is a simple application which performs database operations on a single class/table.  See soure code in
SVN: @uref{http://ormlite.com/docs/example-simple}.

@cindex foreign objects example
@anchor{foreign objects example}
@item Foreign objects 

This example shows how to use foreign objects.  @xref{Foreign Objects}.  See the soure code in SVN: @uref{http://ormlite.com/docs/example-foreign}.

@cindex field configuration example
@anchor{field config example}
@item Field configuration 

This example shows how you can configure a class in @value{package} using Java code @emph{instead} of annotations.  @xref{Class Configuration}.
See the soure code in SVN: @uref{http://ormlite.com/docs/example-config}.

@cindex many to many example
@anchor{many to many example}
@item Many to many 

This example is a bit more complicated with multiple tables and is designed for folks trying to model a many-to-many relationship.
It has a join-table, foreign fields, and also utilizes inner queries.   See the soure code in
SVN: @uref{http://ormlite.com/docs/example-many}.

@cindex spring example
@anchor{spring example}
@item Spring wiring

To demonstrate how to use Spring wiring with @value{package}, this little program includes classes and XML configuration files.
See soure code in SVN: @uref{http://ormlite.com/docs/example-spring}.

@end table

@c ----------------------------------------------------------------
@node Android Examples, Contributions, JDBC Examples, Examples
@section Android Examples

@cindex Android examples
For Android developers, here some complete example application projects to help you get started with that operating system.

@table @asis

@item HelloAndroid

A basic Android application which does some database operations and then quits.  See the source code in SVN:
@uref{http://ormlite.com/docs/android-hello}.  A tarball of the package is also here: @uref{http://ormlite.com/android/examples/}.

@item ClickCounter

A nice little application written by Kevin G. that provides a counter type application using @value{package}.  See the source code in SVN:
@uref{http://ormlite.com/docs/android-click}.  A tarball of the package is also here: @uref{http://ormlite.com/android/examples/}.

@item NotifyService

An example of a service application that uses @value{package} written by Kevin G.  See the source code in SVN:
@uref{http://ormlite.com/docs/android-notify}.  A tarball of the package is also here: @uref{http://ormlite.com/android/examples/}.

@end table

@c ----------------------------------------------------------------
@node Contributions, License, Android Examples, Top
@chapter Contributions

There are a couple of people that I'd like to thank who helped with the project.

@table @asis

@item Kevin Galligan

Kevin was the impetus and the author of a good bit of the Android compatible code.  He wrote the Android level support classes
and did a ton of beta-testing of it.  He's also provided all of the Android examples.  Thanks much Kevin.  See @uref{http://www.kagii.com/}.

@item Jim Gloor

Jim was one of the Java gurus at a previous company.  Thanks much for his JDBC code samples that started this effort.

@item Nelson Erb

Nelson was our self-appointed documentation and testing volunteer for a year.  He did a great job summarizing sections of this document
so we could create a better 'Getting Started' section.  He also fleshed out a bunch of unit tests to improve coverage in some areas.

@item Robert Adamsky

I worked with Robert at a company where he laid out our entire DAO and hibernate class hierarchy.  The @code{DAO} interface and the
@code{BaseDaoImpl} where in some part modeled after his code.  Thanks dude.  

@end table

Thanks much to them all.

@c ----------------------------------------------------------------
@node License, Index of Concepts, Contributions, Top
@chapter Project License

@cindex license
@cindex copyright
This document is part of the ORMLite package.

Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby
granted, provided that the above copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.

The author may be contacted via @uref{http://ormlite.com/}

@c ----------------------------------------------------------------
@node Index of Concepts,, License, Top
@unnumbered Index of Concepts

@printindex cp
@contents

@bye
