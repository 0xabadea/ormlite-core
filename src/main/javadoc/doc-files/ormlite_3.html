<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on November, 4 2011 by texi2html 1.70 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>ORMLite Package: 3. Custom Statement Builder</title>

<meta name="description" content="ORMLite Package: 3. Custom Statement Builder">
<meta name="keywords" content="ORMLite Package: 3. Custom Statement Builder">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.70">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="NOD33"></a>
<a name="SEC32"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="ormlite_2.html#SEC31" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC33" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="ormlite_2.html#SEC6" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="ormlite.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="ormlite_4.html#SEC39" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="ormlite.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_10.html#SEC67" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 3. Custom Statement Builder </h1>

<p>The DAOs have methods to query for an object that matches an id field (<code>queryForId</code>) as well as query for all
objects (<code>queryForAll</code>) and iterating through all of the objects in a table (<code>iterator</code>).  However, for more
specified queries, there is the <code>queryBuilder()</code> method which returns a <code>QueryBuilder</code> object for the DAO
with which you can construct custom queries to return a sub-set of the table.

</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC33">3.1 Query Builder Basics</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         How to start using the query builder.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC34">3.2 Building Queries</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How to build simple and complex queries.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC35">3.3 Building Statements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         How to build update and delete statements.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC36">3.4 QueryBuilder Capabilities</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Description of the various QueryBuilder methods.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC37">3.5 Where Capabilities</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Description of the various WHERE methods.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC38">3.6 Using Select Arguments</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Using arguments to queries.
</td></tr>
</table>

<hr size="6">
<a name="NOD34"></a>
<a name="SEC33"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC32" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC34" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC32" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC32" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="ormlite_4.html#SEC39" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="ormlite.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_10.html#SEC67" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.1 Query Builder Basics </h2>

<p>Here's how you use the query builder to construct custom queries.  First, it is a good pattern to
set the column names of the fields with Java constants so you can use them in queries.  For example:

</p><table><tr><td>&nbsp;</td><td><pre class="example">@DatabaseTable(tableName = &quot;accounts&quot;)
public class Account {
    public static final String PASSWORD_FIELD_NAME = &quot;password&quot;; 
    
    &hellip;
    @DatabaseField(canBeNull = false, columnName = PASSWORD_FIELD_NAME)
    private String password;
    &hellip;
</pre></td></tr></table>
<p>This allows us to construct queries using the password field name without having the renaming of a field in the future break
our queries.  This should be done <em>even</em> if the name of the field and the column name are the same.

</p><a name="IDX203"></a>
<table><tr><td>&nbsp;</td><td><pre class="example">// get our query builder from the DAO
QueryBuilder&lt;Account, String&gt; queryBuilder =
  accountDao.queryBuilder();
// the 'password' field must be equal to &quot;qwerty&quot;
queryBuilder.where().eq(Account.PASSWORD_FIELD_NAME, &quot;qwerty&quot;);
// prepare our sql statement
PreparedQuery&lt;Account&gt; preparedQuery = queryBuilder.prepare();
// query for all accounts that have that password
List&lt;Account&gt; accountList = accountDao.query(preparedQuery);
</pre></td></tr></table>
<a name="IDX204"></a>
<p>You get a <code>QueryBuilder</code> object from the <code>Dao.queryBuilder</code> method, call methods on it to build your custom
query, call <code>queryBuilder.prepare()</code> which returns a <code>PreparedQuery</code> object, and then pass the <code>PreparedQuery</code>
to the DAO's <code>query</code> or <code>iterator</code> methods.

</p><p>As a short cut, you can also call the <code>prepare()</code> method on the <code>Where</code> object to do something like the
following: 

</p><table><tr><td>&nbsp;</td><td><pre class="example">// query for all accounts that have that password
List&lt;Account&gt; accountList =
   accountDao.query(
      accountDao.queryBuilder().where()
         .eq(Account.PASSWORD_FIELD_NAME, &quot;qwerty&quot;)
         .prepare());
</pre></td></tr></table>
<p>You can use another short cut to call <code>query()</code> or <code>iterator()</code> either on the <code>QueryBuilder</code> or <code>Where</code>
objects.

</p><table><tr><td>&nbsp;</td><td><pre class="example">// query for all accounts that have that password
List&lt;Account&gt; accountList =
      accountDao.queryBuilder().where()
         .eq(Account.PASSWORD_FIELD_NAME, &quot;qwerty&quot;)
         .query();
</pre></td></tr></table>
<hr size="6">
<a name="NOD35"></a>
<a name="SEC34"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC33" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC35" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC32" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC32" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="ormlite_4.html#SEC39" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="ormlite.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_10.html#SEC67" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.2 Building Queries </h2>

<p>There are a couple of different ways that you can build queries.  The <code>QueryBuilder</code> has been written for ease of use
as well for power users.  Simple queries can be done linearly:

</p><table><tr><td>&nbsp;</td><td><pre class="example">QueryBuilder&lt;Account, String&gt; queryBuilder =
  accountDao.queryBuilder();
// get the WHERE object to build our query
Where&lt;Account, String&gt; where = queryBuilder.where();
// the name field must be equal to &quot;foo&quot;
where.eq(Account.NAME_FIELD_NAME, &quot;foo&quot;);
// and
where.and();
// the password field must be equal to &quot;_secret&quot;
where.eq(Account.PASSWORD_FIELD_NAME, &quot;_secret&quot;);
PreparedQuery&lt;Account&gt; preparedQuery = queryBuilder.prepare();
</pre></td></tr></table>
<p>The SQL query that will be generated from the above example will be approximately:

</p><table><tr><td>&nbsp;</td><td><pre class="example">SELECT * FROM account
  WHERE (name = 'foo' AND password = '_secret')
</pre></td></tr></table>
<a name="IDX205"></a>
<p>If you'd rather chain the methods onto one line (like StringBuilder), this can also be written as:

</p><table><tr><td>&nbsp;</td><td><pre class="example">queryBuilder.where()
  .eq(Account.NAME_FIELD_NAME, &quot;foo&quot;)
  .and()
  .eq(Account.PASSWORD_FIELD_NAME, &quot;_secret&quot;);
</pre></td></tr></table>
<p>If you'd rather use parenthesis to group the comparisons properly then you can call:

</p><table><tr><td>&nbsp;</td><td><pre class="example">Where&lt;Account, String&gt; where = queryBuilder.where();
where.and(where.eq(Account.NAME_FIELD_NAME, &quot;foo&quot;),
          where.eq(Account.PASSWORD_FIELD_NAME, &quot;_secret&quot;));
</pre></td></tr></table>
<a name="IDX206"></a>
<p>All three of the above call formats produce the same SQL.  For complex queries that mix ANDs and ORs, the last
format may be necessary to get the grouping correct.  For example, here's a complex query:

</p><table><tr><td>&nbsp;</td><td><pre class="example">Where&lt;Account, String&gt; where = queryBuilder.where();
where.or(
  where.and(
    where.eq(Account.NAME_FIELD_NAME, &quot;foo&quot;),
    where.eq(Account.PASSWORD_FIELD_NAME, &quot;_secret&quot;)),
  where.and(
    where.eq(Account.NAME_FIELD_NAME, &quot;bar&quot;),
    where.eq(Account.PASSWORD_FIELD_NAME, &quot;qwerty&quot;)));
</pre></td></tr></table>
<p>This produces the following approximate SQL:

</p><table><tr><td>&nbsp;</td><td><pre class="example">SELECT * FROM account
  WHERE ((name = 'foo' AND password = '_secret')
         OR (name = 'bar' AND password = 'qwerty'))
</pre></td></tr></table>
<a name="IDX207"></a>
<a name="IDX208"></a>
<p>The <code>QueryBuilder</code> also allows you to set what specific select columns you want returned, specify the 'ORDER BY'
and 'GROUP BY' fields, and various other SQL features (LIKE, IN, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;, IS NULL, DISTINCT, &hellip;).
See section <a href="#SEC37">Where Capabilities</a>. You can also see the javadocs on <code>QueryBuilder</code> and <code>Where</code> classes for more
information.  Here's a <a href="http://www.w3schools.com/Sql/">good SQL reference site</a>.

</p><hr size="6">
<a name="NOD36"></a>
<a name="SEC35"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC34" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC36" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC32" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC32" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="ormlite_4.html#SEC39" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="ormlite.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_10.html#SEC67" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.3 Building Statements </h2>

<p><a name="ANC27"></a>
<a name="ANC28"></a>
The DAO can also be used to construct custom <code>UPDATE</code> and <code>DELETE</code> statements.  Update statements
are used to change certain fields in rows from the table that match the <code>WHERE</code> pattern - or update <em>all</em>
rows if no <code>where()</code>. Delete statements are used to delete rows from the table that match the <code>WHERE</code>
pattern - or delete <em>all</em> rows if no <code>where()</code>.  

</p><p>For example, if you want to update the passwords for all of the Accounts in your table that are currently null to
the string &quot;none&quot;, then you might do something like the following:

</p><table><tr><td>&nbsp;</td><td><pre class="example">UpdateBuilder&lt;Account, String&gt; updateBuilder =
  accountDao.updateBuilder();
// update the password to be &quot;none&quot;
updateBuilder.updateColumnValue(&quot;password&quot;, &quot;none&quot;);
// only update the rows where password is null
updateBuilder.where().isNull(Account.PASSWORD_FIELD_NAME);
accountDao.update(updateBuilder.prepare());
</pre></td></tr></table>
<p>With update, you can also specify the update value to be an expression:

</p><table><tr><td>&nbsp;</td><td><pre class="example">// update hasDogs boolean to true if dogC &gt; 0
updateBuilder.updateColumnExpression(
  &quot;hasDogs&quot;, &quot;dogC &gt; 0&quot;);
</pre></td></tr></table>
<p>To help you construct your expressions, you can use the <code>UpdateBuilder</code>'s escape methods <code>escapeColumnName</code> and
<code>escapeValue</code> can take a string or a <code>StringBuilder</code>.  This will protect you if columns or values are reserved words. 

</p><p>If, instead, you wanted to delete the rows in the Accounts table whose password is currently null, then you might do
something like the following:

</p><table><tr><td>&nbsp;</td><td><pre class="example">DeleteBuilder&lt;Account, String&gt; deleteBuilder =
  accountDao.deleteBuilder();
// only delete the rows where password is null
deleteBuilder.where().isNull(Account.PASSWORD_FIELD_NAME);
accountDao.delete(deleteBuilder.prepare());
</pre></td></tr></table>
<hr size="6">
<a name="NOD37"></a>
<a name="SEC36"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC35" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC37" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC32" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC32" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="ormlite_4.html#SEC39" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="ormlite.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_10.html#SEC67" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.4 QueryBuilder Capabilities </h2>

<p>The following are some details about the various method calls on the <code>QueryBuilder</code> object which build custom
select, delete, and update statements.  See the Javadocs for the <code>QueryBuilder</code> class for the most up-to-date
information about the available methods.  Most of these methods return the <code>QueryBuilder</code> object so they can
be chained.

</p><p>Here's a good <a href="http://www.w3schools.com/sql/sql_select.asp">tutorial of SQL commands</a>.

</p><dl compact="compact">
<dd>
<a name="IDX209"></a>
</dd>
<dt><code> distinct()</code></dt>
<dd>
<p>Add &quot;DISTINCT&quot; clause to the SQL query statement.

</p><p><em>NOTE:</em> Use of this means that the resulting objects may not have a valid ID column value so cannot be deleted
or updated.

</p><a name="IDX210"></a>
</dd>
<dt><code> groupBy(String columnName) </code></dt>
<dd>
<p>This adds a &quot;GROUP&quot; clause to the SQL query statement for the specified column name.  This can be called multiple
times to group by multiple columns.

</p><p><em>NOTE:</em> Use of this means that the resulting objects may not have a valid ID column value so cannot be deleted
or updated.

</p><a name="IDX211"></a>
</dd>
<dt><code> groupByRaw(String sql)</code></dt>
<dd>
<p>Add a raw SQL &quot;GROUP BY&quot; clause to the SQL query statement. This allows you to group by things that are not just column
names.  The SQL argument should not include the &quot;GROUP BY&quot; string.

</p><a name="IDX212"></a>
</dd>
<dt><code> limit(Integer maxRows)</code></dt>
<dd>
<p>Limit the output to maxRows maximum number of rows. Set to null for no limit (the default).

</p><a name="IDX213"></a>
</dd>
<dt><code> offset(Integer startRow)</code></dt>
<dd>
<p>Start the output at this row number. Set to null for no offset (the default). If you are paging through a table,
you should consider using the <code>Dao.iterator()</code> method instead which handles paging with a database cursor.
Otherwise, if you are paging you probably want to specify a column to <code>orderBy</code>.

</p><p><em>NOTE:</em> This is not supported for all databases. Also, for some databases, the limit <em>must</em> also be
specified since the offset is an argument of the limit.

</p><a name="IDX214"></a>
</dd>
<dt><code> orderBy(String columnName, boolean ascending)</code></dt>
<dd>
<p>Add &quot;ORDER BY&quot; clause to the SQL query statement to order the results by the specified column name.  Use the ascending
boolean to get a ascending or descending order.  This can be called multiple times to group by multiple columns.

</p><a name="IDX215"></a>
</dd>
<dt><code> orderByRaw(String sql)</code></dt>
<dd>
<p>Add a raw SQL &quot;ORDER BY&quot; clause to the SQL query statement. This allows you to order by things that are not just columns
but can include calculations.  The SQL argument should not include the &quot;ORDER BY&quot; string.

</p><a name="IDX216"></a>
</dd>
<dt><code> prepare()</code></dt>
<dd>
<p>Build and return a prepared query that can be used by <code>Dao.query(PreparedQuery)</code> or
<code>Dao.iterator(PreparedQuery)</code> methods. If you change the where or make other calls you will need
to re-call this method to re-prepare the statement for execution.

</p><p><a name="ANC29"></a>
<a name="IDX217"></a>
</p></dd>
<dt><code> selectColumns(String... columns)</code></dt>
<dd>
<a name="IDX218"></a>
<a name="IDX219"></a>
<p>Add columns to be returned by the SELECT query and set on any resulting objects. If no columns are selected then
all columns are returned by default. For classes with id columns, the id column is added to the select list
automagically.  All fields not selected in the object with be their default values (null, 0, false, etc.).  

</p><p>This allows you to in effect have lazy loaded fields.  You can specify exactly which fields to be set on the
resulting objects. This is especially helpful if you have large fields in a table that you don't always
want to access.  To get all of the fields on the object later, you can either do another query or call
<code>refresh()</code> with the object.

</p><p><em>WARNING:</em> If you specify any columns to return, then any foreign-collection fields will be returned as null
<em>unless</em> their <code>ForeignCollectionField.columnName</code> is also in the list.  See <a href="ormlite_2.html#ANC26">ForeignCollectionField</a>.

</p></dd>
<dt><code> selectColumns(Iterable&lt;String&gt; columns)</code></dt>
<dd>
<p>Same as the above but with an iterable (such as a collection) instead of a variable list of column names.

</p><a name="IDX220"></a>
<a name="IDX221"></a>
<a name="IDX222"></a>
<a name="IDX223"></a>
</dd>
<dt><code> rawColumns(String... columns)</code></dt>
<dd>
<p>Add raw columns or aggregate functions (COUNT, MAX, ...) to the query. This will turn the query into something
only suitable for using as a raw query.  See section <a href="ormlite_2.html#SEC26">Issuing Raw Queries</a>.

</p><a name="IDX224"></a>
</dd>
<dt><code> where()</code></dt>
<dd>
<p>Build and return the <code>Where</code> object with which you can customize your <code>WHERE</code> SQL statements.
See section <a href="#SEC37">Where Capabilities</a>.

</p></dd>
<dt><code> query()</code></dt>
<dd>
<p>Convenience method to perform the query.  Same as <code>dao.query(queryBuilder.prepare())</code>.

</p></dd>
<dt><code> iterator()</code></dt>
<dd>
<p>Convenience method to generate the iterator for the query.  Same as <code>dao.iterator(queryBuilder.prepare())</code>.

</p></dd>
</dl>

<hr size="6">
<a name="NOD38"></a>
<a name="SEC37"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC36" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC32" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC32" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="ormlite_4.html#SEC39" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="ormlite.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_10.html#SEC67" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.5 Where Capabilities </h2>

<p>The following are some details about the various method calls for adding <code>WHERE</code> SQL statements to your custom
select, delete, and update statements.  See the Javadocs for the <code>Where</code> class for the most up-to-date information
about the available methods.  All of the methods return the <code>Where</code> object so you can chain them together.

</p><p>Here's a good <a href="http://www.w3schools.com/sql/sql_where.asp">tutorial of SQL commands</a>.

</p><dl compact="compact">
<dd>
<a name="IDX225"></a>
</dd>
<dt><code> and()</code></dt>
<dd>
<p>Binary <code>AND</code> operation which takes the previous clause and the next clause and AND's them together.  This is when
you are using inline query calls.

</p><a name="IDX226"></a>
</dd>
<dt><code> and(Where&lt;T, ID&gt; first, Where&lt;T, ID&gt; second, Where&lt;T, ID&gt;... others)</code></dt>
<dd>
<p>AND operation which takes 2 or more arguments and AND's them together.  This is when you are <em>not</em> using inline
query calls but instead want to use standard arguments.

</p><p><em>NOTE:</em> There is no guarantee of the order of the clauses that are generated in the final query.

</p><p><em>NOTE:</em> There is an annoying code warning that I get with the usage of this method with more than 2 arguments that can
be ignored. 

</p></dd>
<dt><code> and(int numClauses)</code></dt>
<dd>
<p>This method needs to be used carefully. This will absorb a number of clauses that were registered previously with
calls to <code>Where.eq()</code> or other methods and will string them together with AND's. There is no way to verify the number of
previous clauses so the programmer has to count precisely.

</p><p><em>NOTE:</em> There is no guarantee of the order of the clauses that are generated in the final query.

</p><a name="IDX227"></a>
</dd>
<dt><code> between(String columnName, Object low, Object high)</code></dt>
<dd>
<p>Add a BETWEEN clause which makes sure the column is between the low and high parameters.

</p><a name="IDX228"></a>
<a name="IDX229"></a>
</dd>
<dt><code> eq(String columnName, Object value)</code></dt>
<dd>
<p>Add a '=' clause which makes sure the column is equal to the value.

</p><a name="IDX230"></a>
</dd>
<dt><code> exists(QueryBuilder&lt;?, ?&gt; subQueryBuilder)</code></dt>
<dd>
<p>Add a EXISTS clause with a sub-query inside of parenthesis.  This will return returns as long as the inner query returns
results.

</p><p><em>NOTE:</em> The sub-query will be prepared at the same time that the outside query is.

</p><a name="IDX231"></a>
<a name="IDX232"></a>
<a name="IDX233"></a>
</dd>
<dt><code> ge(String columnName, Object value)</code></dt>
<dd>
<p>Add a '&gt;=' clause which makes sure the column is greater-than or equals-to the value.

</p><a name="IDX234"></a>
<a name="IDX235"></a>
<a name="IDX236"></a>
</dd>
<dt><code> gt(String columnName, Object value)</code></dt>
<dd>
<p>Add a '&gt;' clause which makes sure the column is greater-than the value.

</p></dd>
<dt><code> idEq(ID id)</code></dt>
<dd>
<p>Add a clause where the ID is equals to the argument.

</p></dd>
<dt><code> idEq(Dao&lt;OD, ?&gt; dataDao, OD data)</code></dt>
<dd>
<p>Add a clause where the ID is extracted from an existing object.

</p><a name="IDX237"></a>
</dd>
<dt><code> in(String columnName, Iterable&lt;?&gt; objects)</code></dt>
<dd>
<p>Add a IN clause which makes sure the column is equal-to one of the objects from the <code>Iterable</code> passed in.  Most likely the
<code>Iterable</code> should probably be on of the <code>Collection</code> classes such as a <code>List</code> or <code>Set</code>.

</p><a name="IDX238"></a>
</dd>
<dt><code> in(String columnName, Object... objects)</code></dt>
<dd>
<p>Add a IN clause which makes sure the column is equal-to one of the objects passed in.

</p><a name="IDX239"></a>
<a name="IDX240"></a>
<a name="IDX241"></a>
</dd>
<dt><code> in(String columnName, QueryBuilder&lt;?, ?&gt; subQueryBuilder)</code></dt>
<dd>
<p>Add a IN clause which makes sure the column is in one of the columns returned from a sub-query inside of parenthesis.
The <code>QueryBuilder</code> must return 1 and only one column which can be set with the <code>QueryBuilder.selectColumns(String...)</code>
method calls. That 1 argument must match the SQL type of the column-name passed to this method.

</p><p><em>NOTE:</em> The sub-query will be prepared at the same time that the outside query is.

</p><a name="IDX242"></a>
<a name="IDX243"></a>
</dd>
<dt><code> isNull(String columnName)</code></dt>
<dd>
<p>Add a 'IS NULL' clause which makes sure the column's value is null. '=' NULL does not work.

</p><a name="IDX244"></a>
<a name="IDX245"></a>
</dd>
<dt><code> isNotNull(String columnName)</code></dt>
<dd>
<p>Add a 'IS NOT NULL' clause so the column must not be null. '&lt;&gt;' NULL does not work.

</p><a name="IDX246"></a>
<a name="IDX247"></a>
<a name="IDX248"></a>
</dd>
<dt><code> le(String columnName, Object value)</code></dt>
<dd>
<p>Add a '&lt;=' clause which makes sure the column is less-than or equals-to the value.

</p><a name="IDX249"></a>
<a name="IDX250"></a>
<a name="IDX251"></a>
</dd>
<dt><code> lt(String columnName, Object value)</code></dt>
<dd>
<p>Add a '&lt;' clause which makes sure the column is less-than the value.

</p><a name="IDX252"></a>
</dd>
<dt><code> like(String columnName, Object value)</code></dt>
<dd>
<p>Add a LIKE clause which makes sure the column match the value using '%' patterns.

</p><a name="IDX253"></a>
<a name="IDX254"></a>
<a name="IDX255"></a>
<a name="IDX256"></a>
</dd>
<dt><code> ne(String columnName, Object value)</code></dt>
<dd>
<p>Add a '&lt;&gt;' clause which makes sure the column is not-equal-to the value.

</p><a name="IDX257"></a>
</dd>
<dt><code> not()</code></dt>
<dd>
<p>Used to NOT the next clause specified when using inline query calls.

</p></dd>
<dt><code> not(Where&lt;T, ID&gt; comparison)</code></dt>
<dd>
<p>Used to NOT the argument clause specified.  This is when you are <em>not</em> using inline
query calls but instead want to use standard arguments.

</p><a name="IDX258"></a>
</dd>
<dt><code> or()</code></dt>
<dd>
<p>Binary <code>OR</code> operation which takes the previous clause and the next clause and OR's them together.  This is when
you are using inline query calls.

</p></dd>
<dt><code> or(Where&lt;T, ID&gt; first, Where&lt;T, ID&gt; second, Where&lt;T, ID&gt;... others)</code></dt>
<dd>
<p>OR operation which takes 2 or more arguments and OR's them together.  This is when you are <em>not</em> using inline
query calls but instead want to use standard arguments.

</p><p><em>NOTE:</em> There is no guarantee of the order of the clauses that are generated in the final query.

</p><p><em>NOTE:</em> There is an annoying code warning that I get with the usage of this method with more than 2 arguments that can
be ignored. 

</p></dd>
<dt><code> or(int numClauses)</code></dt>
<dd>
<p>This method needs to be used carefully. This will absorb a number of clauses that were registered previously with
calls to <code>Where.eq()</code> or other methods and will string them together with OR's. There is no way to verify the number of
previous clauses so the programmer has to count precisely.

</p><a name="IDX259"></a>
</dd>
<dt><code> raw(String rawStatement)</code></dt>
<dd>
<p>Add a raw statement as part of the <code>WHERE</code> that can be anything that the database supports. Using the more
structured methods above is recommended but this gives more control over the query and allows you to utilize
database specific features.

</p></dd>
<dt><code> prepare()</code></dt>
<dd>
<p>A short-cut for calling <code>prepare()</code> on the original <code>QueryBuilder.prepare()</code>.  This method returns a
<code>PreparedQuery</code> object.

</p><a name="IDX260"></a>
</dd>
<dt><code> clear()</code></dt>
<dd>
<p>Clear out the where object so it can be reused in a new query but with the same <code>QueryBuilder</code>.

</p></dd>
<dt><code> query()</code></dt>
<dd>
<p>Convenience method to perform the query.  Same as <code>queryBuilder.query()</code> and
<code>dao.query(queryBuilder.prepare())</code>.

</p></dd>
<dt><code> iterator()</code></dt>
<dd>
<p>Convenience method to generate the iterator for the query.  Same as <code>queryBuilder.iterator()</code> and
<code>dao.iterator(queryBuilder.prepare())</code>.

</p></dd>
</dl>

<hr size="6">
<a name="NOD39"></a>
<a name="SEC38"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC37" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="ormlite_4.html#SEC39" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC32" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC32" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="ormlite_4.html#SEC39" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="ormlite.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_10.html#SEC67" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.6 Using Select Arguments </h2>

<p>Select Arguments are arguments that are used in WHERE operations can be specified directly as value arguments (as in the
above examples) or as a <code>SelectArg</code> object.  SelectArgs are used to set the value of an argument at a later time -
they generate a SQL '<code>?</code>'.

</p><p>For example:

</p><table><tr><td>&nbsp;</td><td><pre class="example">QueryBuilder&lt;Account, String&gt; queryBuilder =
  accountDao.queryBuilder();
Where&lt;Account, String&gt; where = queryBuilder.where();
SelectArg selectArg = new SelectArg();
// define our query as 'name = ?'
where.eq(Account.NAME_FIELD_NAME, selectArg);
// prepare it so it is ready for later query or iterator calls
PreparedQuery&lt;Account&gt; preparedQuery = queryBuilder.prepare();

// later we can set the select argument and issue the query
selectArg.setValue(&quot;foo&quot;);
List&lt;Account&gt; accounts = accountDao.query(preparedQuery);
// then we can set the select argument to another
// value and re-run the query
selectArg.setValue(&quot;bar&quot;);
accounts = accountDao.query(preparedQuery);
</pre></td></tr></table>
<a name="IDX261"></a>
<a name="IDX262"></a>
<p>Certain data types use an internal <code>SelectArg</code> object because the string value of the object does not reliably match the
database form of the object.  <code>java.util.Date</code> is one example of such a type.  Also, in places where strings may have
quote characters inside them that clash with the database escaping quotes, a <code>SelectArg</code> may be required for queries to
be formatted correctly.

</p><p><em>NOTE:</em> <code>SelectArg</code> objects have protection against being used in more than one column name.  You must instantiate a
new object if you want to use a <code>SelectArg</code> with another column.

</p><hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC32" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="ormlite_4.html#SEC39" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="ormlite.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_10.html#SEC67" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="ormlite_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Gray Watson</em> on <em>November, 4 2011</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.70</em></a>.
 </font>
 <br>

</p>
</body>
</html>
